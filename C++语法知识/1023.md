# algorithm库

### 语法

大多数 `<algorithm>` 中的函数都遵循以下基本语法：

```
algorithm_name(container.begin(), container.end(), ...);
```

这里的 `container` 是一个容器对象，`begin()` 和 `end()` 是容器的成员函数，返回指向容器开始和结束的迭代器。

## 实例

### 1. 排序算法

函数：sort

定义：对容器中的元素进行排序。

语法：

```
sort(container.begin(), container.end(), compare_function);
```

其中 compare_function 是一个可选的比较函数，用于自定义排序方式。

## 实例

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
  std::vector<int> numbers = {5, 2, 9, 1, 5, 6};
  std::sort(numbers.begin(), numbers.end());

  for (int num : numbers) {
    std::cout << num << " ";
  }
  std::cout << std::endl;

  return 0;
}
```

#### 默认排序行为

- **排序方向**：**升序**（从小到大）。

- 比较规：默认使用元素的 operator<（小于运算符）进行比较。

  - 如果元素类型（如 int、std::string）已定义 operator<，则直接使用。
  - 例如，对 std::vector<int>{3, 1, 4, 1, 5} 调用 std::sort(v.begin(), v.end()) 后，结果为 {1, 1, 3, 4, 5}。
  
- **适用范围**：必须是**随机访问迭代器**（如 vector、array、deque），不支持 list（用 std::list::sort 代替）。

- **稳定性**：**不稳定**（相等元素的位置可能改变）。

### 如何自定义排序算法

std::sort 支持通过**比较器（comparator）\**自定义排序逻辑。比较器是一个\**二元谓词**（binary predicate），即一个函数或函数对象，接受两个参数，返回 bool 值（表示第一个参数是否“小于”第二个）。

```
std::sort(first, last, comp);  // comp 是可选的比较器
```

- 如果不提供 comp，默认使用 operator<。
- comp(a, b) 返回 true 表示 a 应排在 b 前面。

#### 2. **自定义方式**

有三种常见方法：函数指针、Lambda 表达式、函数对象（functor）。

##### **方法1: 函数指针**

定义一个比较函数，然后传入其指针。

```cpp
bool descending(int a, int b) {
    return a > b;  // 降序：a > b 时 a 排在前面
}

std::sort(v.begin(), v.end(), descending);  // 结果: {5, 4, 3, 1, 1}
```

##### **方法2: Lambda 表达式（推荐，C++11+）**

简洁、内联定义。

```cpp
std::sort(v.begin(), v.end(), [](int a, int b) {
    return a > b;  // 降序
});
```

- 支持捕获外部变量，例如按绝对值排序：

```cpp
std::sort(v.begin(), v.end(), [](int a, int b) {
    return std::abs(a) < std::abs(b);  // 按绝对值升序
});
```

##### **方法3: 函数对象（重载 operator()）**

定义一个类或结构体，重载 operator()。

```cpp
struct Descending {
    bool operator()(int a, int b) const {
        return a > b;  // 降序
    }
};

std::sort(v.begin(), v.end(), Descending{});  // 使用实例
```

- 优点：可复用，且 const 确保线程安全。

#### 3. **高级自定义示例**

- **字符串按长度排序**：

```cpp
std::vector<std::string> words = {"apple", "a", "banana", "cat"};
std::sort(words.begin(), words.end(), [](const std::string& a, const std::string& b) {
    return a.length() < b.length();  // 按长度升序
});
// 结果: {"a", "cat", "apple", "banana"}
```

- **多条件排序**（如先按年龄升序，再按姓名降序）：

```cpp
struct Person {
    int age;
    std::string name;
};

std::vector<Person> people = {/* ... */};
std::sort(people.begin(), people.end(), [](const Person& a, const Person& b) {
    if (a.age != b.age) {
        return a.age < b.age;  // 先按年龄升序
    }
    return a.name > b.name;  // 再按姓名降序
});
```

### 2. 搜索算法

函数：find

定义：在容器中查找与给定值匹配的第一个元素。

语法：

```
auto it = find(container.begin(), container.end(), value);
```

如果找到，it 将指向匹配的元素；如果没有找到，it 将等于 container.end()。

## 实例

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
  std::vector<int> numbers = {1, 2, 3, 4, 5};
  auto it = std::find(numbers.begin(), numbers.end(), 3);

  if (it != numbers.end()) {
    std::cout << "Found: " << *it << std::endl;
  } else {
    std::cout << "Value not found." << std::endl;
  }

  return 0;
}
```

输出结果：

```
Found: 3
```

**std::binary_search**: 对有序区间进行二分查找。

```
std::sort(vec.begin(), vec.end());  // 先排序
bool found = std::binary_search(vec.begin(), vec.end(), 4);
```

**std::find_if**: 查找第一个满足特定条件的元素。

```
auto it = std::find_if(vec.begin(), vec.end(), [](int x) { return x > 3; });
```

### 3. 复制算法

函数：copy

定义：将一个范围内的元素复制到另一个容器或数组。

语法：

```
copy(source_begin, source_end, destination_begin);
```

实例：

## 实例

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
  std::vector<int> source = {1, 2, 3, 4, 5};
  int destination[5];
  std::copy(source.begin(), source.end(), destination);

  for (int i = 0; i < 5; ++i) {
    std::cout << destination[i] << " ";
  }
  std::cout << std::endl;

  return 0;
}
```

输出结果：

```
1 2 3 4 5 
```

容器类型不同怎么办？

在 C++ 的 std::copy 算法中，**容器类型不同完全没问题**！这是因为 std::copy 是**基于迭代器**的通用算法，而不是依赖具体容器类型。它只关心源范围的**输入迭代器**（Input Iterator）和目标范围的**输出迭代器**（Output Iterator）。只要迭代器有效，算法就能工作。

#### 核心条件

- **迭代器兼容**：源提供 [first, last) 输入迭代器，目标提供输出迭代器（从 d_first 开始）。

- 元素可赋值：源元素的类型 T 必须能赋值给目标元素的类型 U（即 U = T成立）。如果类型不同，可能需要：

  - 隐式转换（e.g., int 到 double）。
  - 显式转换（使用 std::transform 代替 std::copy）。
  
- **目标空间**：目标必须有足够空间（至少 (last - first) 个元素）。如果目标是动态容器（如 vector、list），用适配器如 std::back_inserter 自动扩展。

#### 基本示例：不同容器类型

从 std::vector<int>（随机访问）复制到 std::list<int>（双向）。

```cpp
#include <algorithm>
#include <vector>
#include <list>
#include <iostream>

int main() {
    std::vector<int> source = {1, 2, 3, 4, 5};
    std::list<int> target;  // 空列表，类型不同

    // 使用 back_inserter 自动扩展 target
    std::copy(source.begin(), source.end(), std::back_inserter(target));

    // 输出 target: 1 2 3 4 5
    for (int x : target) {
        std::cout << x << " ";  // 输出: 1 2 3 4 5
    }
    std::cout << std::endl;

    return 0;
}
```

- **为什么成功**：vector 的 begin()/end() 是随机访问迭代器（可转换为输入迭代器）；list 的 back_inserter 返回一个插入迭代器（输出迭代器），自动在末尾插入元素。
- **结果**：target 现在有 5 个元素，顺序相同。

#### 不同元素类型示例

从 std::vector<int> 复制到 std::vector<double>（隐式转换）。

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> source = {1, 2, 3};
    std::vector<double> target(3);  // 预分配空间

    std::copy(source.begin(), source.end(), target.begin());  // int -> double 隐式转换

    // 输出 target: 1 2 3
    for (double x : target) {
        std::cout << x << " ";  // 输出: 1 2 3
    }
    std::cout << std::endl;

    return 0;
}
```

- 如果转换失败

  （e.g., 

  int

   到 

  std::string

  ）：编译错误或运行时问题。用 

  std::transform

   自定义转换：

  ```cpp
  #include <string>
  std::vector<std::string> target;
  std::transform(source.begin(), source.end(), std::back_inserter(target),
                 [](int i) { return std::to_string(i); });  // 转换: 1 -> "1"
  ```

#### 高级技巧

1. 使用适配器扩展目标

   ：

   - std::back_inserter(container)：在末尾插入（适合 vector、list、deque）。

   - std::inserter(container, pos)：在指定位置插入。

   - 示例：从数组复制到 

     deque

     。

     ```cpp
     int arr[] = {10, 20, 30};
     std::deque<int> target;
     std::copy(std::begin(arr), std::end(arr), std::back_inserter(target));
     ```

2. 部分复制或条件复制

   ：

   - 用 std::copy_n 复制固定数量：std::copy_n(source.begin(), 2, target.begin());（复制前 2 个）。
   - 条件：std::copy_if(source.begin(), source.end(), std::back_inserter(target), [](int x){ return x > 2; });。

3. 性能与注意

   ：

   - **效率**：线性 O(n)，不受容器类型影响，但动态扩展（如 vector::push_back）可能重分配。
   - **重叠范围**：如果源和目标重叠，用 std::copy_backward。
   - **C++17+**：用 std::copy 的执行策略（如 std::execution::par）并行复制（需 <execution>）。
   - **替代**：如果容器有 assign 成员（如 vector::assign），有时更高效：target.assign(source.begin(), source.end());。

### 4. 比较算法

函数：equal

定义：比较两个容器或两个范围内的元素是否相等。

语法：

```
bool result = equal(first1, last1, first2);

或

bool result = equal(first1, last1, first2, compare_function);
```

## 实例

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
  std::vector<int> v1 = {1, 2, 3, 4, 5};
  std::vector<int> v2 = {1, 2, 3, 4, 5};

  bool are_equal = std::equal(v1.begin(), v1.end(), v2.begin());
  std::cout << (are_equal ? "Vectors are equal." : "Vectors are not equal.") << std::endl;

  return 0;
}
```

输出结果：

```
Vectors are equal.
```

### 5. 修改算法

**std::reverse**: 反转区间内的元素顺序。

```
std::reverse(vec.begin(), vec.end());
```

**std::fill**: 将指定区间内的所有元素赋值为某个值。

```
std::fill(vec.begin(), vec.end(), 0);  // 所有元素设为 0
```

**std::replace**: 将区间内的某个值替换为另一个值。

```
std::replace(vec.begin(), vec.end(), 1, 99);  // 将所有 1 替换为 99
```

### 6.排列算法

**std::next_permutation**: 生成字典序的下一个排列，如果没有下一个排列则返回 false。

```
std::vector<int> vec = {1, 2, 3};
do {
    for (int n : vec) std::cout << n << " ";
    std::cout << std::endl;
} while (std::next_permutation(vec.begin(), vec.end()));
```

**std::prev_permutation**: 生成字典序的上一个排列。

```
std::prev_permutation(vec.begin(), vec.end());
```

### 字典序（Lexicographical Order）简介

**字典序**（也称词典序）是一种自然的顺序排列方式，就像字典中单词的排序：从左到右逐位比较元素，第一个不同位置决定先后（较小的元素在前）。对于数字序列或字符串，它类似于**数值从小到大**的排序，但应用于**排列（permutation）**时，指的是所有可能重排的序列按这种顺序排列。

- 示例

  ：对于元素 {1, 2, 3}，所有 3! = 6 个唯一排列的字典序是：

  | 排列位置 | 序列  | 解释（为什么这样排序）               |
  | -------- | ----- | ------------------------------------ |
  | 1 (最小) | 1 2 3 | 最小的起点（1 开头），然后 2<3       |
  | 2        | 1 3 2 | 1 开头，3>2 但在 1 2 3 后            |
  | 3        | 2 1 3 | 2 开头（大于1），然后最小后缀 1 3    |
  | 4        | 2 3 1 | 2 开头，3>1                          |
  | 5        | 3 1 2 | 3 开头（最大起点），然后最小后缀 1 2 |
  | 6 (最大) | 3 2 1 | 3 开头，最大后缀 2>1                 |

- **关键**：字典序假设元素有 < 操作符（默认升序）。重复元素（如 {1,1,2}）会产生较少唯一排列，算法自动处理（不重复生成）。

- **为什么重要**：用于生成所有排列（如组合问题、排序验证），时间复杂度 O(n)（n 是序列长度），但全遍历需 O(n! * n)。

### std::next_permutation 算法

std::next_permutation（在 <algorithm> 头文件中）用于生成**当前序列的下一个字典序排列**。它**就地修改**序列（in-place），并返回 bool 值表示是否成功生成下一个。

#### 语法

```cpp
#include <algorithm>  // 必须包含

bool std::next_permutation(RandomIt first, RandomIt last);
bool std::next_permutation(RandomIt first, RandomIt last, Compare comp);  // 可选自定义比较器
```

- 参数

  ：

  - first, last：随机访问迭代器（RandomAccessIterator），如 vector、array、deque（不支持 list，因为需要随机访问）。
  - comp（可选）：二元谓词，默认用 operator<（升序字典序）。

- 返回值

  ：

  - true：成功生成下一个排列（序列已修改）。
  - false：当前已是最后一个（最大）排列，则**重置序列为第一个（最小排序）**，并返回 false。

- 行为

  ：

  1. 从右往左找第一个“非递增”位置 i（即 a[i] < a[i+1] 不成立的最后一个 i）。
  2. 如果无（全递增，如 1 2 3），则是最后一个，重置为最小。
  3. 否则，从 i+1 到末尾找大于 a[i] 的最小元素 j，交换 a[i] 和 a[j]。
  4. 反转 i+1 到末尾，使其成为最小后缀。

- **时间复杂度**：O(n)，空间 O(1)。

- **注意**：输入序列应**预先按字典序排序**（从小到大），否则从中间开始生成。支持自定义 comp（如降序：用 greater<T>）。

#### 示例（你的代码）

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};  // 初始：最小排列
    do {
        for (int n : vec) std::cout << n << " ";  // 输出当前
        std::cout << std::endl;
    } while (std::next_permutation(vec.begin(), vec.end()));  // 生成下一个，循环直到 false

    // 输出（全 6 个排列，按字典序）：
    // 1 2 3
    // 1 3 2
    // 2 1 3
    // 2 3 1
    // 3 1 2
    // 3 2 1
    // （然后重置为 1 2 3，返回 false，退出循环）
    return 0;
}
```

- **解释**：do-while 确保先输出初始，然后生成下一个。循环结束后，vec 被重置为 {1,2,3}。

#### 自定义比较器示例（降序字典序）

```cpp
std::vector<int> vec = {3, 2, 1};  // 初始：最大（降序）
std::sort(vec.begin(), vec.end(), std::greater<int>());  // 确保起始为“最小”（3 2 1）
do {
    // 输出从大到小：3 2 1, 3 1 2, 2 3 1 等
} while (std::next_permutation(vec.begin(), vec.end(), std::greater<int>()));
```

### std::prev_permutation 算法

std::prev_permutation 是 next_permutation 的**反向版本**：生成**当前序列的上一个字典序排列**。同样就地修改，并返回 bool。

#### 语法

```cpp
bool std::prev_permutation(RandomIt first, RandomIt last);
bool std::prev_permutation(RandomIt first, RandomIt last, Compare comp);
```

- **参数/返回值**：与 next_permutation 相同。

- 行为

  （镜像 next）：

  1. 从右往左找第一个“非递减”位置 i（即 a[i] > a[i+1] 不成立的最后一个 i）。
  2. 如果无（全递减，如 3 2 1），则是第一个，重置为最大。
  3. 否则，从 i+1 到末尾找小于 a[i] 的最大元素 j，交换 a[i] 和 a[j]。
  4. 反转 i+1 到末尾，使其成为最大后缀。

- **时间复杂度**：O(n)，空间 O(1)。

- **注意**：输入应**预先按字典序反向排序**（从大到小），以从最大开始生成。自定义 comp 类似。

#### 示例

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {3, 2, 1};  // 初始：最大排列
    do {
        for (int n : vec) std::cout << n << " ";
        std::cout << std::endl;
    } while (std::prev_permutation(vec.begin(), vec.end()));  // 生成上一个

    // 输出（反向字典序）：
    // 3 2 1
    // 3 1 2
    // 2 3 1
    // 2 1 3
    // 1 3 2
    // 1 2 3
    // （然后重置为 3 2 1，返回 false）
    return 0;
}
```

- **解释**：从最大开始，逐步生成“上一个”（实际是字典序倒序）。结束后，重置为最大。

### 总结比较

| 方面           | std::next_permutation        | std::prev_permutation        |
| -------------- | ---------------------------- | ---------------------------- |
| **方向**       | 下一个（升序方向）           | 上一个（降序方向）           |
| **起始假设**   | 序列预排序为最小（从小到大） | 序列预排序为最大（从大到小） |
| **结束时重置** | 为最小，返回 false           | 为最大，返回 false           |
| **典型用例**   | 生成所有排列（从小到大遍历） | 生成所有排列（从大到小遍历） |
| **自定义**     | 用 comp 改变序（如降序）     | 同左                         |

### 7. 归并算法

**std::merge**: 将两个有序区间合并到一个有序区间。

```
std::vector<int> vec1 = {1, 3, 5};
std::vector<int> vec2 = {2, 4, 6};
std::vector<int> result(6);
std::merge(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin());
```

**std::inplace_merge**: 在单个区间中合并两个有序子区间。

```
std::inplace_merge(vec.begin(), middle, vec.end());
```

1、如果一开始两个区间不有序会怎么样？

**关键点**：这些算法**不自动排序**！它们严格假设输入范围已经有序。如果输入无序，算法会按照“有序”逻辑逐个比较和放置元素，导致**结果不正确**（输出可能部分有序、乱序或重复）。这是常见错误：算法不会抛异常，而是产生“安静的”错误（silent failure）。

#### 为什么会出错？

- std::merge 和 std::inplace_merge 使用二分选择（从两个范围取较小头元素放入输出），依赖有序性。
- 无序时：取错元素顺序，导致输出不是全局有序。

### 8. 集合算法

**std::set_union**: 计算两个有序集合的并集。

```
std::vector<int> result(10);
auto it = std::set_union(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin());
result.resize(it - result.begin());
```

**std::set_intersection**: 计算两个有序集合的交集。

```
auto it = std::set_intersection(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin());
result.resize(it - result.begin());
```

**std::set_difference**: 计算集合的差集。

```
auto it = std::set_difference(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin());
result.resize(it - result.begin());
```

为什么强调有序？

这些算法**严格要求输入范围已排序**（默认升序），原因如下：

1. 算法原理（归并式实现）

   ：

   - 它们使用

     双指针归并（two-pointer merge）

     ：从两个范围的开头开始，逐一比较当前头元素（用 

     <

      判断）。

     - **并集**：取较小的一个（或两者都取，如果不相等）；相等时取一个（去重）并推进两者。
     - **交集**：只取相等元素，并推进两者。
     - **差集**：取第一个范围中 < 第二个头元素的元素，推进第一个；相等时跳过第一个。

   - 这依赖有序性：指针只能**单向推进**（从左到右），确保比较的元素是“当前最小”。类似于归并排序的合并步骤。

   - 如果无序，指针推进逻辑失效，无法正确识别“最小”或“包含”关系。

2. 效率

   ：

   - 有序输入：O(n) 线性时间（单次遍历）。
   - 无序：需先 std::sort（O(n log n)），总复杂度更高。但 STL 不内置排序步骤，以保持通用性和性能。

3. 语义正确性

   ：

   - “集合”概念隐含无序，但 STL 这些算法针对**有序集合**（如 std::set），确保输出也排序。无序时，输出可能乱序或遗漏。

4. 设计哲学

   ：

   - STL 鼓励**组合使用**：先 sort，再集合运算。适用于关联容器（如 set 的迭代器天然有序）。

### 无序输入有问题吗？

**是的，有严重问题**！算法不会自动排序或检查有序性。如果输入无序：

- **结果不正确**：输出可能包含错误元素、重复、遗漏，或乱序（违反集合语义）。
- **无异常**：安静失败（silent failure），运行正常但逻辑错。
- **性能浪费**：仍 O(n) 执行，但结果无效。

### 9. 其他有用算法

***\*std::accumulate\**（需要 <numeric> 库）**：计算范围内元素的累计和。

```
#include <numeric>
int sum = std::accumulate(vec.begin(), vec.end(), 0);
```

最后一个参数是偏移量

**std::for_each**: 对区间内的每个元素执行操作。

```
std::for_each(vec.begin(), vec.end(), [](int& x) { x += 1; });
```

**std::min_element** 和 **std::max_element**: 查找区间内的最小值和最大值。

```
auto min_it = std::min_element(vec.begin(), vec.end());
auto max_it = std::max_element(vec.begin(), vec.end());
```

# 2.iterator库

C++ 标准库中的 `<iterator>` 头文件提供了一组工具，用于遍历容器中的元素。迭代器是 C++ 标准模板库（STL）中的核心概念之一，它允许程序员以统一的方式访问容器中的元素，而不需要关心容器的具体实现细节。

迭代器是一个对象，它提供了一种方法来遍历容器中的元素。迭代器可以被视为指向容器中元素的指针，但它比指针更加灵活和强大。迭代器可以用于访问、修改容器中的元素，并且可以与 STL 算法一起使用。

迭代器主要分为以下几类：

1. **输入迭代器（Input Iterator）**：只能进行单次读取操作，不能进行写入操作。
2. **输出迭代器（Output Iterator）**：只能进行单次写入操作，不能进行读取操作。
3. **正向迭代器（Forward Iterator）**：可以进行读取和写入操作，并且可以向前移动。
4. **双向迭代器（Bidirectional Iterator）**：除了可以进行正向迭代器的所有操作外，还可以向后移动。
5. **随机访问迭代器（Random Access Iterator）**：除了可以进行双向迭代器的所有操作外，还可以进行随机访问，例如通过下标访问元素。

## 你常用的 `for(auto it = ...; ++it)` 实际上隐藏了这些类型

我们来看不同容器的例子👇

### 1️⃣ `std::vector`

```
std::vector<int> v;
auto it = v.begin(); // 随机访问迭代器
it += 5;  // ✅ 可以直接跳 5 个位置
```

👉 所以 `vector` 的 `iterator` 是 **Random Access Iterator**。
 因为它的底层是数组，支持随机访问。

------

### 2️⃣ `std::list`

```
std::list<int> lst;
auto it = lst.begin(); 
--it;   // ✅ 可以往后退
it += 5; // ❌ 不行，不能直接跳
```

👉 所以 `list` 的 `iterator` 是 **Bidirectional Iterator**。
 它支持前后移动，但不能跳，因为底层是链表。

------

### 3️⃣ `std::forward_list`

```
std::forward_list<int> flst;
auto it = flst.begin();
++it;  // ✅ 可以往前
--it;  // ❌ 不行，不能回头
```

👉 它的迭代器是 **Forward Iterator**，只能前进。
 （单向链表嘛）

------

### 4️⃣ 输入输出流迭代器

```
std::istream_iterator<int> in(std::cin);
std::ostream_iterator<int> out(std::cout, " ");
```

👉 输入流只能“读一次”；输出流只能“写一次”。
 它们分别是 **Input** 和 **Output Iterator**。

------

## ⚙️ 四、标准库算法为什么关心这个

STL 算法的模板参数一般写成：

```
template <class RandomAccessIterator>
void sort(RandomAccessIterator first, RandomAccessIterator last);
```

注意：这里写的是 **RandomAccessIterator**，
 意味着 `std::sort()` 只能用于随机访问迭代器（`vector`, `array`, `deque`），
 **不能**用于 `list` 或 `forward_list`。

这就是迭代器“类型区分”的真正意义：

> 👉 让编译器在编译期就知道某个算法是否能作用在这个容器上。

------

## 📦 五、一句话理解：

> 迭代器的五种类型不是让你手动区分的，
> 而是让 **标准库算法** 知道“它能对容器做哪些操作”。

你只需要记得：

- 日常遍历时，`auto it = c.begin()` 就行；
- 不同容器的迭代器“能力”不同；
- 一些算法（如 `sort`, `reverse`）只接受特定能力等级的迭代器。

# 3.`functional`库

C++ 标准库中的 `<functional>` 头文件提供了一组函数模板，这些模板允许我们使用函数对象（function objects）作为参数传递给算法，或者作为算法的返回值。函数对象是那些重载了 `operator()` 的对象，它们可以像普通函数一样被调用。

在 C++ 中，函数对象是一种特殊的类，它重载了 `operator()` 来允许对象像函数一样被调用。这使得我们可以将行为作为对象传递，增加了代码的灵活性和可重用性。

## 常用函数对象

`<functional>` 头文件中定义了一些常用的函数对象，包括：

- `std::function`：一个通用的多态函数封装器。
- `std::bind`：用于绑定函数的参数。
- `std::plus`、`std::minus`、`std::multiplies`、`std::divides`、`std::modulus`：基本的算术操作。
- `std::equal_to`、`std::not_equal_to`、`std::greater`、`std::less`、`std::greater_equal`、`std::less_equal`：比较操作。
- `std::unary_negate`、`std::binary_negate`：逻辑否定操作。
- `std::logical_and`、`std::logical_or`、`std::logical_not`：逻辑操作。

## 🧭 一览表

| 功能类别         | 示例                                                      | 是否被 Lambda 取代 | 是否仍常用             | 说明                                                         |
| ---------------- | --------------------------------------------------------- | ------------------ | ---------------------- | ------------------------------------------------------------ |
| **通用函数封装** | `std::function`                                           | ❌ 否               | ✅ 是                   | Lambda 常配合它使用，它是 Lambda 的“容器”                    |
| **函数绑定**     | `std::bind`                                               | ✅ 基本被取代       | ⚠️ 偶尔使用             | Lambda 更直观；Bind 只在旧代码或特殊接口中出现               |
| **算术操作**     | `std::plus`, `std::minus` 等                              | ✅ 是               | ⚠️ 较少用               | Lambda 写起来更清晰，例如 `[](int a, int b){ return a + b; }` |
| **比较操作**     | `std::less`, `std::greater` 等                            | ⚠️ 部分取代         | ✅ 仍常用               | 在排序、容器比较时仍很常见，如 `std::map<int,int, std::greater<int>>` |
| **逻辑操作**     | `std::logical_and`, `std::logical_or`, `std::logical_not` | ✅ 是               | ⚠️ 几乎只在泛型模板中用 |                                                              |
| **逻辑否定**     | `std::unary_negate`, `std::binary_negate`                 | ✅ 完全被取代       | ❌ 不再使用             | 已过时（C++11 起推荐用 lambda）                              |

它的核心作用是：

> 提供**函数对象（function objects）**、**函数适配器（function adapters）**、**绑定工具（bind）**、**通用函数包装器（std::function）**等，用来让“函数”这种概念在 C++ 中可以像“变量”一样被传递、存储、组合和调用。

### 使用 `std::function`

`std::function` 是一个模板类，可以存储、调用和复制任何可调用对象，比如函数、lambda 表达式或函数对象。

通俗说，它是一个“盒子”，可以保存**任意类型的可调用对象**（普通函数、函数指针、lambda、函数对象、成员函数绑定体等），并通过统一的接口 `operator()` 调用它们。
 它实现了 *类型擦除（type erasure）*：外界只知道“可以这样调用 `R(Args...)`”，不需要知道盒子里具体装的是什么类型。

# 意义 / 为什么要用它

- **统一接口**：把不同来源、不同形式的可调用对象都当作同一种类型传递和存储（比如回调、事件处理、命令队列等）。
- **解耦**：API 接受 `std::function`，调用方可以传普通函数、lambda、bind 表达式或仿函数，调用者和实现者不再耦合具体类型。
- **容器/成员存储**：可以把各种可调用对象放到容器里或作为类成员保存，稍后再调用。

# 何时用 vs 不用

用：

- 需要以运行时多态/动态替换回调时（例如 GUI 事件、异步回调、策略切换）。
- 回调/接口要求不同调用者传入不同实现，但调用方只关心签名。

不用（或慎用）：

- 热路径性能敏感处：`std::function` 有一定开销（类型擦除、可能的堆分配）。
- 如果可以用模板（`template<typename F> void foo(F f)`）做到编译期多态并内联，那通常更快、更优（避免运行时开销）。
- 想保存**move-only**可调用对象（注意下面的限制）。

# 基本用法（示例）

```
#include <functional>
#include <iostream>

int add(int a, int b) { return a + b; }

int main() {
    // 保存普通函数
    std::function<int(int,int)> f1 = add;
    std::cout << f1(2,3) << "\n"; // 5

    // 保存 lambda
    std::function<int(int,int)> f2 = [](int x, int y){ return x * y; };
    std::cout << f2(4,5) << "\n"; // 20

    // 保存无参函数
    std::function<void()> f3 = [](){ std::cout << "hello\n"; };
    f3();

    return 0;
}
```

# 常见场景示例

## 1. 回调（Callback）

```
void set_callback(std::function<void(int)> cb);

set_callback([](int code){ std::cout << "code=" << code << "\n"; });
```

## 2. 保存到容器

```
std::vector<std::function<void()>> tasks;
tasks.push_back([](){ std::cout << "task1\n"; });
tasks.push_back([](){ std::cout << "task2\n"; });
for (auto &t : tasks) t();
```

## 3. 绑定成员函数

两种方式常用：`std::bind` 或 用 lambda 包装（推荐 lambda，更清晰）：

```
struct Foo {
    void method(int x) { std::cout << "Foo::" << x << "\n"; }
};

Foo foo;
std::function<void(int)> cb1 = std::bind(&Foo::method, &foo, std::placeholders::_1);

// 推荐：用 lambda
std::function<void(int)> cb2 = [&foo](int x){ foo.method(x); };
```

## 4. 返回一个可调用对象

```
std::function<int(int)> make_adder(int a) {
    return [a](int b){ return a + b; };
}

auto add5 = make_adder(5);
std::cout << add5(3); // 8
```

# `std::function` 的 API 要点

- `operator()`：调用被包装的可调用对象（行为与目标对象一致，调用时会转发异常）。
- `operator bool()`：可以检查是否包装了有效目标（是否为空）。
- `target_type()` / `target<T>()`：可以在运行时尝试获取内部真实类型（但一般不常用，且有局限）。
- `swap`、拷贝、赋值：`std::function` 可拷贝（如果内部可调用对象是可拷贝的）。
- 空状态：默认构造会得到空的 `std::function`，调用空的 `std::function` 会抛 `std::bad_function_call`。

例：

```
std::function<void()> f;
if (f) { f(); } // safe check
else { /* 没有目标 */ }
```

2.bind

`std::bind` 允许我们创建一个可调用对象，它在调用时会将给定的参数绑定到一个函数或函数对象。

```cpp
#include <iostream>
#include <functional>

int add(int a, int b) {
  return a + b;
}

int main() {
  auto bound_add = std::bind(add, 5, std::placeholders::_1);
  std::cout << bound_add(10) << std::endl; // 输出: 15

  return 0;
}
```

## 🧩 一、`std::bind` 是什么？

`std::bind` 是 `<functional>` 头文件中的一个函数模板，用来**“绑定”一个可调用对象（函数、函数指针、成员函数、lambda、仿函数等）的一部分参数**，
 从而生成一个新的**可调用对象**（通常叫“绑定器”）。

简单来说，它能让你提前固定（或重新排列）函数的某些参数，让生成的对象更容易在算法或回调中使用。

------

## 🧠 二、为什么需要 `std::bind`

在现代 C++ 之前（C++11 之前），lambda 表达式还没有出现，而很多 STL 算法需要传入**一个只有一个参数的函数对象**。

比如你有个函数需要两个参数，但算法只能传入一个参数，这时 `std::bind` 就能“绑定”其中一个参数，变成一个只需要一个参数的函数。

------

## ⚙️ 三、语法格式

```
#include <functional>

auto new_func = std::bind(callable, arg1, arg2, ...);
```

- `callable`：你要绑定的函数或可调用对象。
- `arg1, arg2, ...`：要绑定的参数。
  - 如果你用 `_1`, `_2`, `_3` 等占位符（来自 `std::placeholders`），表示“调用时再传入这些位置的参数”。

------

## 🧩 四、例子讲解

### 例子 1：绑定普通函数

```cpp
#include <iostream>
#include <functional>
using namespace std;

void greet(string name, int times) {
    for (int i = 0; i < times; ++i)
        cout << "Hello, " << name << "!" << endl;
}

int main() {
    // 绑定第二个参数，固定 times = 3
    auto greet3 = bind(greet, placeholders::_1, 3);

    greet3("Alice");
    greet3("Bob");
}
```

🔹 **输出：**

```
Hello, Alice!
Hello, Alice!
Hello, Alice!
Hello, Bob!
Hello, Bob!
Hello, Bob!
```

这里 `bind` 把 `greet` 的第二个参数固定为 3，生成的新函数 `greet3` 只需要传入一个参数（`name`）。

------

### 例子 2：绑定成员函数

```cpp
#include <iostream>
#include <functional>
using namespace std;

struct Printer {
    void print(int x) const {
        cout << "Value: " << x << endl;
    }
};

int main() {
    Printer p;

    // 绑定成员函数：第一个参数是对象指针或引用
    auto f = bind(&Printer::print, &p, placeholders::_1);
    f(42);
}
```

🔹 **输出：**

```
Value: 42
```

这里 `bind` 让 `f` 成为了一个“普通函数对象”，虽然它内部实际调用了 `p.print(42)`。

------

### 例子 3：参数重排

```cpp
#include <iostream>
#include <functional>
using namespace std;

void show(int a, int b, int c) {
    cout << a << " " << b << " " << c << endl;
}

int main() {
    // 改变参数顺序
    auto reorder = bind(show, placeholders::_2, 10, placeholders::_1);
    reorder(1, 2); // _1 = 1, _2 = 2
}
```

🔹 **输出：**

```
2 10 1
```

说明：

- `_2` → 第一个参数位置上放调用时传入的第二个参数。
- `_1` → 第三个参数位置上放调用时传入的第一个参数。
- 中间的 `10` 是固定值。

------

## 🔧 五、使用场景

1. **在 STL 算法中使用**

   ```
   vector<int> v = {1, 2, 3, 4, 5};
   for_each(v.begin(), v.end(), bind(greet, "Tom", placeholders::_1));
   ```

   可把原本需要两个参数的函数改造成只接受一个参数的形式。

2. **绑定成员函数到回调系统**

   - 在 GUI 框架、线程库中经常需要把成员函数传给回调，但它们往往要求一个普通函数。
   - 用 `std::bind(&Class::method, &object, placeholders::_1)` 就能解决。

3. **旧项目中替代 lambda（在 C++11 以前）**

   - 现在 lambda 更灵活，写法更清晰，但理解 `bind` 仍然有助于阅读老代码。

基本的算术操作：plus`、`std::minus`、`std::multiplies`、`std::divides`、`std::modulus

## 🧩 一、它们是什么？

这些类型其实是**函数对象类模板（function object classes）**，定义在 `<functional>` 里。
 比如：

```
template<class T>
struct plus {
    constexpr T operator()(const T& lhs, const T& rhs) const {
        return lhs + rhs;
    }
};
```

这意味着：
 `std::plus<int>` 是一个**对象类型**，这个对象**重载了 `()` 运算符**，所以你可以把它当作函数来用。

------

## 🧠 二、为什么要有它们？

在 STL 算法中，我们经常需要把操作（比如“加法”、“乘法”）当作参数传给算法，比如 `std::accumulate()`、`std::transform()`。
 但 C++ 里，`+`、`-` 这些运算符不能直接作为函数传递。
 于是 `<functional>` 就提供了这些“函数对象”来代替。

------

## ⚙️ 三、常用的算术函数对象

| 名称                 | 对应运算符 | 示例结果                             |
| -------------------- | ---------- | ------------------------------------ |
| `std::plus<T>`       | `+`        | `plus<int>()(3, 4)` → 7              |
| `std::minus<T>`      | `-`        | `minus<int>()(10, 2)` → 8            |
| `std::multiplies<T>` | `*`        | `multiplies<int>()(2, 3)` → 6        |
| `std::divides<T>`    | `/`        | `divides<double>()(10.0, 4.0)` → 2.5 |
| `std::modulus<T>`    | `%`        | `modulus<int>()(10, 3)` → 1          |

------

## 🧩 四、基本用法示例

```cpp
#include <iostream>
#include <functional>
using namespace std;

int main() {
    cout << std::plus<int>()(3, 5) << endl;        // 8
    cout << std::minus<int>()(10, 4) << endl;      // 6
    cout << std::multiplies<int>()(2, 3) << endl;  // 6
    cout << std::divides<double>()(7.5, 2.5) << endl; // 3.0
    cout << std::modulus<int>()(10, 3) << endl;    // 1
}
```

------

## 🧮 五、在算法中的使用场景

### 1️⃣ 累加求和 (`std::accumulate`)

```cpp
#include <iostream>
#include <vector>
#include <numeric>     // accumulate
#include <functional>  // plus
using namespace std;

int main() {
    vector<int> v = {1, 2, 3, 4, 5};
    int sum = accumulate(v.begin(), v.end(), 0, std::plus<int>());
    cout << sum << endl;  // 输出 15
}
```

说明：
 `accumulate` 默认也是用 `+` 运算，你可以自定义，比如换成 `std::multiplies<int>()` 实现“连乘积”：

```
int product = accumulate(v.begin(), v.end(), 1, std::multiplies<int>());
cout << product << endl; // 输出 120
```

------

### 2️⃣ 元素运算 (`std::transform`)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
using namespace std;

int main() {
    vector<int> a = {1, 2, 3};
    vector<int> b = {4, 5, 6};
    vector<int> result(3);

    transform(a.begin(), a.end(), b.begin(), result.begin(), std::plus<int>());
    // result = {5, 7, 9}

    for (int n : result)
        cout << n << " ";
}
```

🔹 `std::transform` 第五个参数是“二元操作”，这里用 `std::plus<int>()` 来实现“两个向量对应元素相加”。

比较操作

## 🧩 一、它们是什么？

这些都定义在 `<functional>` 头文件中，是模板类，用于封装常见的**比较运算符**：

| 名称                    | 对应运算符 | 作用                     |
| ----------------------- | ---------- | ------------------------ |
| `std::equal_to<T>`      | `==`       | 判断两个值是否相等       |
| `std::not_equal_to<T>`  | `!=`       | 判断两个值是否不相等     |
| `std::greater<T>`       | `>`        | 判断左值是否大于右值     |
| `std::less<T>`          | `<`        | 判断左值是否小于右值     |
| `std::greater_equal<T>` | `>=`       | 判断左值是否大于等于右值 |
| `std::less_equal<T>`    | `<=`       | 判断左值是否小于等于右值 |

------

## ⚙️ 二、内部结构（以 `std::less` 为例）

这些函数对象的实现都很简单，比如 `std::less`：

```
template <class T>
struct less {
    constexpr bool operator()(const T& lhs, const T& rhs) const {
        return lhs < rhs;
    }
};
```

换句话说，
 `std::less<int>()(3, 5)`
 等价于
 `3 < 5`。

------

## 🧠 三、为什么要有它们？

在 STL 中，算法和容器常常要接受“比较逻辑”作为模板参数或构造参数。

👉 比如：

- `std::sort()` 可以使用自定义比较器；
- `std::map` / `std::set` 用比较函数决定排序顺序；
- `std::priority_queue` 也需要比较函数定义“堆顶规则”。

这些地方都需要一个“**可调用对象**”来表示比较逻辑，而 `<functional>` 就提供了通用的标准实现。

------

## 💡 四、基本使用示例

```cpp
#include <iostream>
#include <functional>
using namespace std;

int main() {
    cout << std::equal_to<int>()(3, 3) << endl;       // true
    cout << std::not_equal_to<int>()(3, 4) << endl;   // true
    cout << std::greater<int>()(5, 3) << endl;        // true
    cout << std::less<int>()(2, 8) << endl;           // true
    cout << std::greater_equal<int>()(5, 5) << endl;  // true
    cout << std::less_equal<int>()(3, 4) << endl;     // true
}
```

输出（布尔值转成 1/0）：

```
1
1
1
1
1
1
```

------

## 🔧 五、在 STL 算法中的应用

### 1️⃣ `std::sort` 排序示例

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
using namespace std;

int main() {
    vector<int> v = {5, 2, 8, 3, 1};

    sort(v.begin(), v.end(), std::less<int>());   // 升序
    // sort(v.begin(), v.end(), std::greater<int>()); // 降序

    for (int n : v) cout << n << " ";
}
```

输出：

```
1 2 3 5 8
```

------

### 2️⃣ `std::map`、`std::set` 的排序规则

STL 的有序关联容器默认使用 `std::less` 作为比较方式。

```cpp
#include <map>
#include <iostream>
using namespace std;

int main() {
    map<int, string, std::greater<int>> m; // 改成降序排列
    m[1] = "one";
    m[3] = "three";
    m[2] = "two";

    for (auto& [k, v] : m)
        cout << k << ": " << v << endl;
}
```

输出：

```
3: three
2: two
1: one
```

🔹 说明：
 `map<int, string, greater<int>>` 中，键的比较规则由 `greater<int>` 决定。
 如果不写，默认是 `less<int>`（升序）。

------

### 3️⃣ `std::max_element`、`std::min_element`

这些算法也可以传入比较对象：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
using namespace std;

int main() {
    vector<int> v = {10, 30, 20};

    auto max_it = max_element(v.begin(), v.end(), std::less<int>());  // 默认就是less
    auto min_it = min_element(v.begin(), v.end(), std::less<int>());

    cout << "max = " << *max_it << ", min = " << *min_it << endl;
}
```

------

## 🧮 六、它们与 Lambda 对比

| 特性             | 函数对象（如 `std::less`） | Lambda                            |
| ---------------- | -------------------------- | --------------------------------- |
| 可读性           | 简洁、通用                 | 更灵活、更易读                    |
| 泛型性           | 模板化、可直接用于任意类型 | 需要泛型 lambda（C++14+）         |
| 用于容器模板参数 | ✅ 推荐使用                 | ❌ 不支持（lambda 无默认构造函数） |
| 算法中临时使用   | ✅ 可行                     | ✅ 更方便                          |

# 4.`numeric`库

## 常用函数

### 1. `accumulate`

`accumulate` 函数用于计算容器中所有元素的总和。它接受三个参数：容器的开始迭代器、结束迭代器和初始值。

**语法**:

```
template <InputIterator Iter, class T>
T accumulate(Iter first, Iter last, T init);
```

**实例**:

## 实例

```cpp
#include <iostream>
#include <numeric>
#include <vector>

int main() {
  std::vector<int> v = {1, 2, 3, 4, 5};
  int sum = std::accumulate(v.begin(), v.end(), 0);
  std::cout << "Sum: " << sum << std::endl; // 输出: Sum: 15
  return 0;
}
```

### 2. `inner_product`

`inner_product` 函数用于计算两个容器中对应元素乘积的总和。

**语法**:

```
template <InputIterator1 Iter1, InputIterator2 Iter2, class T>
T inner_product(Iter1 first1, Iter1 last1, Iter2 first2, T init);
```

**实例**:

## 实例

```cpp
#include <iostream>
#include <numeric>
#include <vector>

int main() {
  std::vector<int> v1 = {1, 2, 3};
  std::vector<int> v2 = {4, 5, 6};
  int product_sum = std::inner_product(v1.begin(), v1.end(), v2.begin(), 0);
  std::cout << "Product Sum: " << product_sum << std::endl; // 输出: Product Sum: 32
  return 0;
}
```

### 3. `partial_sum`

`partial_sum` 函数用于计算容器中元素的部分和，并将结果存储在另一个容器中。

**语法**:

```
template <InputIterator InIter, OutputIterator OutIter>
OutIter partial_sum(InIter first, InIter last, OutIter result);
```

**实例**:

## 实例

```cpp
#include <iostream>
#include <numeric>
#include <vector>

int main() {
  std::vector<int> v = {1, 2, 3, 4};
  std::vector<int> result(v.size());
  std::partial_sum(v.begin(), v.end(), result.begin());
  for (int i : result) {
    std::cout << i << " "; // 输出: 1 3 6 10
  }
  return 0;
}
```

### 4. `adjacent_difference`

`adjacent_difference` 函数用于计算容器中相邻元素的差值，并将结果存储在另一个容器中。

**语法**:

```
template <InputIterator InIter, OutputIterator OutIter>
OutIter adjacent_difference(InIter first, InIter last, OutIter result);
```

**实例**:

## 实例

```cpp
#include <iostream>
#include <numeric>
#include <vector>

int main() {
  std::vector<int> v = {1, 2, 3, 4};
  std::vector<int> result(v.size() - 1);
  std::adjacent_difference(v.begin(), v.end(), result.begin());
  for (int i : result) {
    std::cout << i << " "; // 输出: 1 1 1
  }
  return 0;
}
```

### 5. std::gcd

使用 std::gcd 计算两个整数的最大公约数：

## 实例

```cpp
#include <iostream>
#include <numeric>

int main() {
  int a = 48;
  int b = 18;
  int result = std::gcd(a, b); // 计算 48 和 18 的最大公约数
  std::cout << "GCD: " << result << std::endl; // 输出 6
  return 0;
}
```

### 6. std::lcm

使用 std::lcm 计算两个整数的最小公倍数：

## 实例

```cpp
#include <iostream>
#include <numeric>

int main() {
  int a = 48;
  int b = 18;
  int result = std::lcm(a, b); // 计算 48 和 18 的最小公倍数
  std::cout << "LCM: " << result << std::endl; // 输出 144
  return 0;
}
```

### 7. std::iota

## 实例

```cpp
#include <iostream>
#include <numeric>  // 包含 numeric 头文件
#include <vector>

int main() {
  std::vector<int> v(5); // 创建一个包含5个元素的向量

  // 使用 std::iota 填充向量，起始值为1
  std::iota(std::begin(v), std::end(v), 1);

  // 输出填充后的向量
  for (int i : v) {
    std::cout << i << " ";
  }
  std::cout << std::endl; // 输出: 1 2 3 4 5

  return 0;
}
```

使用 std::iota 填充范围内的序列值。

```
template<class ForwardIt, class T>
void iota(ForwardIt first, ForwardIt last, T value);
```

### 8.查找最大值与最小值

`min_element` 和 `max_element` 函数用于找到容器中的最大值和最小值。

## 实例

```cpp
#include <iostream>
#include <numeric>
#include <vector>
#include <algorithm> // 为了使用 std::min_element 和 std::max_element

int main() {
  // 定义一个包含整数的向量
  std::vector<int> v = {3, 1, 4, 1, 5, 9};

  // 计算最小值和最大值
  int min_val = *std::min_element(v.begin(), v.end());
  int max_val = *std::max_element(v.begin(), v.end());

  // 计算总和
  int sum_val = std::accumulate(v.begin(), v.end(), 0);

  // 计算平均值
  double avg_val = static_cast<double>(sum_val) / v.size();

  // 输出结果
  std::cout << "Min: " << min_val << std::endl;
  std::cout << "Max: " << max_val << std::endl;
  std::cout << "Sum: " << sum_val << std::endl;
  std::cout << "Average: " << avg_val << std::endl;

  return 0;
}
```

输出结果为：

```
Min: 1
Max: 9
Sum: 23
Average: 3.83333
```

# 5.`complex`库

处理负数，

```cpp
#include <iostream>
#include <complex>  // 复数头文件

int main() {
  std::complex<double> z1(3.0, 4.0); // 3 + 4i
  std::complex<double> z2(1.0, -2.0); // 1 - 2i

  std::cout << "z1 = " << z1 << std::endl;
  std::cout << "z2 = " << z2 << std::endl;
}
```

输出：

```
z1 = (3,4)
z2 = (1,-2)
```

## 基本语法

### 创建复数

```
std::complex<double> c(5.0, 3.0); // 创建一个复数 5 + 3i
```

### 访问实部和虚部

```
double realPart = c.real(); // 获取实部
double imagPart = c.imag(); // 获取虚部
```

### 复数的基本运算

C++ 标准库 `<complex>` 支持以下基本运算：

- 加法：`operator+`
- 减法：`operator-`
- 乘法：`operator*`
- 除法：`operator/`
- 共轭：`conj`
- 模：`abs`
- 辐角：`arg`

**1 、获取实部和虚部**

```
std::cout << "实部: " << z1.real() << std::endl; // 3
std::cout << "虚部: " << z1.imag() << std::endl; // 4
```

**2、四则运算：**

## 实例

```cpp
auto z3 = z1 + z2;  // (4, 2)
auto z4 = z1 - z2;  // (2, 6)
auto z5 = z1 * z2;  // (11, -2)
auto z6 = z1 / z2;  // (-1, 2)

std::cout << "z1 + z2 = " << z3 << std::endl;
std::cout << "z1 * z2 = " << z5 << std::endl;
```

**3、常用函数**

头文件 `<complex>` 提供了很多和复数相关的数学函数。

## 实例

```cpp
#include <cmath>  // 部分数学函数需要

std::cout << "模长 |z1| = " << std::abs(z1) << std::endl;   // 5
std::cout << "幅角 arg(z1) = " << std::arg(z1) << std::endl; // 0.927 (弧度)
std::cout << "共轭 conjugate(z1) = " << std::conj(z1) << std::endl; // (3,-4)
std::cout << "exp(z1) = " << std::exp(z1) << std::endl;    // e^(3+4i)
std::cout << "sin(z1) = " << std::sin(z1) << std::endl;
std::cout << "cos(z1) = " << std::cos(z1) << std::endl;
```

**4、极坐标表示**

有时我们需要用 极坐标（模长 + 相角） 表示复数。

## 实例

```cpp
// 从极坐标生成复数
double r = 5.0;      // 模长
double theta = M_PI / 4; // 45 度
std::complex<double> z = std::polar(r, theta);

std::cout << "极坐标复数 z = " << z << std::endl; // (3.53553,3.53553)
```

#### 5、模板参数

`std::complex<T>` 是一个模板类，支持不同的数值类型：

- `std::complex<float>`
- `std::complex<double>`（常用）
- `std::complex<long double>`

## 实例

```cpp
std::complex<float> zf(1.0f, 2.0f);
std::complex<double> zd(1.0, 2.0);
```

## 实例

下面是一个使用 `<complex>` 头文件的简单示例，包括创建复数、基本运算和输出结果。

## 实例

```cpp
#include <iostream>
#include <complex>

int main() {
  // 创建两个复数
  std::complex<double> c1(5.0, 3.0);  // 5 + 3i
  std::complex<double> c2(2.0, -4.0); // 2 - 4i

  // 输出复数
  std::cout << "c1: " << c1 << std::endl; // (5,3)
  std::cout << "c2: " << c2 << std::endl; // (2,-4)

  // 复数加法
  std::complex<double> sum = c1 + c2;
  std::cout << "Sum: " << sum << std::endl; // 7 - i

  // 复数减法
  std::complex<double> diff = c1 - c2;
  std::cout << "Difference: " << diff << std::endl; // 3 + 7i

  // 复数乘法
  std::complex<double> product = c1 * c2;
  std::cout << "Product: " << product << std::endl; // 22 - 14i

  // 复数除法
  std::complex<double> quotient = c1 / c2;
  std::cout << "Quotient: " << quotient << std::endl; // -0.1 + 1.3i

  // 复数的共轭
  std::complex<double> conjugate = std::conj(c1);
  std::cout << "Conjugate of c1: " << conjugate << std::endl; // 5 - 3i

  // 复数的模
  double modulus = std::abs(c1);
  std::cout << "Modulus of c1: " << modulus << std::endl; // sqrt(34) ≈ 5.83095

  // 复数的辐角（弧度制）
  double argument = std::arg(c1);
  std::cout << "Argument of c1: " << argument << std::endl; // atan(3/5) ≈ 0.54042 rad

  return 0;
}
```

当你运行上述程序时，你将得到以下输出：

```
c1: (5,3)
c2: (2,-4)
Sum: (7,-1)
Difference: (3,7)
Product: (22,-14)
Quotient: (-0.1,1.3)
Conjugate of c1: (5,-3)
Modulus of c1: 5.83095
Argument of c1: 0.54042
```