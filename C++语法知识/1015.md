# C++ 学习笔记

## 目录

1. [动态多态的实现：虚函数表与虚函数指针](#动态多态的实现虚函数表与虚函数指针)  
2. [`<fstream>` 头文件：常用方法、对象及使用方法](#fstream-头文件常用方法对象及使用方法)  
3. [`<sstream>` 头文件：常用方法、对象及使用方法](#sstream-头文件常用方法对象及使用方法)  
4. [`<iomanip>` 库：作用及常用方法](#iomanip-库作用及常用方法)  
5. [常见 STL 容器中的部分不常用方法总结](#常见-stl-容器中的部分不常用方法总结)  

---

## 1.动态多态的实现：虚函数表与虚函数指针

“多态（Polymorphism）” 的意思是 **同一接口，不同表现形式**。  
在 C++ 中，多态分为两种：

1. **静态多态（编译期多态）**：通过函数重载、模板实现。  
   ➜ 在编译阶段就能确定调用哪个函数。  
2. **动态多态（运行期多态）**：通过**虚函数**实现。  
   ➜ 在运行阶段才能确定调用哪个函数。

### 实现动态多态的三个条件

要实现动态多态，必须满足三个条件：

1. 存在**继承关系**（父类与子类）  
2. 父类中有**虚函数（virtual function）**  
3. 通过**父类指针或引用**调用该虚函数  

### 举例说明

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void speak() {  // 虚函数
        cout << "Animal speaking" << endl;
    }
};

class Dog : public Animal {
public:
    void speak() override { // 重写父类虚函数
        cout << "Dog barking" << endl;
    }
};

int main() {
    Animal* p = new Dog();
    p->speak(); // 调用的是 Dog 的 speak()
    delete p;
    return 0;
}
```

**输出：**  
```
Dog barking
```

**问题：**  
`p` 是 `Animal*` 类型，为什么却能调用 `Dog::speak()` 呢？  
这就是动态多态的核心。

### 底层原理：虚函数表（vtable）与虚函数指针（vptr）

当类中含有**虚函数**时，编译器会在背后为它做两件事：

#### 1. 每个对象多出一个隐藏的指针 —— **虚函数指针（vptr）**

- `vptr` 是一个指针，指向该类对应的**虚函数表（vtable）**。  
- 每个拥有虚函数的类的对象中，编译器会自动加上这个指针。  

你看不到它，但它存在于对象的内存布局中。

#### 2. 编译器为每个类创建一个 **虚函数表（vtable）**

- 这是一个数组（或指针表），存储了该类**所有虚函数的地址**。  
- 当子类重写父类的虚函数时，子类的表中该函数的指针会**覆盖**父类的那一项。  

### 执行过程详解

以 `Animal` 和 `Dog` 为例：

| 类     | 虚函数表（vtable）内容       |
| ------ | ---------------------------- |
| Animal | [ `Animal::speak()` 的地址 ] |
| Dog    | [ `Dog::speak()` 的地址 ]    |

当你写：  
```cpp
Animal* p = new Dog();
```

实际发生了以下事情：

1. `new Dog()` 会在堆上创建一个 `Dog` 对象。  
2. 编译器在 `Dog` 对象内部，自动设置它的 `vptr` → 指向 `Dog` 类的虚函数表。  
3. 当你执行 `p->speak()` 时：  
   - 程序先根据 `p` 找到对象的 `vptr`。  
   - 然后沿着 `vptr` 去查虚函数表。  
   - 发现 `speak()` 对应的是 `Dog::speak()` 的地址。  
   - 最终跳转到 `Dog::speak()` 执行。  

### 补充细节

1. **vptr 的设置时机**  
   - 在对象构造时由编译器自动完成。  
   - 析构时也会自动恢复（尤其是多继承时）。  
2. **虚函数表是静态存储的**  
   - 它在程序启动时就生成，不会随对象的创建销毁而改变。  
   - 所有同类对象共用一张虚表。  
3. **虚函数指针是每个对象独有的**  
   - 因为它指向具体的虚表，不同类的对象需要不同指针。  

### 总结对比：静态 vs 动态绑定

| 类型     | 绑定时机 | 是否通过虚函数表 | 示例                 |
| -------- | -------- | ---------------- | -------------------- |
| 静态绑定 | 编译期   | 否               | 普通成员函数调用     |
| 动态绑定 | 运行期   | 是               | 通过虚函数实现的调用 |

---

## 2.`<fstream>` 头文件：常用方法、对象及使用方法

### `<fstream>` 是什么？

头文件 `<fstream>` 是 C++ 标准库中用于**文件输入输出（File Stream）**的模块。  
它包含了三个核心类（都是从 `iostream` 系列派生而来）：

| 类名       | 功能                                   | 对应头文件中的定义 |
| ---------- | -------------------------------------- | ------------------ |
| `ifstream` | 从文件中读取数据（input file stream）  | `<fstream>`        |
| `ofstream` | 向文件中写入数据（output file stream） | `<fstream>`        |
| `fstream`  | 既可读又可写（file stream）            | `<fstream>`        |

### 文件流的打开与关闭

#### 打开文件的常用方式

可以通过**构造函数直接打开**文件，或通过 `.open()` 方法打开。

```cpp
#include <fstream>
using namespace std;

int main() {
    ofstream fout("example.txt");     // 写模式打开
    ifstream fin("example.txt");      // 读模式打开
    fstream file("example.txt");      // 读写模式打开
}
```

也可以这样：  
```cpp
ofstream fout;
fout.open("example.txt");
```

### 文件打开模式（Open Modes）

打开文件时可以指定模式（多个模式可用 `|` 组合）：

| 模式          | 含义                                 |
| ------------- | ------------------------------------ |
| `ios::in`     | 以读模式打开文件                     |
| `ios::out`    | 以写模式打开文件（会覆盖原文件内容） |
| `ios::app`    | 追加模式，每次写入都从文件末尾开始   |
| `ios::ate`    | 打开后文件指针自动移到文件末尾       |
| `ios::trunc`  | 若文件已存在则清空原内容（默认）     |
| `ios::binary` | 以二进制方式打开文件（非文本）       |

例如：  
```cpp
fstream file("data.bin", ios::in | ios::out | ios::binary);
```

### 常用方法汇总

#### 1. 文件打开与关闭

| 方法                    | 功能                 |
| ----------------------- | -------------------- |
| `.open("文件名", 模式)` | 打开文件             |
| `.is_open()`            | 判断文件是否成功打开 |
| `.close()`              | 关闭文件             |

```cpp
ifstream fin;
fin.open("input.txt");
if (!fin.is_open()) {
    cout << "无法打开文件" << endl;
}
fin.close();
```

#### 2. 文件读写

##### 写入（`ofstream` 或 `fstream`）

```cpp
ofstream fout("data.txt");
fout << "Hello, world!" << endl;
fout << 123 << " " << 45.6 << endl;
fout.close();
```

##### 读取（`ifstream` 或 `fstream`）

```cpp
ifstream fin("data.txt");
string text;
int a;
double b;

fin >> text;   // 读取字符串
fin >> a >> b; // 读取数字
fin.close();
```

##### 按行读取

```cpp
string line;
while (getline(fin, line)) {
    cout << line << endl;
}
```

#### 3. 二进制读写

如果文件是**非文本文件**（比如 `.bin`, `.dat`, 图片、音频等），则必须以二进制模式打开：

```cpp
fstream file("data.bin", ios::out | ios::binary);

// 写入二进制数据
int num = 12345;
file.write(reinterpret_cast<char*>(&num), sizeof(num));
file.close();
```

读取时：  
```CPP
fstream file("data.bin", ios::in | ios::binary);
int num;
file.read(reinterpret_cast<char*>(&num), sizeof(num));
cout << num << endl;
file.close();
```

🔸 `write()` 和 `read()` 是专用于二进制文件的低层函数，它们直接操作内存数据。  
🔸 `reinterpret_cast<char*>` 是一种类型转换，把任意类型的地址转换为字符指针以便写入。

### 文件指针操作（高级）

在 `fstream` 中，文件读写都有一个“文件位置指针”：

- `seekg(pos)` / `seekp(pos)`：移动到指定位置（g = get, p = put）  
- `tellg()` / `tellp()`：获取当前指针位置  

```cpp
fstream file("data.txt", ios::in | ios::out);
file.seekg(0, ios::end);   // 移动到末尾
int size = file.tellg();   // 获取文件大小
file.seekg(0, ios::beg);   // 移动回开头
```

### `<fstream>` 能操作哪些类型的文件？

✔ 任何类型的文件都可以操作，包括：  

- `.txt` 文本文件  
- `.csv` 数据文件  
- `.bin` 二进制文件  
- `.dat` 结构化存储文件  
- 自定义格式文件（例如保存对象序列化）  

关键是：  

- **文本文件** → 使用 `<<`、`>>`、`getline()`。  
- **二进制文件** → 使用 `.write()` 和 `.read()`。  

### 小结

| 类型       | 类名       | 打开模式                | 主要方法                          |
| ---------- | ---------- | ----------------------- | --------------------------------- |
| 写文本文件 | `ofstream` | `ios::out` / `ios::app` | `<<`, `.open()`, `.close()`       |
| 读文本文件 | `ifstream` | `ios::in`               | `>>`, `getline()`                 |
| 读写文件   | `fstream`  | `ios::in | ios::out`    | `<<`, `>>`, `.write()`, `.read()` |
| 二进制文件 | `fstream`  | `ios::binary`           | `.write()`, `.read()`             |

---

## 3.`<sstream>` 头文件：常用方法、对象及使用方法

### `<sstream>` 的作用

头文件 `<sstream>` 主要用于**在内存中进行基于字符串的输入输出操作**。  
换句话说，它提供了一个“字符串版的文件流”：

| 类名            | 功能                         | 类似于     |
| --------------- | ---------------------------- | ---------- |
| `istringstream` | 从字符串中读取数据（输入流） | `ifstream` |
| `ostringstream` | 向字符串中写入数据（输出流） | `ofstream` |
| `stringstream`  | 既可读又可写的字符串流       | `fstream`  |

### 常用对象及用途总结

| 类名            | 功能                   | 使用场景                   |
| --------------- | ---------------------- | -------------------------- |
| `istringstream` | 从字符串中提取数据     | 把字符串拆分为单词、数字等 |
| `ostringstream` | 把数据格式化写入字符串 | 构造复杂的字符串           |
| `stringstream`  | 既能写又能读           | 字符串的临时读写缓冲区     |

### 常用方法

| 方法                    | 作用                           |
| ----------------------- | ------------------------------ |
| `.str()`                | 获取或设置当前流中的字符串内容 |
| `.clear()`              | 清空错误状态，使流可再次使用   |
| `.seekg()` / `.seekp()` | 移动读/写位置（不常用）        |
| `<<`                    | 向流中写入（如 `cout`）        |
| `>>`                    | 从流中提取（如 `cin`）         |

### `istringstream`（字符串输入流）

#### 功能

从一个字符串中**按空格或指定格式提取内容**。

#### 示例

```cpp
#include <iostream>
#include <sstream>
#include <string>
using namespace std;

int main() {
    string text = "123 45.6 hello";
    istringstream iss(text); // 把字符串当作输入流

    int a;
    double b;
    string c;

    iss >> a >> b >> c; // 从字符串流中读取
    cout << a << " " << b << " " << c << endl;

    return 0;
}
```

**输出：**  
```
123 45.6 hello
```

#### 应用场景

- 字符串分词（拆单词）  
- 从字符串中提取数字  
- 解析输入命令（如命令行参数）  

### `ostringstream`（字符串输出流）

#### 功能

把各种类型格式化写入一个字符串中，非常适合拼接字符串。

#### 示例

```cpp
#include <iostream>
#include <sstream>
#include <string>
using namespace std;

int main() {
    ostringstream oss;

    string name = "Alice";
    int age = 20;
    double score = 95.5;

    oss << "Name: " << name << ", Age: " << age << ", Score: " << score;

    string result = oss.str(); // 获取字符串
    cout << result << endl;

    return 0;
}
```

**输出：**  
```
Name: Alice, Age: 20, Score: 95.5
```

#### 应用场景

- 动态拼接字符串（比 `+` 更高效）  
- 生成格式化输出（类似 `printf`）  
- 记录日志内容  

### `stringstream`（可读可写的字符串流）

`stringstream` 结合了前两者的功能：既能写入也能读取。

#### 示例

```cpp
#include <iostream>
#include <sstream>
using namespace std;

int main() {
    stringstream ss;

    // 写入
    ss << 2025 << " " << 10 << " " << 15;

    // 读取
    int year, month, day;
    ss >> year >> month >> day;

    cout << year << "-" << month << "-" << day << endl;
}
```

**输出：**  
```
2025-10-15
```

#### 应用场景

- 临时构造数据然后再读取  
- 文件或输入字符串的中间解析过程  

### 常用技巧与方法演示

#### 1. `.str()` 获取与设置内容

```cpp
stringstream ss;
ss << "Hello 123";
cout << ss.str() << endl;  // 获取字符串内容

ss.str("World 456");       // 重新设置流内容
string word;
int num;
ss >> word >> num;
cout << word << " " << num << endl;
```

#### 2. `.clear()` 清除错误状态

如果提取完内容后想重用同一个流，必须 `clear()`：

```cpp
stringstream ss("123 456");
int a, b;
ss >> a >> b;
cout << a << " " << b << endl;

ss.clear();      // 清除EOF等状态
ss.str("789");   // 设置新字符串
ss >> a;
cout << a << endl;
```

#### 3. 字符串分割的常见用法

用 `istringstream` 按空格分割字符串：

```cpp
string s = "C++ is powerful";
istringstream iss(s);
string word;

while (iss >> word) {
    cout << word << endl;
}
```

**输出：**  
```
C++
is
powerful
```

#### 4. 解析逗号分隔值（CSV）

```cpp
string s = "apple,banana,pear";
istringstream iss(s);
string item;

while (getline(iss, item, ',')) { // 用逗号作为分隔符
    cout << item << endl;
}
```

---

## 4.`<iomanip>` 库：作用及常用方法

### `<iomanip>` 的总体作用

在不使用 `<iomanip>` 时，`cout` 默认的输出格式往往比较简单：

```cpp
#include <iostream>
using namespace std;

int main() {
    double pi = 3.1415926535;
    cout << pi << endl;
}
```

**输出：**  

```
3.14159
```

但是如果你想要：  

- 限定小数位数；  
- 对齐输出；  
- 显示进制；  
- 控制正负号或前缀显示；  
- 科学计数法显示；  

就需要用到 `<iomanip>`。

### `<iomanip>` 的常用操纵符与功能分类

我们可以把 `<iomanip>` 的功能分成 **四大类** 来记：

#### 1. 控制输出宽度与对齐方式

##### `setw(n)`：设置输出宽度（仅对下一次输出生效）（set width）

```cpp
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    cout << "[" << setw(6) << 42 << "]" << endl;
}
```

**输出：**  
```
[    42]
```

注意：`setw` **只对下一次输出有效**，不会持续生效。`setw(6)` 只影响紧随其后的那次输出（即“42”）  

##### `setfill(c)`：设置填充字符（默认是空格）

```cpp
cout << setfill('*') << setw(6) << 42 << endl;
```

**输出：**  

```
****42
```

##### `left` / `right` / `internal`：控制对齐方式

| 操纵符     | 含义               | 示例       |
| ---------- | ------------------ | ---------- |
| `left`     | 左对齐             | `[42    ]` |
| `right`    | 右对齐（默认）     | `[    42]` |
| `internal` | 符号靠左，数字靠右 | `[-  42]`  |

```cpp
cout << "[" << left << setw(6) << 42 << "]" << endl;
cout << "[" << right << setw(6) << 42 << "]" << endl;
cout << "[" << internal << setw(6) << -42 << "]" << endl;
```

### 那如果输出不是数字呢？

`std::internal` 只有在“输出对象包含符号”时才有特殊意义。  
例如：  

- 对 `"42"`、`"hello"` 等普通字符串无效；  
- 对 `-42`、`+42`、`std::showpos` 开启时的 `42` 有效果；  
- 对 `"-d22j+"`、`"42-"` 这类字符串：**不会自动识别符号部分**，它只是普通字符串，不受 `internal` 控制。  

也就是说：  

> `internal` 是针对**数字类类型（int, float, double 等）**设计的，不会“分析字符串中的符号”。

#### 2. 控制浮点数格式

##### `setprecision(n)`：控制有效位数或小数位数

默认是控制“**总有效位数**”：

```cpp
cout << setprecision(4) << 3.1415926 << endl;
```

**输出：**  
```
3.142
```

若配合 `fixed` 一起使用，则控制**小数点后的位数**：

```cpp
cout << fixed << setprecision(4) << 3.1415926 << endl;
```

**输出：**  
```
3.1416
```

##### `scientific`：以科学计数法显示

```cpp
cout << scientific << 3.1415926 << endl;
```

**输出：**  
```
3.141593e+00
```

##### `showpos`：显示正号

```cpp
cout << showpos << 42 << " " << -42 << endl;
```

**输出：**  
```
+42 -42
```

##### `uppercase`：科学计数法或十六进制中字母大写

```cpp
cout << uppercase << scientific << 3.14 << endl;
```

**输出：**  
```
3.140000E+00
```

#### 3. 控制整数的进制与前缀显示

##### `hex` / `oct` / `dec`：控制输出进制

```cpp
cout << dec << 42 << " "
     << hex << 42 << " "
     << oct << 42 << endl;
```

**输出：**  

```
42 2a 52
```

##### `showbase`：显示进制前缀

```cpp
cout << showbase << hex << 42 << endl;
```

**输出：**  
```
0x2a
```

八进制会显示 `0` 前缀：  
```cpp
cout << showbase << oct << 42 << endl;
```

**输出：**  
```
052
```

##### `setbase(n)`：直接设置进制（8、10、16）

```cpp
cout << setbase(16) << 42 << endl;
```

**输出：**  
```
2a
```

#### 4. 其他格式控制

##### `boolalpha`：布尔值以 true/false 输出

```cpp
cout << boolalpha << true << " " << false << endl;
```

**输出：**  
```
true false
```

默认情况下：  
```cpp
cout << noboolalpha << true << " " << false << endl;
```

**输出：**  
```
1 0
```

##### `resetiosflags(flag)` / `setiosflags(flag)`：设置或重置状态

```cpp
cout << setiosflags(ios::showbase | ios::uppercase)
     << hex << 42 << endl;

cout << resetiosflags(ios::showbase)
     << hex << 42 << endl;
```

**输出：**  
```
0X2A
2A
```

### 综合示例：格式化表格输出

```cpp
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    cout << left << setw(10) << "Name"
         << right << setw(10) << "Score" << endl;
    cout << setfill('-') << setw(20) << "-" << setfill(' ') << endl;

    cout << left << setw(10) << "Alice"
         << right << setw(10) << 95.5 << endl;

    cout << left << setw(10) << "Bob"
         << right << setw(10) << 88.75 << endl;

    cout << left << setw(10) << "Charlie"
         << right << setw(10) << 100.0 << endl;
}
```

**输出：**  
```
Name          Score
--------------------
Alice          95.5
Bob            88.75
Charlie       100
```

### 常用操纵符汇总表

| 操纵符                          | 作用                    | 示例输出                         |
| ------------------------------- | ----------------------- | -------------------------------- |
| `setw(n)`（set width）          | 设置输出宽度            | `"   42"`                        |
| `setfill(c)`                    | 设置填充字符            | `"***42"`                        |
| `left` / `right` / `internal`   | 控制对齐方式            | `"42   "` / `"   42"` / `"- 42"` |
| `setprecision(n)`               | 设置有效位数或小数位数  | `"3.142"`                        |
| `fixed` / `scientific`          | 定点 / 科学计数法       | `"3.1416"` / `"3.141593e+00"`    |
| `showpos`                       | 显示正号                | `+42`                            |
| `showbase`                      | 显示进制前缀            | `0x2a`                           |
| `uppercase`                     | 输出大写字母            | `0X2A`                           |
| `boolalpha`                     | 布尔值输出为 true/false | `true`                           |
| `setbase(n)`                    | 设置进制                | `setbase(16)` → `2a`             |
| `setiosflags` / `resetiosflags` | 设置/重置流标志         | 控制输出行为                     |

### 小结

| 功能类别   | 常用操纵符                                                   |
| ---------- | ------------------------------------------------------------ |
| 宽度与对齐 | `setw`, `setfill`, `left`, `right`, `internal`               |
| 浮点数控制 | `setprecision`, `fixed`, `scientific`, `showpos`, `uppercase` |
| 整数格式   | `hex`, `oct`, `dec`, `showbase`, `setbase`                   |
| 其他       | `boolalpha`, `setiosflags`, `resetiosflags`                  |

---

## 5.常见 STL 容器中的部分不常用方法总结

### array

| 方法                   | 描述                           |
| ---------------------- | ------------------------------ |
| `at(size_t pos)`       | 返回指定位置的元素，带边界检查 |
| `data()`               | 返回指向数组数据的指针         |
| `fill(const T& value)` | 将数组所有元素设置为指定值     |
| `swap(array& other)`   | 交换两个数组的内容             |

### vector

| 方法                        | 描述                           |
| --------------------------- | ------------------------------ |
| `at(size_t pos)`            | 返回指定位置的元素，带边界检查 |
| `data()`                    | 返回指向底层数组的指针         |
| `capacity()`                | 返回当前分配的容量             |
| `reserve(size_t n)`         | 预留至少 `n` 个元素的存储空间  |
| `resize(size_t n)`          | 将元素数量调整为 `n`           |
| `insert(iterator pos, val)` | 在指定位置插入元素             |
| `erase(iterator pos)`       | 删除指定位置的元素             |

### list

| 方法                        | 描述                     |
| --------------------------- | ------------------------ |
| `insert(iterator pos, val)` | 在指定位置插入元素       |
| `erase(iterator pos)`       | 删除指定位置的元素       |
| `remove(const T& val)`      | 删除所有等于指定值的元素 |
| `sort()`                    | 对链表中的元素进行排序   |
| `merge(list& other)`        | 合并另一个已排序的链表   |

### deque

| 方法                                   | 描述                                           |
| -------------------------------------- | ---------------------------------------------- |
| `operator=`                            | 赋值操作符，赋值给 `deque` 容器。              |
| `assign()`                             | 用新值替换 `deque` 容器中的所有元素。          |
| `deque(initializer_list<T> il)`        | 使用初始化列表 `il` 构造 `deque` 容器。        |
| `insert(iterator pos, const T& value)` | 在 `pos` 位置插入 `value` 元素。               |
| `erase(iterator pos)`                  | 移除 `pos` 位置的元素。                        |
| `get_allocator()`                      | 返回一个用于构造双端队列的分配器对象的副本。   |
| `resize(size_type count)`              | 调整容器大小为 `count`，多出部分用默认值填充。 |

### bitset

定义 `std::bitset`：  
```cpp
std::bitset<8> bits;  // 定义一个 8 位的二进制序列
```

#### 初始化

- 默认初始化：所有位为 `0`。  
- 从整数初始化：将整数转换为二进制。  
- 从字符串初始化：将字符串解析为二进制。  

```cpp
std::bitset<8> bits1;        // 默认初始化：00000000
std::bitset<8> bits2(42);    // 从整数初始化：00101010
std::bitset<8> bits3("10101010");  // 从字符串初始化：10101010
```

#### 常用成员函数

**访问和修改位：**

| 方法         | 描述                       |
| ------------ | -------------------------- |
| `operator[]` | 访问或修改某一位           |
| `set()`      | 将某一位或所有位设置为 `1` |
| `reset()`    | 将某一位或所有位设置为 `0` |
| `flip()`     | 翻转某一位或所有位         |

**查询位信息：**

| 方法        | 描述                     |
| ----------- | ------------------------ |
| `count()`   | 返回 `1` 的个数          |
| `size()`    | 返回位数                 |
| `test(pos)` | 检查某一位是否为 `1`     |
| `all()`     | 检查是否所有位都为 `1`   |
| `any()`     | 检查是否有任何一位为 `1` |
| `none()`    | 检查是否所有位都为 `0`   |

**转换为其他类型：**

| 方法          | 描述                                         |
| ------------- | -------------------------------------------- |
| `to_ulong()`  | 将 `std::bitset` 转换为 `unsigned long`      |
| `to_ullong()` | 将 `std::bitset` 转换为 `unsigned long long` |
| `to_string()` | 将 `std::bitset` 转换为字符串                |

```cpp
std::bitset<8> bits("10101010");
unsigned long num = bits.to_ulong(); // 转换为整数：170
std::string str = bits.to_string();  // 转换为字符串："10101010"
```

#### 位操作

`std::bitset` 支持常见的位操作，如按位与、按位或、按位异或和按位取反。

| 操作符 | 描述     |
| ------ | -------- |
| `&`    | 按位与   |
| `|`    | 按位或   |
| `^`    | 按位异或 |
| `~`    | 按位取反 |

```cpp
std::bitset<8> bits1("10101010");
std::bitset<8> bits2("11110000");

std::bitset<8> result_and = bits1 & bits2; // 按位与：10100000
std::bitset<8> result_or = bits1 | bits2;  // 按位或：11111010
std::bitset<8> result_xor = bits1 ^ bits2; // 按位异或：01011010
std::bitset<8> result_not = ~bits1;     // 按位取反：01010101
```