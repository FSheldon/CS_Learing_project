# MySQL 常用指令速查

## 1️⃣ 登录与退出
- `mysql -u 用户名 -p`        # 登录 MySQL（输入密码）
- `mysql -h 主机名 -u 用户名 -p`  # 远程登录
- `exit;`                     # 或者 `\q` 退出

## 2️⃣ 数据库操作（DDL）
- `SHOW DATABASES;`                          -- 查看所有数据库
- `CREATE DATABASE testdb;`                  -- 创建数据库
- `CREATE DATABASE testdb`  
  `DEFAULT CHARACTER SET utf8mb4`  
  `COLLATE utf8mb4_general_ci;`            -- 指定字符集与排序规则
- `USE testdb;`                              -- 选择数据库
- `DROP DATABASE testdb;`                    -- 删除数据库  
  （使用 `IF NOT EXISTS` 和 `IF EXISTS` 保险）

## 3️⃣ 表结构操作（DDL）

### ✅ 创建表
```sql
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    birthdate DATE,
    is_active BOOLEAN DEFAULT TRUE
);
```
**实例解析**：  
- `id`：字段名。 
- `INT`：数据类型
- `AUTO_INCREMENT` ：自增长。  
- `PRIMARY KEY` ：主键
- `NOT NULL`：不可设为空
- `DEFAULT`：默认值

如果你希望在创建表时指定数据引擎、字符集和排序规则等，可以使用 `CHARACTER SET` 和 `COLLATE` 子句：  
```sql
CREATE TABLE mytable (
    id INT PRIMARY KEY,
    name VARCHAR(50)
) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
```

`CHARACTER SET`：字符集

`COLLATE`：排序规则

以下例子中我们将在 RUNOOB 数据库中创建数据表 `runoob_tbl`：  

```sql
CREATE TABLE IF NOT EXISTS `runoob_tbl`(
   `runoob_id` INT UNSIGNED AUTO_INCREMENT,
   `runoob_title` VARCHAR(100) NOT NULL,
   `runoob_author` VARCHAR(40) NOT NULL,
   `submission_date` DATE,
   PRIMARY KEY ( `runoob_id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
```
`ENGINE`：存储引擎

一些tips：

·可以选择给字段加上反引号用于设置字段名，更安全。

·INT UNSIGNED设置无符号整形

 ·设置主键的方法两种：

写法1（单独定义）：

```
PRIMARY KEY (`runoob_id`)
```

### 写法2（内联定义）：

```
id INT AUTO_INCREMENT PRIMARY KEY
```

✅ 这两种写法完全等价，区别只是书写风格：

- **写法1**：先定义所有列，再单独声明哪一列是主键（适合多列联合主键）。
- **写法2**：直接在列定义中声明（适合单列主键）。

例如联合主键时只能用写法1：

```
PRIMARY KEY (student_id, course_id)
```

## `ENGINE=InnoDB DEFAULT CHARSET=utf8;` 是什么意思？

### ✅ 1. `ENGINE=InnoDB`

指定**存储引擎**。
 MySQL 支持多种存储引擎，最常见的是：

| 存储引擎   | 特点                                       |
| ---------- | ------------------------------------------ |
| **InnoDB** | 支持事务（ACID）、行级锁、外键约束（默认） |
| **MyISAM** | 速度快但不支持事务与外键                   |
| **Memory** | 数据存内存，重启丢失，超快                 |

💡 所以 `ENGINE=InnoDB` 表示：

> 该表使用 InnoDB 引擎，能支持事务与外键。

------

### ✅ 2. `DEFAULT CHARSET=utf8`

`CHARSET`（或 `CHARACTER SET`）表示**字符集**，即存储文本数据时用的**编码方案**。

常见字符集：

| 字符集    | 含义                                                         |
| --------- | ------------------------------------------------------------ |
| `latin1`  | 英文、西欧语系（默认早期 MySQL 默认）                        |
| `utf8`    | MySQL 早期版本的 UTF-8，但**最多支持3字节**（不完全支持 Emoji） |
| `utf8mb4` | 真正完整的 UTF-8，支持 Emoji 和所有 Unicode 字符             |

💡 所以 `DEFAULT CHARSET=utf8` 意思是：

> “默认使用 UTF-8 编码（3字节版）来存储文本”。

✅ 现代推荐写法：

```
DEFAULT CHARSET=utf8mb4
```

## `COLLATE utf8mb4_general_ci` 是什么？

### ✅ 1. 含义

`COLLATE` 用来指定**排序规则（collation）**，决定：

- 字符如何比较（A vs a 是否相等？）
- 排序时的顺序（“Z” 在 “a” 前还是后？）

### ✅ 2. 常见规则解释

| 排序规则             | 说明                                                        |
| -------------------- | ----------------------------------------------------------- |
| `utf8mb4_general_ci` | **不区分大小写**（ci = case-insensitive），效率高，排序简单 |
| `utf8mb4_unicode_ci` | 不区分大小写，遵循 Unicode 规范，排序更准确（慢一点）       |
| `utf8mb4_bin`        | 区分大小写与重音（按二进制排序）                            |

举例：

```
SELECT 'A'='a' COLLATE utf8mb4_general_ci;  -- 结果为 TRUE
SELECT 'A'='a' COLLATE utf8mb4_bin;         -- 结果为 FALSE
```

## 联合主键（Composite Primary Key）是什么？

> **联合主键**是指：使用**多个列组合起来**作为主键，
> 只有当这些列的**组合值**同时相同时，才算重复。

### ✅ 语法：

```
CREATE TABLE enrollments (
    student_id INT,
    course_id INT,
    enrollment_date DATE,
    PRIMARY KEY (student_id, course_id)
);
```

这里的 `(student_id, course_id)` 就是一个 **联合主键**。
 它表示：

- 同一个学生可以选多门课；
- 同一门课也有多个学生；
- 但 **同一个学生不能重复选同一门课**。

换句话说：

> `student_id` 不唯一
> `course_id` 也不唯一
> 但 `(student_id, course_id)` 的组合是唯一的。

#### ✅ 查看/修改表结构

- `SHOW TABLES;`                -- 查看当前数据库的所有表

- `DESC students;`              -- 查看表的字段（DESC = describe)

- `SHOW CREATE TABLE students;` -- 查看建表 SQL 语句

- `ALTER TABLE students ADD COLUMN address VARCHAR(100);`  -- 增加列

- `ALTER TABLE students MODIFY COLUMN age TINYINT;`        -- 修改列的数据类型

- `ALTER TABLE students DROP COLUMN score;`                -- 删除列

- `ALTER TABLE students RENAME TO users;`                  -- 重命名表

- `ALTER TABLE users RENAME COLUMN username TO user_name;` -- 重命名列

- `ALTER TABLE table_name ADD PRIMARY KEY (column_name);` -- 添加 PRIMARY KEY

- ```
  ALTER TABLE child_table ADD CONSTRAINT fk_name FOREIGN KEY (column_name) REFERENCES parent_table (column_name);
  ```

-- 添加外键



删除表：`DROP TABLE students;`

## 4️⃣ 数据操作（DML）

### 插入数据
```sql
INSERT INTO table_name (column1, column2, column3, ...)
VALUES (value1, value2, value3, ...);
```
**参数说明**：  

- `table_name` 是你要插入数据的表的名称。  
- `column1, column2, column3, ...` 是表中的列名。  
- `value1, value2, value3, ...` 是要插入的具体数值。  
- 如果数据是字符型，必须使用单引号 `'` 或者双引号 `"`，如：`'value1', "value1"`。  

示例：  
```sql
INSERT INTO students (name, age, gender, score)
VALUES ('Alice', 20, '女', 95.5);
```

如果你要插入所有列的数据，可以省略列名：  
```sql
INSERT INTO users
VALUES (NULL,'test', 'test@runoob.com', '1990-01-01', true);
```
这里，`NULL` 是用于自增长列的占位符，表示系统将为 `id` 列生成一个唯一的值。

**批量插入**：  

```sql
INSERT INTO students (name, age, gender, score)
VALUES
  ('Bob', 22, '男', 88.0),
  ('Cathy', 19, '女', 92.3);
```

### 更新数据
```sql
UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;
```
**参数说明**：  
- `table_name` 是你要更新数据的表的名称。  
- `column1, column2, ...` 是你要更新的列的名称。  
- `value1, value2, ...` 是新的值，用于替换旧的值。  
- `WHERE condition` 是一个可选的子句，用于指定更新的行。如果省略 `WHERE` 子句，将更新表中的所有行。  

**更多说明**：  

- 你可以同时更新一个或多个字段。  
- 你可以在 `WHERE` 子句中指定任何条件。  
- 你可以在一个单独表中同时更新数据。  
- 当你需要更新数据表中指定行的数据时 `WHERE` 子句是非常有用的。  

**实例**：  
1. 更新单个列的值：  
   ```sql
   UPDATE employees
   SET salary = 60000
   WHERE employee_id = 101;
   ```

2. 更新多个列的值：  
   ```sql
   UPDATE orders
   SET status = 'Shipped', ship_date = '2023-03-01'
   WHERE order_id = 1001;
   ```

3. 使用表达式更新值：  
   ```sql
   UPDATE products
   SET price = price * 1.1
   WHERE category = 'Electronics';
   ```
   以上 SQL 语句将每个属于 'Electronics' 类别的产品的价格都增加了 10%。

   

4. 更新符合条件的所有行：  

   ```sql
   UPDATE students
   SET status = 'Graduated';
   ```
   以上 SQL 语句将所有学生的状态更新为 'Graduated'。

   

5. 更新使用子查询的值：  

   ```sql
   UPDATE customers
   SET total_purchases = (
       SELECT SUM(amount)
       FROM orders
       WHERE orders.customer_id = customers.customer_id
   )
   WHERE customer_type = 'Premium';
   ```
   以上 SQL 语句通过子查询计算每个 'Premium' 类型客户的总购买金额，并将该值更新到 `total_purchases` 列中。

### 删除数据
```sql
DELETE FROM table_name
WHERE condition;
```
**参数说明**：  
- `table_name` 是你要删除数据的表的名称。  
- `WHERE condition` 是一个可选的子句，用于指定删除的行。如果省略 `WHERE` 子句，将删除表中的所有行。  

**更多说明**：  
- 如果没有指定 `WHERE` 子句，MySQL 表中的所有记录将被删除。  
- 你可以在 `WHERE` 子句中指定任何条件。  
- 您可以在单个表中一次性删除记录。  
- 当你想删除数据表中指定的记录时 `WHERE` 子句是非常有用的。  

**实例**：  
1. 删除符合条件的行：  
   ```sql
   DELETE FROM students
   WHERE graduation_year = 2021;
   ```
   以上 SQL 语句删除了 `students` 表中所有 `graduation_year` 为 2021 的学生的记录。

2. 删除所有行：  
   ```sql
   DELETE FROM orders;
   ```
   以上 SQL 语句删除了 `orders` 表中的所有记录，但表结构保持不变。

3. 使用子查询删除符合条件的行：  
   ```sql
   DELETE FROM customers
   WHERE customer_id IN (
       SELECT customer_id
       FROM orders
       WHERE order_date < '2023-01-01'
   );
   ```
   以上 SQL 语句通过子查询删除了 `orders` 表中在 '2023-01-01' 之前下的订单对应的客户。

- `DELETE FROM students WHERE id = 3;`  
- `TRUNCATE TABLE students;`  -- 清空整个表（比 DELETE 更快，清空数据但保留表结构）

## 5️⃣ 查询数据（DQL）
```sql
SELECT column1, column2, ...
FROM table_name
[WHERE condition]
[ORDER BY column_name [ASC | DESC]]
[LIMIT number];
```
**参数说明**：  
- `column1, column2, ...` 是你想要选择的列的名称，如果使用 `*` 表示选择所有列。  
- `table_name` 是你要从中查询数据的表的名称。  
- `WHERE condition` 是一个可选的子句，用于指定过滤条件，只返回符合条件的行。  
- `ORDER BY column_name [ASC | DESC]` 是一个可选的子句，用于指定结果集的排序顺序，默认是升序（ASC）。  
- `LIMIT number` 是一个可选的子句，用于限制返回的行数。  

**MySQL SELECT 语句简单的应用实例**：  

- `-- 选择所有列的所有行`  
  `SELECT * FROM users;`  
- `-- 选择特定列的所有行`  
  `SELECT username, email FROM users;`  
- `-- 添加 WHERE 子句，选择满足条件的行`  
  `SELECT * FROM users WHERE is_active = TRUE;`  
- `-- 添加 ORDER BY 子句，按照某列的升序排序`  
  `SELECT * FROM users ORDER BY birthdate;`  
- `-- 添加 ORDER BY 子句，按照某列的降序排序`  
  `SELECT * FROM users ORDER BY birthdate DESC;`  
- `-- 添加 LIMIT 子句，限制返回的行数`  
  `SELECT * FROM users LIMIT 10;`

### 基本查询
- `SELECT * FROM students;`  
- `SELECT name, score FROM students WHERE gender='女';`

### 条件查询
- `SELECT * FROM students WHERE age > 18 AND score >= 90;`

### 模糊查询（LIKE）
- `SELECT * FROM students WHERE name LIKE 'A%';`  -- A 开头  
- `SELECT * FROM students WHERE name LIKE '%e';`  -- e 结尾  

**✅ % 与 _ 是两个“通配符”**  
不区分大小写的匹配：  
`SELECT * FROM employees WHERE last_name LIKE 'smi%' COLLATE utf8mb4_general_ci;`  

**LIKE 子句提供了强大的模糊搜索能力**，可以根据不同的模式和需求进行定制。在使用时，请确保理解通配符的含义，并根据实际情况进行匹配。  

以下是一些进阶的 SELECT 语句实例：  
- `-- 使用 AND 运算符和通配符`  
  `SELECT * FROM users WHERE username LIKE 'j%' AND is_active = TRUE;`  
- `-- 使用 OR 运算符`  
  `SELECT * FROM users WHERE is_active = TRUE OR birthdate < '1990-01-01';`  
- `-- 使用 IN 子句`  
  `SELECT * FROM users WHERE birthdate IN ('1990-01-01', '1992-03-15', '1993-05-03');`

### 排序
- `SELECT * FROM students ORDER BY score DESC, age ASC;`  

**✅ 含义**：对查询结果按指定字段进行排序。

先按前面排，再按后面排。

### 限制行数
- `SELECT * FROM students LIMIT 5;`          -- 取前 5 条  
- `SELECT * FROM students LIMIT 5 OFFSET 10;`-- 从第 11 条开始取 5 条

### 分组与聚合
```sql
SELECT gender, AVG(score) AS avg_score
FROM students
GROUP BY gender
HAVING avg_score > 90;  -- 分组后的过滤
```
**✅ GROUP BY 含义**：将查询结果按某列分组统计，常与聚合函数一起使用。  

**⚙️ 示例**：  
```sql
SELECT gender, COUNT(*) AS num_students
FROM students
GROUP BY gender;
```

**⚙️ 示例**：  
`SELECT gender,COUNT(*) AS num_studentsFROM students GROUPBY gender;`

**✅ HAVING 含义**：对分组后的结果再进行过滤（类似于 WHERE，但作用于分组之后）。

## 6️⃣ 多表操作（JOIN）

### 🧭 一、多表查询的概念

在数据库中，**一张表往往不能独立满足业务需求**。
 例如：

- `employees` 员工表：员工姓名、部门编号
- `departments` 部门表：部门编号、部门名称

如果我们想查出：

> “每个员工的名字和所在部门名称”

就必须把两张表的数据**关联起来查询**。
 👉 这就是 **多表查询（JOIN）**。

------

### 🧩 二、JOIN 的三种常见类型

| 类型     | 英文名       | 特点                                |
| -------- | ------------ | ----------------------------------- |
| 内连接   | `INNER JOIN` | 只返回两个表中“匹配”的行            |
| 左外连接 | `LEFT JOIN`  | 返回左表所有行，右表无匹配则补 NULL |
| 右外连接 | `RIGHT JOIN` | 返回右表所有行，左表无匹配则补 NULL |

（MySQL 不支持 FULL OUTER JOIN，但可以用 UNION 模拟）

------

### 🧠 三、基础示例数据

我们先创建两张表方便理解：

```
CREATE TABLE departments (
  dept_id INT PRIMARY KEY,
  dept_name VARCHAR(50)
);

CREATE TABLE employees (
  emp_id INT PRIMARY KEY,
  emp_name VARCHAR(50),
  dept_id INT
);
```

插入数据：

```
INSERT INTO departments VALUES
(1, 'HR'),
(2, 'Engineering'),
(3, 'Sales');

INSERT INTO employees VALUES
(101, 'Alice', 1),
(102, 'Bob', 2),
(103, 'Charlie', 2),
(104, 'David', NULL);
```

------

### 🧩 四、INNER JOIN（内连接）

#### ✅ 概念：

> 只返回 **两张表中匹配成功的行**。
> 如果某一方在另一张表中找不到对应值，就不会出现在结果中。

------

#### ✅ 语法：

```
SELECT 列名
FROM 表1
INNER JOIN 表2
ON 表1.字段 = 表2.字段;
```

------

#### ✅ 示例：

```
SELECT e.emp_name, d.dept_name
FROM employees e
INNER JOIN departments d
ON e.dept_id = d.dept_id;
```

🔹 查询结果：

| emp_name | dept_name   |
| -------- | ----------- |
| Alice    | HR          |
| Bob      | Engineering |
| Charlie  | Engineering |

> David 因为没有部门（dept_id = NULL），不出现在结果中。

------

#### ✅ 使用场景：

- 只关心“匹配成功”的数据；
- 比如：
  - 订单表 + 客户表（只要有下单的客户）
  - 学生表 + 选课表（只要有选课的学生）

------

### 🧩 五、LEFT JOIN（左外连接）

#### ✅ 概念：

> 返回 **左表的所有记录**，
> 即使右表没有匹配项，也会显示出来，右表字段填 `NULL`。

------

#### ✅ 语法：

```
SELECT 列名
FROM 表1
LEFT JOIN 表2
ON 表1.字段 = 表2.字段;
```

------

#### ✅ 示例：

```
SELECT e.emp_name, d.dept_name
FROM employees e
LEFT JOIN departments d
ON e.dept_id = d.dept_id;
```

🔹 查询结果：

| emp_name | dept_name   |
| -------- | ----------- |
| Alice    | HR          |
| Bob      | Engineering |
| Charlie  | Engineering |
| David    | NULL        |

> David 虽然没有部门信息，但依然保留。

------

#### ✅ 使用场景：

- 想保留左表的所有数据，即使关联不到；
- 比如：
  - 所有员工（包括没分部门的）
  - 所有客户（包括没下订单的）
  - 所有学生（包括没选课的）

------

### 🧩 六、RIGHT JOIN（右外连接）

#### ✅ 概念：

> 与 LEFT JOIN 相反，
> 返回 **右表的所有记录**，即使左表中没有匹配项。

------

#### ✅ 语法：

```
SELECT 列名
FROM 表1
RIGHT JOIN 表2
ON 表1.字段 = 表2.字段;
```

------

#### ✅ 示例：

```
SELECT e.emp_name, d.dept_name
FROM employees e
RIGHT JOIN departments d
ON e.dept_id = d.dept_id;
```

#### 🔹 查询结果：

| emp_name | dept_name   |
| -------- | ----------- |
| Alice    | HR          |
| Bob      | Engineering |
| Charlie  | Engineering |
| NULL     | Sales       |

> 因为没有员工属于 Sales 部门，但 Sales 依然显示。

------

#### ✅ 使用场景：

- 想保留右表全部数据；
- 比如：
  - 所有部门（包括还没有员工的）
  - 所有课程（包括还没人选的）

------

### 🧩 七、FULL OUTER JOIN（全外连接）

MySQL **不支持直接语法**，但可以模拟：

```
SELECT e.emp_name, d.dept_name
FROM employees e
LEFT JOIN departments d ON e.dept_id = d.dept_id
UNION
SELECT e.emp_name, d.dept_name
FROM employees e
RIGHT JOIN departments d ON e.dept_id = d.dept_id;
```

> 等价于：**左外连接 + 右外连接的并集**
> 可以看到所有员工 + 所有部门，即使没有匹配。

------

### 🧠 八、JOIN 的执行逻辑

你可以理解成：

| JOIN 类型       | 逻辑解释      |
| --------------- | ------------- |
| INNER JOIN      | “交集”        |
| LEFT JOIN       | “左集 + 交集” |
| RIGHT JOIN      | “右集 + 交集” |
| FULL OUTER JOIN | “左集 ∪ 右集” |

## 7️⃣ 子查询

```sql
SELECT name, score
FROM students
WHERE score > (SELECT AVG(score) FROM students);
```
**✅ 含义**：括号中的查询称为“子查询”，会先执行。  
这里：  
`(SELECT AVG(score) FROM students)`  
计算所有学生的平均分，然后主查询返回成绩高于平均分的学生。

## 8️⃣ 视图（VIEW）
```sql
CREATE VIEW high_score AS
SELECT name, score FROM students WHERE score > 90;
SELECT * FROM high_score;
DROP VIEW high_score;
```
**✅ 含义**：视图是一个“虚拟表”，并不存储真实数据，而是保存了一个查询语句。  
之后你可以像操作表一样查询它：  
`SELECT * FROM high_score;`  
等价于：  
`SELECT name, score FROM students WHERE score > 90;`  

**✅ 优点**：  
- 代码更简洁  
- 可用于权限控制（让用户只能访问视图）  
- 简化复杂查询

## 9️⃣ 索引（INDEX）
- `CREATE INDEX idx_name ON students(name);`  
- `SHOW INDEX FROM students;`  
- `DROP INDEX idx_name ON students;`  

- # 🧭 一、什么是索引（Index）

  ### ✅ 定义：

  > **索引是数据库中用来提高查询效率的数据结构。**

  它就像一本书的目录：
   你不用从头到尾翻书，而是通过目录 **快速定位到某一页**。

  ------

  ### 🧠 比喻理解：

  没有索引时：

  > 查“张三”的数据 = 从第一行开始逐条扫描（全表扫描）

  有索引时：

  > 数据库先查索引表，立刻知道“张三”在第 2048 行，直接跳过去。

  ------

  # 🚀 二、索引的意义

  | 作用                     | 说明                                        |
  | ------------------------ | ------------------------------------------- |
  | ✅ **加快查询速度**       | 尤其是 WHERE、JOIN、ORDER BY、GROUP BY 操作 |
  | ✅ **加速排序**           | 有序索引可直接支持 ORDER BY                 |
  | ✅ **加快表连接（JOIN）** | 外键列建立索引可以显著提升 JOIN 性能        |
  | ❌ **会占用空间**         | 索引文件本身要额外存储                      |
  | ❌ **会降低写入效率**     | 插入、删除、更新时要同步更新索引结构        |

  > 📌 所以：**索引让“读”更快，但让“写”更慢。**

  ------

  # 🧩 三、索引的底层原理（B+ 树）

  MySQL（InnoDB 引擎）**几乎所有索引都是用 B+ 树实现的**。

  ### 🪴 B+ 树的特点：

  - 数据按键值顺序排列；
  - 所有数据都存储在叶子节点；
  - 叶子节点之间有链表指针（方便范围查找）；
  - 查询可以用二分法逐层缩小范围。

  👇 举个简单例子（假设索引在 `id` 列）：

  ```
            [20]
           /    \
     [5,10]    [25,30,35]
  ```

  - 查找 id=30 → 一次找到
  - 范围查找 id>10 → 顺着右链表高效扫描

  > 这就是为什么索引对 `WHERE id BETWEEN 10 AND 30` 的查询非常快。

  ------

  # 🧠 四、索引的分类

  | 索引类型                  | 说明                                    | 示例                |
  | ------------------------- | --------------------------------------- | ------------------- |
  | 🌳 主键索引（Primary Key） | 唯一标识一行记录，不可重复，不可为 NULL | `PRIMARY KEY(id)`   |
  | 🌿 唯一索引（Unique Key）  | 不允许重复，但可为 NULL                 | `UNIQUE(email)`     |
  | 🍀 普通索引（Index / Key） | 最基本的索引，可重复                    | `INDEX(name)`       |
  | 🌾 复合索引（Composite）   | 多列联合索引，遵循“最左前缀原则”        | `INDEX(name, age)`  |
  | 🍎 全文索引（Fulltext）    | 用于文本内容的模糊匹配                  | `FULLTEXT(content)` |
  | 🌻 前缀索引                | 只索引字符串前 N 个字符                 | `INDEX(email(10))`  |

  ------

  # ⚙️ 五、索引的基本操作

  ### ✅ 1. 创建索引

  ```
  -- 创建普通索引
  CREATE INDEX idx_name ON employees(name);
  
  -- 创建唯一索引
  CREATE UNIQUE INDEX idx_email ON employees(email);
  
  -- 创建复合索引（多列联合）
  CREATE INDEX idx_dept_salary ON employees(department, salary);
  ```

  ------

  ### ✅ 2. 删除索引

  ```
  DROP INDEX idx_name ON employees;
  ```

  ------

  ### ✅ 3. 查看索引

  ```
  SHOW INDEX FROM employees;
  ```

  输出会包含索引名、列名、是否唯一等信息。

  ------

  ### ✅ 4. 在建表时创建索引

  ```
  CREATE TABLE employees (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50),
    email VARCHAR(100),
    INDEX idx_name (name),
    UNIQUE INDEX idx_email (email)
  );
  ```

  ------

  # 📊 六、索引使用的场景与技巧

  | 场景                          | 是否适合建索引 | 原因                          |
  | ----------------------------- | -------------- | ----------------------------- |
  | `WHERE name = 'Alice'`        | ✅              | 精确查找，索引最有效          |
  | `WHERE age BETWEEN 20 AND 30` | ✅              | 范围查找高效                  |
  | `ORDER BY salary`             | ✅              | 可直接利用索引排序            |
  | `JOIN ON dept_id`             | ✅              | 加速多表连接                  |
  | `WHERE YEAR(hire_date)=2020`  | ❌              | 函数作用在列上，索引失效      |
  | `WHERE name LIKE '%A%'`       | ❌              | 前缀有通配符，无法用索引      |
  | `WHERE name LIKE 'A%'`        | ✅              | 可用索引前缀匹配              |
  | 频繁更新的列                  | ❌              | 每次更新都要维护索引结构      |
  | 低区分度列（如性别）          | ❌              | “男/女”两种值无法明显过滤数据 |

  ------

  # 🧠 七、复合索引与最左前缀原则

  假设有索引：

  ```
  CREATE INDEX idx_name_age ON employees(name, age);
  ```

  则可用的情况是：

  | 查询条件                        | 是否用到索引 | 说明             |
  | ------------------------------- | ------------ | ---------------- |
  | `WHERE name='Alice'`            | ✅            | 用到 `name`      |
  | `WHERE name='Alice' AND age=25` | ✅            | 用到 `name, age` |
  | `WHERE age=25`                  | ❌            | 跳过了“最左列”   |

  > 📌 **复合索引从左到右依次有效**，跳过前面的列则索引失效。

  ------

  # ⚡ 八、索引的性能验证

  你可以用：

  ```
  EXPLAIN SELECT * FROM employees WHERE name='Alice';
  ```

  它会显示 MySQL 实际是否使用了索引（`key` 字段）。

  ------

  # 🧱 九、索引的成本与维护

  | 操作         | 成本                     |
  | ------------ | ------------------------ |
  | 插入数据     | 必须更新索引结构（略慢） |
  | 删除数据     | 必须同步删除索引项       |
  | 更新被索引列 | 必须重建索引节点         |
  | 查询数据     | 明显提速（尤其是大表）   |

  所以索引不是越多越好，要**平衡“查”和“写”性能**。



# 2.NULL值处理：

我们已经知道 MySQL 使用 **SELECT** 命令及 **WHERE** 子句来读取数据表中的数据，但是当提供的查询条件字段为 NULL 时，该命令可能就无法正常工作。

在 MySQL 中，NULL 用于表示缺失的或未知的数据，处理 NULL 值需要特别小心，因为在数据库中它可能会导致不同于预期的结果。

为了处理这种情况，MySQL提供了三大运算符:

- **IS NULL:** 当列的值是 NULL,此运算符返回 true。
- **IS NOT NULL:** 当列的值不为 NULL, 运算符返回 true。
- **<=>:** 比较操作符（不同于 = 运算符），当比较的的两个值相等或者都为 NULL 时返回 true。

关于 NULL 的条件比较运算是比较特殊的。你不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。

在 MySQL 中，NULL 值与任何其它值的比较（即使是 NULL）永远返回 NULL，即 NULL = NULL 返回 NULL 。

MySQL 中处理 NULL 使用 IS NULL 和 IS NOT NULL 运算符。

> **注意：**
>
> ``` 
> select * , columnName1+ifnull(columnName2,0) from tableName;
> ```

### MySQL 中处理 NULL 值的常见注意事项和技巧

1. 检查是否为 NULL：

要检查某列是否为 NULL，可以使用 IS NULL 或 IS NOT NULL 条件。

```
SELECT * FROM employees WHERE department_id IS NULL;
SELECT * FROM employees WHERE department_id IS NOT NULL;
```

2. 使用 COALESCE 函数处理 NULL：

COALESCE 函数可以用于替换为 NULL 的值，它接受多个参数，返回参数列表中的第一个非 NULL 值：

```
SELECT product_name, COALESCE(stock_quantity, 0) AS actual_quantity
FROM products;
```

以上 SQL 语句中，如果 stock_quantity 列为 NULL，则 COALESCE 将返回 0。

3. 使用 IFNULL 函数处理 NULL：

IFNULL 函数是 COALESCE 的 MySQL 特定版本，它接受两个参数，如果第一个参数为 NULL，则返回第二个参数。

```
SELECT product_name, IFNULL(stock_quantity, 0) AS actual_quantity
FROM products;
```

4. NULL 排序：

在使用 ORDER BY 子句进行排序时，NULL 值默认会被放在排序的最后。如果希望将 NULL 值放在最前面，可以使用 ORDER BY column_name ASC NULLS FIRST，反之使用 ORDER BY column_name DESC NULLS LAST。

```
SELECT product_name, price
FROM products
ORDER BY price ASC NULLS FIRST;
```

5. 使用 <=> 操作符进行 NULL 比较：

<=> 操作符是 MySQL 中用于比较两个表达式是否相等的特殊操作符，对于 NULL 值的比较也会返回 TRUE。它可以用于处理 NULL 值的等值比较。

```
SELECT * FROM employees WHERE commission <=> NULL;
```

6. 注意聚合函数对 NULL 的处理：

在使用聚合函数（如 COUNT, SUM, AVG）时，它们会忽略 NULL 值，因此可能会得到不同于预期的结果。如果希望将 NULL 视为 0，可以使用 COALESCE 或 IFNULL。

```
SELECT AVG(COALESCE(salary, 0)) AS avg_salary FROM employees;
```

这样即使 salary 为 NULL，聚合函数也会将其视为 0。

> 处理 NULL 值时，要特别小心确保查询和操作的语义符合预期。在设计表结构时，也需要考虑 NULL 值的使用场景和合理性。



# 3.正则表达式：

## 1) 基本符号与含义

- `^`
  - 含义：匹配输入字符串的**开始位置**。
  - 举例：`^abc` 能匹配 `"abcdef"` 中的开头 `abc`，但不能匹配 `"xabc"` 中的 `abc`。
  - 多行模式（`m` / Multiline）下：`^` 也匹配行内换行后的位置（即行首）。
- `$`
  - 含义：匹配输入字符串的**结束位置**。
  - 举例：`abc$` 能匹配 `"xabc"` 的结尾 `abc`，不能匹配 `"abcx"`。
  - 多行模式下：`$` 也匹配行内换行前的位置（即行尾）。
- `.`
  - 含义：匹配**任意单个字符**（通常不包括换行 `\n`）。
  - 举例：`a.c` 可匹配 `abc`, `a-c`, `a c`，但默认不匹配 `a\nc`。
  - 若要让点匹配包括换行，使用“点任意匹配（dotall）”模式（常见标志是 `s`，或者用等价的模式/选项）；某些环境没有 `s`，可以用 `[\s\S]` 或 `[.\n]` 来代替。
- `[...]`（字符集合）
  - 含义：匹配集合里**任意一个字符**。
  - 举例：`[abc]` 匹配 `a`、`b` 或 `c`。`[aeiou]` 匹配元音。`[0-9]` 表示一位数字。`[A-Za-z]` 表示字母。
  - 注意：字符集内的 `-` 表示范围（如 `a-z`），若要匹配 `-` 本身可以放在首尾或转义 `\-`。
- `[^...]`（否定字符集合）
  - 含义：匹配**不在集合**内的任意单个字符。
  - 举例：`[^abc]` 匹配除 `a,b,c` 以外的任意字符。
- `p1|p2|p3`（选择/或）
  - 含义：匹配 `p1` 或 `p2` 或 `p3`（按顺序尝试，遇到第一个匹配即用）。
  - 举例：`cat|dog` 匹配 `"cat"` 或 `"dog"`。用括号可以与其他部分组合：`(cat|dog)s?`。

## 2) 量词（重复）与界定次数

- `*`：零次或多次（等价 `{0,}`）。
  - 例：`ab*` 能匹配 `a`, `ab`, `abb`, `abbb`...
- `+`：一次或多次（等价 `{1,}`）。
  - 例：`ab+` 匹配 `ab`, `abb`，但不匹配单独的 `a`。
- `?`：零次或一次
  - 例：`colou?r` 匹配 `color` 或 `colour`。
- `{n}`：恰好 n 次。
  - 例：`o{2}` 匹配两个连续的 `o`（如 `food` 中的 `oo`）。
- `{n,m}`：至少 n 次，最多 m 次。
  - 例：`a{2,4}` 匹配 `aa`、`aaa` 或 `aaaa`。

## 3) 预定义字符类（第二组补充的常见项）

- `\w`：字母数字字符（word character，通常包含字母、数字和下划线 `_`）。在 Unicode-aware 引擎中，`\w` 可匹配更多 Unicode 字母/数字（取决于引擎）。
  - 等价例子（在很多引擎下）:`[A-Za-z0-9_]`（但 Unicode 模式下更宽泛）。
- `\d`：数字字符，相当于 `[0-9]`（在 Unicode 引擎下可能包含其他数字类）。
- `\s`：空白字符，匹配空格、制表符、换行等。等价于 `[ \t\r\n\f\v]`（具体集合由引擎决定并可能扩展到 Unicode 空白）。
- `\W, \D, \S`：分别是否定形式（非字母数字、非数字、非空白）。
- `.`（前面也提过）在一些引擎下不匹配 `\n`，而 `[\s\S]` 或 `(?s).` 可以包含所有字符。

查找 name 字段中以 **'st'** 为开头的所有数据：

```
mysql> SELECT name FROM person_tbl WHERE name REGEXP '^st';
```

查找 name 字段中以 **'ok'** 为结尾的所有数据：

```
mysql> SELECT name FROM person_tbl WHERE name REGEXP 'ok$';
```

查找 name 字段中包含 **'mar'** 字符串的所有数据：

```
mysql> SELECT name FROM person_tbl WHERE name REGEXP 'mar';
```

查找 name 字段中以元音字符开头或以 **'ok'** 字符串结尾的所有数据：

```
mysql> SELECT name FROM person_tbl WHERE name REGEXP '^[aeiou]|ok$';
```

选择订单表中描述中包含 "item" 后跟一个或多个数字的记录。

```
SELECT * FROM orders WHERE order_description REGEXP 'item[0-9]+';
```

使用 **BINARY** 关键字，使得匹配区分大小写：

```
SELECT * FROM products WHERE product_name REGEXP BINARY 'apple';
```

使用 OR 进行多个匹配条件，以下将选择姓氏为 "Smith" 或 "Johnson" 的员工记录：

```
SELECT * FROM employees WHERE last_name REGEXP 'Smith|Johnson';
```



# 4.事务的概念？

MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！

在 MySQL 中，事务是一组SQL语句的执行，它们被视为一个单独的工作单元。

- 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。
- 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。
- 事务用来管理 **insert、update、delete** 语句

一般来说，事务是必须满足4个条件（ACID）：：原子性（**A**tomicity，或称不可分割性）、一致性（**C**onsistency）、隔离性（**I**solation，又称独立性）、持久性（**D**urability）。

- **原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
- **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
- **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

> 在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。

### 事务控制语句：

- BEGIN 或 START TRANSACTION 显式地开启一个事务；
- COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；
- ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；
- SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；
- RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；
- ROLLBACK TO identifier 把事务回滚到标记点；
- SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。

### MYSQL 事务处理主要有两种方法：

1、用 BEGIN, ROLLBACK, COMMIT 来实现

- **BEGIN 或 START TRANSACTION**：开用于开始一个事务。
- **ROLLBACK** 事务回滚，取消之前的更改。
- **COMMIT**：事务确认，提交事务，使更改永久生效。

2、直接用 SET 来改变 MySQL 的自动提交模式:

- **SET AUTOCOMMIT=0** 禁止自动提交
- **SET AUTOCOMMIT=1** 开启自动提交

**BEGIN 或 START TRANSACTION** -- 用于开始一个事务：

```
BEGIN; -- 或者使用 START TRANSACTION;
```

**COMMIT** -- 用于提交事务，将所有的修改永久保存到数据库：

```
COMMIT;
```

**ROLLBACK** -- 用于回滚事务，撤销自上次提交以来所做的所有更改：

```
ROLLBACK;
```

**SAVEPOINT** -- 用于在事务中设置保存点，以便稍后能够回滚到该点：

```
SAVEPOINT savepoint_name;
```

**ROLLBACK TO SAVEPOINT** -- 用于回滚到之前设置的保存点：

```
ROLLBACK TO SAVEPOINT savepoint_name;
```

下面是一个简单的 MySQL 事务的例子：

## 实例

*-- 开始事务*
**START** **TRANSACTION**;

*-- 执行一些SQL语句*
**UPDATE** accounts **SET** balance = balance - 100 **WHERE** user_id = 1;
**UPDATE** accounts **SET** balance = balance + 100 **WHERE** user_id = 2;

*-- 判断是否要提交还是回滚*
**IF** (条件) **THEN**
  COMMIT; *-- 提交事务*
**ELSE**
  **ROLLBACK**; *-- 回滚事务*
**END** **IF**;



实例

一个简单的事务实例：

mysql> use RUNOOB;
Database changed
mysql> CREATE TABLE runoob_transaction_test( id int(5)) engine=innodb;  # 创建数据表
Query OK, 0 rows affected (0.04 sec)

mysql> select * from runoob_transaction_test;
Empty set (0.01 sec)

mysql> begin;  # 开始事务
Query OK, 0 rows affected (0.00 sec)

mysql> insert into runoob_transaction_test value(5);
Query OK, 1 rows affected (0.01 sec)

mysql> insert into runoob_transaction_test value(6);
Query OK, 1 rows affected (0.00 sec)

mysql> commit; # 提交事务
Query OK, 0 rows affected (0.01 sec)

mysql>  select * from runoob_transaction_test;
+------+
| id   |
+------+
| 5    |
| 6    |
+------+
2 rows in set (0.01 sec)

mysql> begin;    # 开始事务
Query OK, 0 rows affected (0.00 sec)

mysql>  insert into runoob_transaction_test values(7);
Query OK, 1 rows affected (0.00 sec)

mysql> rollback;   # 回滚
Query OK, 0 rows affected (0.00 sec)

mysql>   select * from runoob_transaction_test;   # 因为回滚所以数据没有插入
+------+
| id   |
+------+
| 5    |
| 6    |
+------+
2 rows in set (0.01 sec)

mysql>

补充：隔离等级的概念：

好的，我们来系统讲一下 **隔离等级（Isolation Level）** 的概念、作用以及在数据库中的使用场景。

------

## 1️⃣ 概念

**隔离等级**是数据库事务管理（Transaction Management）中的一个重要概念，它定义了 **一个事务在执行过程中，对其他事务可见的程度**。

换句话说，隔离等级决定了 **事务之间的干扰程度**，控制不同事务之间 **并发操作时的“互相看到的数据状态”**。

- 事务（Transaction）是一系列操作的集合，要么全部成功，要么全部失败。
- 隔离性（Isolation）是 ACID 中的四个特性之一（Atomicity、Consistency、Isolation、Durability）。
- 隔离等级规定了 **事务在并发时可以看到哪些数据变更**。

------

## 2️⃣ 四种隔离等级及说明

MySQL（以及大多数关系型数据库）定义了四种隔离等级，从 **低** 到 **高**：

| 隔离等级                         | 描述                                                  | 是否可能出现脏读 / 不可重复读 / 幻读 |
| -------------------------------- | ----------------------------------------------------- | ------------------------------------ |
| **READ UNCOMMITTED**（未提交读） | 事务可以读取其他事务未提交的数据                      | 脏读 ✅ 不可重复读 ✅ 幻读 ✅           |
| **READ COMMITTED**（提交读）     | 只能读取其他事务已提交的数据                          | 脏读 ❌ 不可重复读 ✅ 幻读 ✅           |
| **REPEATABLE READ**（可重复读）  | 事务中多次读取同一行数据，结果相同（InnoDB 默认级别） | 脏读 ❌ 不可重复读 ❌ 幻读 ✅           |
| **SERIALIZABLE**（可串行化）     | 最高级别，事务像排队执行一样                          | 脏读 ❌ 不可重复读 ❌ 幻读 ❌           |

------

## 3️⃣ 现象解释

1. **脏读（Dirty Read）**

- 一个事务读到了 **另一个事务未提交的数据**。
- 例子：
  - 事务 A 修改了某行，但还没提交。
  - 事务 B 读取了这条未提交的数据。
  - 如果 A 回滚，B 读取的数据就是错误的。

1. **不可重复读（Non-Repeatable Read）**

- 同一个事务内，**同一条记录两次读取到不同结果**。
- 例子：
  - 事务 A 读取某行数据。
  - 事务 B 修改并提交了这行数据。
  - 事务 A 再次读取时发现数据变化。

1. **幻读（Phantom Read）**

- 同一个事务内，**查询范围内的记录数量或内容变化**。
- 例子：
  - 事务 A 查询满足条件的多行记录。
  - 事务 B 插入新的满足条件的记录并提交。
  - 事务 A 再查询时发现“新增记录”，就像出现了“幻影”。

------

## 4️⃣ MySQL 中设置隔离等级

### 查询当前隔离等级

```
-- 查看全局隔离等级
SELECT @@global.tx_isolation;
-- 查看会话隔离等级
SELECT @@session.tx_isolation;
```

### 修改隔离等级

- **全局修改**（影响后续所有连接）：

```
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

- **当前会话修改**（仅当前连接有效）：

```
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

- **事务级别修改**（仅对单个事务生效）：

```
START TRANSACTION
  ISOLATION LEVEL SERIALIZABLE;
```

------

## 5️⃣ 使用场景

- **低隔离等级（READ UNCOMMITTED、READ COMMITTED）**
  - 并发高、性能要求高
  - 容忍少量脏读或不可重复读
  - 比如日志统计、分析报表等
- **高隔离等级（REPEATABLE READ、SERIALIZABLE）**
  - 事务对数据一致性要求高
  - 重要金融系统、库存管理
  - 防止脏读、不可重复读甚至幻读



补充：会话和临时表的概念。

**会话（Session）** 是指 **客户端与数据库（或服务器）之间建立的一个临时交互通道**，在这个通道中客户端可以发送 SQL 命令，数据库可以返回结果，并维护当前状态。

可以理解为：

- 一次会话就是从你登录数据库开始，到你退出数据库结束的整个过程。
- 会话期间，数据库可以记住一些**状态信息**，如事务状态、用户变量、权限等。

临时表：

MySQL 临时表在我们需要保存一些临时数据时是非常有用的。

临时表只在当前连接可见，当关闭连接时，MySQL 会自动删除表并释放所有空间。

在 MySQL 中，临时表是一种在当前会话中存在的表，它在会话结束时会自动被销毁。

MySQL 临时表只在当前连接可见，如果你使用PHP脚本来创建 MySQL 临时表，那每当 PHP 脚本执行完成后，该临时表也会自动销毁。

如果你使用了其他 MySQL 客户端程序连接 MySQL 数据库服务器来创建临时表，那么只有在关闭客户端程序时才会销毁临时表，当然你也可以手动销毁。

### 创建临时表

```
CREATE TEMPORARY TABLE temp_table_name (
  column1 datatype,
  column2 datatype,
  ...
);
```

后续对临时表的操作与普通表基本无异。



# 5.如何复制一张表



## 1️⃣ 概念

在 MySQL 中，“复制表”可以有两种含义：

1. **复制表结构（Structure）**：只复制表的列、数据类型、索引、默认值等，但不复制数据。
2. **复制表结构 + 数据（Full Copy）**：同时复制表结构和原表中的数据。

> 注意：使用 `CREATE TABLE ... SELECT` 只能部分复制表结构，**索引、默认值、约束等不会完全复制**。

------

## 2️⃣ 方法一：手动复制表结构和数据

### 步骤一：获取原表的完整创建语句

```
SHOW CREATE TABLE 原表名 \G;
```

输出示例：

```
*************************** 1. row ***************************
       Table: runoob_tbl
Create Table: CREATE TABLE `runoob_tbl` (
  `runoob_id` int(11) NOT NULL auto_increment,
  `runoob_title` varchar(100) NOT NULL default '',
  `runoob_author` varchar(40) NOT NULL default '',
  `submission_date` date default NULL,
  PRIMARY KEY  (`runoob_id`),
  UNIQUE KEY `AUTHOR_INDEX` (`runoob_author`)
) ENGINE=InnoDB
```

- 这个命令会显示原表的完整结构，包括 **列定义、主键、索引、默认值、存储引擎** 等。

------

### 步骤二：修改表名并创建新表

```
CREATE TABLE `新表名` (
  `runoob_id` int(11) NOT NULL auto_increment,
  `runoob_title` varchar(100) NOT NULL default '',
  `runoob_author` varchar(40) NOT NULL default '',
  `submission_date` date default NULL,
  PRIMARY KEY  (`runoob_id`),
  UNIQUE KEY `AUTHOR_INDEX` (`runoob_author`)
) ENGINE=InnoDB;
```

- 将原表 `runoob_tbl` 改为新表名 `clone_tbl` 即可创建一张结构完全相同的新表。

------

### 步骤三：复制数据（可选）

```
INSERT INTO clone_tbl (runoob_id, runoob_title, runoob_author, submission_date)
SELECT runoob_id, runoob_title, runoob_author, submission_date
FROM runoob_tbl;
```

- 这条语句会将原表的数据全部插入到新表中。
- 执行完后，`clone_tbl` 的表结构和数据都与 `runoob_tbl` 一致。

------

## 3️⃣ 方法二：使用 `mysqldump` 命令（适合备份/迁移）

### 导出表

```
mysqldump -u username -p dbname old_table > old_table_dump.sql
```

- 导出表的结构和数据到 SQL 文件。
- 需要替换：
  - `username`：MySQL 用户名
  - `dbname`：数据库名
  - `old_table`：原表名

------

### 导入表到新数据库/新表

```
mysql -u username -p new_dbname < old_table_dump.sql
```

- 将 SQL 文件中的结构和数据导入到 `new_dbname` 数据库。
- 会在新数据库中创建同名表。