# 1.Redis是什么，特点是什么，和MySQL的区别是什么，使用场景有哪些，和MySQL的使用场景有什么不同

## 一、Redis 是什么

**Redis（Remote Dictionary Server）** 是一个开源的、基于内存的 **键值型（Key-Value）数据库**。
 它最大的特点是：

- **所有数据都存储在内存中（Memory-Based）**，因此**读写速度极快**。
- 同时支持数据持久化（即可以将内存中的数据保存到磁盘中），防止数据丢失。

Redis 通常被称为：

> “一个数据结构服务器（Data Structure Server）”

因为它不仅能存字符串（String），还支持多种复杂数据结构：

- **String**：字符串（可存文本、数字、二进制数据）
- **List**：链表（有序集合，可实现消息队列）
- **Set**：无序集合（可去重）
- **Sorted Set（ZSet）**：带权重的有序集合（适用于排行榜等场景）
- **Hash**：哈希表（键值对集合，适合存对象）
- **Bitmap / HyperLogLog / Stream** 等高级数据结构

------

## 二、Redis 的主要特点

| **高性能**               | 所有操作都在内存中完成，读写速度极快，通常单机能达到 **10万+ QPS（每秒查询数）** |
| ------------------------ | ------------------------------------------------------------ |
| 特点类别                 | 说明                                                         |
| **支持丰富数据结构**     | 除了字符串，还支持列表、集合、有序集合、哈希等               |
| **支持持久化**           | 数据可以定期或实时写入磁盘（RDB / AOF 持久化方式）           |
| **支持事务**             | MULTI、EXEC、WATCH 机制保证多个命令的原子执行                |
| **支持发布/订阅**        | 可以用于消息队列、实时推送等场景                             |
| **支持分布式与主从复制** | 可构建主从复制、高可用（Redis Sentinel）、分布式集群（Redis Cluster） |
| **轻量且易部署**         | 单机部署简单，占用资源小                                     |
| **原子操作**             | 所有操作均为原子性（线程安全）                               |

------

## 三、Redis 与 MySQL 的区别

| 对比维度       | **Redis**                                 | **MySQL**                  |
| -------------- | ----------------------------------------- | -------------------------- |
| **数据类型**   | 键值（Key-Value）数据库，支持多种数据结构 | 关系型数据库（表格结构）   |
| **存储方式**   | **内存存储**（可持久化）                  | **磁盘存储**               |
| **性能**       | 极快（读写都在内存中）                    | 相对较慢（磁盘 I/O）       |
| **数据量**     | 通常用于小数据集（内存容量限制）          | 可存储大规模数据           |
| **持久化**     | 可选择 RDB / AOF                          | 数据默认持久化             |
| **事务支持**   | 简单事务（无回滚机制）                    | 完整事务（ACID）           |
| **适用场景**   | 缓存、消息队列、计数器、分布式锁等        | 核心业务数据存储、事务处理 |
| **一致性要求** | 一般是 **最终一致性**                     | 支持强一致性（ACID）       |
| **索引机制**   | 基于内存结构（例如跳表）                  | B+ 树索引                  |
| **主从复制**   | 原生支持                                  | 原生支持                   |
| **查询方式**   | 只能通过键（Key）访问                     | 支持复杂 SQL 查询          |

------

## 四、Redis 的典型使用场景

| 场景             | 示例                               | Redis 的优势                   |
| ---------------- | ---------------------------------- | ------------------------------ |
| **缓存**         | 缓存热点数据，如用户信息、商品详情 | 减轻数据库压力，响应更快       |
| **排行榜**       | 游戏积分榜、热门文章榜             | 使用有序集合（ZSet）可快速排序 |
| **计数器**       | 文章点赞数、访问量                 | 自增操作（INCR）性能极高       |
| **消息队列**     | 异步任务处理                       | 使用 List 或 Stream 实现       |
| **Session 共享** | 多台服务器共享用户登录状态         | 内存读写快、易于过期管理       |
| **分布式锁**     | 防止多进程同时修改资源             | 原子性 SETNX 实现              |
| **地理位置计算** | 附近的人、附近的店铺               | GEO 数据结构提供经纬度支持     |
| **实时统计**     | PV/UV 统计、在线用户数             | HyperLogLog 或 Bitmap 实现     |

------

## 五、MySQL 的典型使用场景

| 场景             | 示例                     | 原因                     |
| ---------------- | ------------------------ | ------------------------ |
| **核心业务数据** | 用户信息、订单、支付记录 | 需要强一致性和可靠持久化 |
| **复杂查询**     | 多表关联、聚合、过滤     | 支持 SQL 查询和索引优化  |
| **报表系统**     | 统计、分析、导出数据     | 数据关系性强             |
| **历史归档**     | 存储长期日志、历史记录   | 磁盘容量大，成本低       |

------

## 六、Redis 与 MySQL 的**结合使用场景**

在实际开发中，两者往往是 **搭配使用** 的：

### 🔹“冷热数据分离”模式

- **Redis 存热数据**（访问频繁、实时要求高的数据）
- **MySQL 存冷数据**（长期存储、低访问频率的数据）

### 🔹“读写分离”模式

1. 用户请求 → 先读 Redis
2. 如果 Redis 缓存中没有（缓存未命中） → 再查 MySQL
3. 查到结果后 → 写入 Redis（缓存预热）
4. 下次直接从 Redis 读

这称为 **缓存模式（Cache Aside Pattern）**

------

## 七、总结对比（简表）

| 项目     | Redis                      | MySQL            |
| -------- | -------------------------- | ---------------- |
| 类型     | 内存型键值数据库           | 磁盘型关系数据库 |
| 查询能力 | 简单Key查询                | 复杂SQL查询      |
| 速度     | 毫秒级                     | 毫秒到秒级       |
| 持久化   | 可选                       | 默认持久化       |
| 一致性   | 弱（最终一致性）           | 强（ACID）       |
| 典型用途 | 缓存、消息、计数、会话、锁 | 业务数据存储     |
| 数据量   | 小到中等（内存限制）       | 大量数据（磁盘） |



## 补充：什么是BDS协议？Redis是遵守BDS协议的。

**BSD 协议（Berkeley Software Distribution License）** 是一种非常 **宽松的开源许可证（Permissive License）**。
 它起源于美国加州大学伯克利分校（University of California, Berkeley），最初用于该校开发的 **BSD Unix 系统**，后来被广泛用于各类开源项目中。

> 简而言之：
>  **BSD 协议允许你“几乎随意使用代码”** —— 包括复制、修改、分发、甚至用于商业闭源软件中，只要保留原始版权声明即可。

------

### BSD 协议的核心内容（以 3-Clause BSD License 为例）

现代常见的 BSD 协议主要是 **3-Clause BSD License**，即“三条款 BSD 协议”，主要内容如下：

1. **允许使用和分发**
    你可以自由地使用、修改和再分发源代码或二进制代码，无论是开源还是闭源项目。
2. **必须保留原始版权声明**
    无论你是否修改代码，只要发布出去（包括商业软件），都必须在代码或文档中保留原作者的版权信息与免责声明。
3. **不得滥用原作者名义进行宣传**
    你不能用原作者或机构的名字为你的派生产品做广告或背书。

------

### ✅ 3-Clause BSD 协议原文（简化版中文解释）

| 条款 | 内容                                                         | 说明                 |
| ---- | ------------------------------------------------------------ | -------------------- |
| 1️⃣    | 允许源代码和二进制形式的再分发和使用，无论是否修改，只要保留上述版权声明。 | 可以商用、闭源、修改 |
| 2️⃣    | 再分发时必须包含原作者的版权和许可声明。                     | 必须注明来源         |
| 3️⃣    | 未经书面许可，不得使用原作者或组织的名字为派生产品背书。     | 不得用原作者名义宣传 |



# 2.Redis启动的相关指令：

`redis-cli`：启动Redis命令行（Redis Command-Line interface）

`redis-cli -h host -p port -a password`:远程登录，指定主机名，端口号，密码。

`ping`： 回应pong，用户服务器心跳检测

`config get *` : 查看配置文件，奇数行是字段，偶数行是指。

几个比较重要的配置信息：

| 序号 | 配置项                                                       | 说明                                                         |
| :--- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 1    | `daemonize no`                                               | Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ） |
| 2    | `pidfile /var/run/redis.pid`                                 | 当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定 |
| 3    | `port 6379`                                                  | 指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字 |
| 4    | `bind 127.0.0.1`                                             | 绑定的主机地址                                               |
| 5    | `timeout 300`                                                | 当客户端闲置多长秒后关闭连接，如果指定为 0 ，表示关闭该功能  |
| 6    | `loglevel notice`                                            | 指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice |
| 7    | `logfile stdout`                                             | 日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null |
| 8    | `databases 16`                                               | 设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id |
| 9    | `save <seconds> <changes>`Redis 默认配置文件中提供了三个条件：**save 900 1****save 300 10****save 60 10000**分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。 | 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 |
| 10   | `rdbcompression yes`                                         | 指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大 |
| 11   | `dbfilename dump.rdb`                                        | 指定本地数据库文件名，默认值为 dump.rdb                      |
| 12   | `dir ./`                                                     | 指定本地数据库存放目录                                       |
| 13   | `slaveof <masterip> <masterport>`                            | 设置当本机为 slave 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步 |
| 14   | `masterauth <master-password>`                               | 当 master 服务设置了密码保护时，slave 服务连接 master 的密码 |
| 15   | `requirepass foobared`                                       | 设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH <password> 命令提供密码，默认关闭 |
| 16   | ` maxclients 128`                                            | 设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息 |
| 17   | `maxmemory <bytes>`                                          | 指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区 |
| 18   | `appendonly no`                                              | 指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no |
| 19   | `appendfilename appendonly.aof`                              | 指定更新日志文件名，默认为 appendonly.aof                    |
| 20   | `appendfsync everysec`                                       | 指定更新日志条件，共有 3 个可选值：**no**：表示等操作系统进行数据缓存同步到磁盘（快）**always**：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）**everysec**：表示每秒同步一次（折中，默认值） |
| 21   | `vm-enabled no`                                              | 指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制） |
| 22   | `vm-swap-file /tmp/redis.swap`                               | 虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享 |
| 23   | `vm-max-memory 0`                                            | 将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0 |
| 24   | `vm-page-size 32`                                            | Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值 |
| 25   | `vm-pages 134217728`                                         | 设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。 |
| 26   | `vm-max-threads 4`                                           | 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 |
| 27   | `glueoutputbuf yes`                                          | 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 |
| 28   | `hash-max-zipmap-entries 64 hash-max-zipmap-value 512`       | 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 |
| 29   | `activerehashing yes`                                        | 指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍） |
| 30   | `include /path/to/local.conf`                                | 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 |



# 3.Redis中的数据类型和对应的命令

## Redis 主要支持以下几种数据类型：

- **string（字符串）:** 基本的数据存储单元，可以存储字符串、整数或者浮点数。
- **hash（哈希）:**一个键值对集合，可以存储多个字段。
- **list（列表）:**一个简单的列表，可以存储一系列的字符串元素。
- **set（集合）:**一个无序集合，可以存储不重复的字符串元素。
- **zset(sorted set：有序集合):** 类似于集合，但是每个元素都有一个分数（score）与之关联。
- **位图（Bitmaps）：**基于字符串类型，可以对每个位进行操作。
- **超日志（HyperLogLogs）：**用于基数统计，可以估算集合中的唯一元素数量。
- **地理空间（Geospatial）：**用于存储地理位置信息。
- **发布/订阅（Pub/Sub）：**一种消息通信模式，允许客户端订阅消息通道，并接收发布到该通道的消息。
- **流（Streams）：**用于消息队列和日志存储，支持消息的持久化和时间排序。
- **模块（Modules）：**Redis 支持动态加载模块，可以扩展 Redis 的功能。

以下是常用的数据类型和对应指令：

## String（字符串）

string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。

string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据，比如jpg图片或者序列化的对象。

string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。

### 常用命令

- 

- | 序号 | 命令及描述                                                   |
  | :--- | :----------------------------------------------------------- |
  | 1    | [SET key value](https://www.runoob.com/redis/strings-set.html) 设置指定 key 的值。 |
  | 2    | [GET key](https://www.runoob.com/redis/strings-get.html) 获取指定 key 的值。 |
  | 3    | [GETRANGE key start end](https://www.runoob.com/redis/strings-getrange.html) 返回 key 中字符串值的子字符 |
  | 4    | [GETSET key value](https://www.runoob.com/redis/strings-getset.html) 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。 |
  | 5    | [GETBIT key offset](https://www.runoob.com/redis/strings-getbit.html) 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。 |
  | 6    | [MGET key1 [key2..\]](https://www.runoob.com/redis/strings-mget.html) 获取所有(一个或多个)给定 key 的值。 |
  | 7    | [SETBIT key offset value](https://www.runoob.com/redis/strings-setbit.html) 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。 |
  | 8    | [SETEX key seconds value](https://www.runoob.com/redis/strings-setex.html) 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。 |
  | 9    | [SETNX key value](https://www.runoob.com/redis/strings-setnx.html) 只有在 key 不存在时设置 key 的值。 |
  | 10   | [SETRANGE key offset value](https://www.runoob.com/redis/strings-setrange.html) 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。 |
  | 11   | [STRLEN key](https://www.runoob.com/redis/strings-strlen.html) 返回 key 所储存的字符串值的长度。 |
  | 12   | [MSET key value [key value ...\]](https://www.runoob.com/redis/strings-mset.html) 同时设置一个或多个 key-value 对。 |
  | 13   | [MSETNX key value [key value ...\]](https://www.runoob.com/redis/strings-msetnx.html) 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。 |
  | 14   | [PSETEX key milliseconds value](https://www.runoob.com/redis/strings-psetex.html) 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。 |
  | 15   | [INCR key](https://www.runoob.com/redis/strings-incr.html) 将 key 中储存的数字值增一。 |
  | 16   | [INCRBY key increment](https://www.runoob.com/redis/strings-incrby.html) 将 key 所储存的值加上给定的增量值（increment） 。 |
  | 17   | [INCRBYFLOAT key increment](https://www.runoob.com/redis/strings-incrbyfloat.html) 将 key 所储存的值加上给定的浮点增量值（increment） 。 |
  | 18   | [DECR key](https://www.runoob.com/redis/strings-decr.html) 将 key 中储存的数字值减一。 |
  | 19   | [DECRBY key decrement](https://www.runoob.com/redis/strings-decrby.html) key 所储存的值减去给定的减量值（decrement） 。 |
  | 20   | [APPEND key value](https://www.runoob.com/redis/strings-append.html) 如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。 |

### 容易有疑问的点：

##### [GETRANGE key start end](https://www.runoob.com/redis/strings-getrange.html) 

返回 key 中字符串值的子字符

容错度很高，基本不会报错。start > end 返回空字符串

负数会倒着数，如果超出长度置为0。



##### [GETBIT key offset](https://www.runoob.com/redis/strings-getbit.html) 

对 key 所储存的字符串值，获取指定偏移量上的位(bit)。

###### 🧩 一、命令定义

```
GETBIT key offset
```

**作用：**
 从指定键（key）存储的 **字符串值** 中，获取第 `offset` 个**二进制位（bit）** 的值。

返回结果是：

- `0` → 该位置上的比特为 0
- `1` → 该位置上的比特为 1

------

###### 🧠 二、理解关键点：Redis 字符串是“字节序列”

你平时看到的 Redis “字符串”，其实在底层是**字节数组（byte array）**。
 一个字节 = 8 个二进制位（bit）。

例如：

```
字符: "A"
ASCII码: 65
二进制: 01000001
```

所以 `"A"` 实际占 1 个字节，共 8 位。

------

###### 🧪 三、举例说明

我们来试一下：

```
set mykey "A"
```

然后查看某些位：

```
getbit mykey 0
getbit mykey 1
getbit mykey 6
getbit mykey 7
```

------

###### ✅ 解析

"A" = `01000001`（二进制）

| 位偏移 | 二进制位 | 说明                   |
| ------ | -------- | ---------------------- |
| 0      | 0        | 最左边的最高位（bit7） |
| 1      | 1        | bit6                   |
| 2      | 0        | bit5                   |
| 3      | 0        | bit4                   |
| 4      | 0        | bit3                   |
| 5      | 0        | bit2                   |
| 6      | 0        | bit1                   |
| 7      | 1        | 最右边的最低位（bit0） |

Redis 是**从左往右**计数（即第一个 bit 为 offset=0）。

所以执行结果会是：

```
getbit mykey 0  → 0
getbit mykey 1  → 1
getbit mykey 7  → 1
```

------

###### ⚙️ 四、`offset` 是按“bit位”算的

如果你有一个字符串 `"ABC"`：

| 字符 | 字节范围 | bit偏移范围 |
| ---- | -------- | ----------- |
| A    | 第0字节  | 0 ~ 7       |
| B    | 第1字节  | 8 ~ 15      |
| C    | 第2字节  | 16 ~ 23     |

所以：

- `getbit mykey 0` → A 的最高位
- `getbit mykey 8` → B 的最高位
- `getbit mykey 16` → C 的最高位

------

###### 💡 五、典型使用场景

`GETBIT` / `SETBIT` 通常用于**高密度位存储**的业务，比如：

1. **用户签到系统**
   - 用一个 key 表示一个用户的一个月签到记录
   - 每天用 1 bit 表示是否签到（0=未签，1=已签）
   - 节省大量存储空间（1个月仅30 bit ≈ 4字节）
2. **活跃用户统计**
   - 使用 bitmap 表示每天是否活跃
   - 使用 `BITCOUNT` 统计活跃人数
   - 使用 `BITOP` 做交集、并集分析连续活跃用户
3. **海量布尔标记**
   - 比如黑名单、特征标志、权限位等





## Hash（哈希）

Redis hash 是一个键值(key=>value)对集合，类似于一个小型的 NoSQL 数据库。

Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。

每个哈希最多可以存储 2^32 - 1 个键值对。

### 常用命令

- 

- | 1    | [HDEL key field1 [field2\]](https://www.runoob.com/redis/hashes-hdel.html) 删除一个或多个哈希表字段 |
  | ---- | ------------------------------------------------------------ |
  | 2    | [HEXISTS key field](https://www.runoob.com/redis/hashes-hexists.html) 查看哈希表 key 中，指定的字段是否存在。 |
  | 3    | [HGET key field](https://www.runoob.com/redis/hashes-hget.html) 获取存储在哈希表中指定字段的值。 |
  | 4    | [HGETALL key](https://www.runoob.com/redis/hashes-hgetall.html) 获取在哈希表中指定 key 的所有字段和值 |
  | 5    | [HINCRBY key field increment](https://www.runoob.com/redis/hashes-hincrby.html) 为哈希表 key 中的指定字段的整数值加上增量 increment 。 |
  | 6    | [HINCRBYFLOAT key field increment](https://www.runoob.com/redis/hashes-hincrbyfloat.html) 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。 |
  | 7    | [HKEYS key](https://www.runoob.com/redis/hashes-hkeys.html) 获取哈希表中的所有字段 |
  | 8    | [HLEN key](https://www.runoob.com/redis/hashes-hlen.html) 获取哈希表中字段的数量 |
  | 9    | [HMGET key field1 [field2\]](https://www.runoob.com/redis/hashes-hmget.html) 获取所有给定字段的值 |
  | 10   | [HMSET key field1 value1 [field2 value2 \]](https://www.runoob.com/redis/hashes-hmset.html) 同时将多个 field-value (域-值)对设置到哈希表 key 中。 |
  | 11   | [HSET key field value](https://www.runoob.com/redis/hashes-hset.html) 将哈希表 key 中的字段 field 的值设为 value 。 |
  | 12   | [HSETNX key field value](https://www.runoob.com/redis/hashes-hsetnx.html) 只有在字段 field 不存在时，设置哈希表字段的值。 |
  | 13   | [HVALS key](https://www.runoob.com/redis/hashes-hvals.html) 获取哈希表中所有值。 |
  | 14   | [HSCAN key cursor [MATCH pattern\] [COUNT count]](https://www.runoob.com/redis/hashes-hscan.html) 迭代哈希表中的键值对。 |

### 实例

**DEL runoob** 用于删除前面测试用过的 key，不然会报错

![img](https://www.runoob.com/wp-content/uploads/2014/11/B104156B-7270-4D03-8EB3-B72D4022ED78.jpg)

```
redis 127.0.0.1:6379> DEL runoob
redis 127.0.0.1:6379> HMSET runoob field1 "Hello" field2 "World"
"OK"
redis 127.0.0.1:6379> HGET runoob field1
"Hello"
redis 127.0.0.1:6379> HGET runoob field2
"World"
```

实例中我们使用了 Redis **HMSET, HGET** 命令，**HMSET** 设置了两个 **field=>value** 对, HGET 获取对应 **field** 对应的 **value**。

为了便于理解，哈希可以理解成MySQL中一张数据表的一行记录，其中key相当于唯一标识这一行的主键，field相当于一列，value是这一列对应的值。

## List（列表）

Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。

列表最多可以存储 2^32 - 1 个元素。

### 常用命令

- 

- | 序号 | 命令及描述                                                   |
  | :--- | :----------------------------------------------------------- |
  | 1    | [BLPOP key1 [key2 \] timeout](https://www.runoob.com/redis/lists-blpop.html) 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 |
  | 2    | [BRPOP key1 [key2 \] timeout](https://www.runoob.com/redis/lists-brpop.html) 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 |
  | 3    | [BRPOPLPUSH source destination timeout](https://www.runoob.com/redis/lists-brpoplpush.html) 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 |
  | 4    | [LINDEX key index](https://www.runoob.com/redis/lists-lindex.html) 通过索引获取列表中的元素 |
  | 5    | [LINSERT key BEFORE\|AFTER pivot value](https://www.runoob.com/redis/lists-linsert.html) 在列表的元素前或者后插入元素 |
  | 6    | [LLEN key](https://www.runoob.com/redis/lists-llen.html) 获取列表长度 |
  | 7    | [LPOP key](https://www.runoob.com/redis/lists-lpop.html) 移出并获取列表的第一个元素 |
  | 8    | [LPUSH key value1 [value2\]](https://www.runoob.com/redis/lists-lpush.html) 将一个或多个值插入到列表头部 |
  | 9    | [LPUSHX key value](https://www.runoob.com/redis/lists-lpushx.html) 将一个值插入到已存在的列表头部 |
  | 10   | [LRANGE key start stop](https://www.runoob.com/redis/lists-lrange.html) 获取列表指定范围内的元素 |
  | 11   | [LREM key count value](https://www.runoob.com/redis/lists-lrem.html) 移除列表元素 |
  | 12   | [LSET key index value](https://www.runoob.com/redis/lists-lset.html) 通过索引设置列表元素的值 |
  | 13   | [LTRIM key start stop](https://www.runoob.com/redis/lists-ltrim.html) 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。 |
  | 14   | [RPOP key](https://www.runoob.com/redis/lists-rpop.html) 移除列表的最后一个元素，返回值为移除的元素。 |
  | 15   | [RPOPLPUSH source destination](https://www.runoob.com/redis/lists-rpoplpush.html) 移除列表的最后一个元素，并将该元素添加到另一个列表并返回 |
  | 16   | [RPUSH key value1 [value2\]](https://www.runoob.com/redis/lists-rpush.html) 在列表中添加一个或多个值到列表尾部 |
  | 17   | [RPUSHX key value](https://www.runoob.com/redis/lists-rpushx.html) 为已存在的列表添加值 |

### 实例

```
redis 127.0.0.1:6379> DEL runoob
redis 127.0.0.1:6379> lpush runoob redis
(integer) 1
redis 127.0.0.1:6379> lpush runoob mongodb
(integer) 2
redis 127.0.0.1:6379> lpush runoob rabbitmq
(integer) 3
redis 127.0.0.1:6379> lrange runoob 0 10
1) "rabbitmq"
2) "mongodb"
3) "redis"
redis 127.0.0.1:6379>
```

## Set（集合）

Redis 的 Set 是 string 类型的无序集合。

集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。

### 常用命令

- 

- | 序号 | 命令及描述                                                   |
  | :--- | :----------------------------------------------------------- |
  | 1    | [SADD key member1 [member2\]](https://www.runoob.com/redis/sets-sadd.html) 向集合添加一个或多个成员 |
  | 2    | [SCARD key](https://www.runoob.com/redis/sets-scard.html) 获取集合的成员数 |
  | 3    | [SDIFF key1 [key2\]](https://www.runoob.com/redis/sets-sdiff.html) 返回第一个集合与其他集合之间的差集。 |
  | 4    | [SDIFFSTORE destination key1 [key2\]](https://www.runoob.com/redis/sets-sdiffstore.html) 返回第一个集合与其他集合之间的差集并存储在 destination 中 |
  | 5    | [SINTER key1 [key2\]](https://www.runoob.com/redis/sets-sinter.html) 返回给定所有集合的交集 |
  | 6    | [SINTERSTORE destination key1 [key2\]](https://www.runoob.com/redis/sets-sinterstore.html) 返回给定所有集合的交集并存储在 destination 中 |
  | 7    | [SISMEMBER key member](https://www.runoob.com/redis/sets-sismember.html) 判断 member 元素是否是集合 key 的成员 |
  | 8    | [SMEMBERS key](https://www.runoob.com/redis/sets-smembers.html) 返回集合中的所有成员 |
  | 9    | [SMOVE source destination member](https://www.runoob.com/redis/sets-smove.html) 将 member 元素从 source 集合移动到 destination 集合 |
  | 10   | [SPOP key](https://www.runoob.com/redis/sets-spop.html) 移除并返回集合中的一个随机元素 |
  | 11   | [SRANDMEMBER key [count\]](https://www.runoob.com/redis/sets-srandmember.html) 返回集合中一个或多个随机数 |
  | 12   | [SREM key member1 [member2\]](https://www.runoob.com/redis/sets-srem.html) 移除集合中一个或多个成员 |
  | 13   | [SUNION key1 [key2\]](https://www.runoob.com/redis/sets-sunion.html) 返回所有给定集合的并集 |
  | 14   | [SUNIONSTORE destination key1 [key2\]](https://www.runoob.com/redis/sets-sunionstore.html) 所有给定集合的并集存储在 destination 集合中 |
  | 15   | [SSCAN key cursor [MATCH pattern\] [COUNT count]](https://www.runoob.com/redis/sets-sscan.html) 迭代集合中的元素 |



集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。



## zset(sorted set：有序集合)

Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。

不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。

zset的成员是唯一的,但分数(score)却可以重复。

### 常用命令

- 

- | 序号 | 命令及描述                                                   |
  | :--- | :----------------------------------------------------------- |
  | 1    | [ZADD key score1 member1 [score2 member2\]](https://www.runoob.com/redis/sorted-sets-zadd.html) 向有序集合添加一个或多个成员，或者更新已存在成员的分数 |
  | 2    | [ZCARD key](https://www.runoob.com/redis/sorted-sets-zcard.html) 获取有序集合的成员数 |
  | 3    | [ZCOUNT key min max](https://www.runoob.com/redis/sorted-sets-zcount.html) 计算在有序集合中指定区间分数的成员数 |
  | 4    | [ZINCRBY key increment member](https://www.runoob.com/redis/sorted-sets-zincrby.html) 有序集合中对指定成员的分数加上增量 increment |
  | 5    | [ZINTERSTORE destination numkeys key [key ...\]](https://www.runoob.com/redis/sorted-sets-zinterstore.html) 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中 |
  | 6    | [ZLEXCOUNT key min max](https://www.runoob.com/redis/sorted-sets-zlexcount.html) 在有序集合中计算指定字典区间内成员数量 |
  | 7    | [ZRANGE key start stop [WITHSCORES\]](https://www.runoob.com/redis/sorted-sets-zrange.html) 通过索引区间返回有序集合指定区间内的成员 |
  | 8    | [ZRANGEBYLEX key min max [LIMIT offset count\]](https://www.runoob.com/redis/sorted-sets-zrangebylex.html) 通过字典区间返回有序集合的成员 |
  | 9    | [ZRANGEBYSCORE key min max [WITHSCORES\] [LIMIT]](https://www.runoob.com/redis/sorted-sets-zrangebyscore.html) 通过分数返回有序集合指定区间内的成员 |
  | 10   | [ZRANK key member](https://www.runoob.com/redis/sorted-sets-zrank.html) 返回有序集合中指定成员的索引 |
  | 11   | [ZREM key member [member ...\]](https://www.runoob.com/redis/sorted-sets-zrem.html) 移除有序集合中的一个或多个成员 |
  | 12   | [ZREMRANGEBYLEX key min max](https://www.runoob.com/redis/sorted-sets-zremrangebylex.html) 移除有序集合中给定的字典区间的所有成员 |
  | 13   | [ZREMRANGEBYRANK key start stop](https://www.runoob.com/redis/sorted-sets-zremrangebyrank.html) 移除有序集合中给定的排名区间的所有成员 |
  | 14   | [ZREMRANGEBYSCORE key min max](https://www.runoob.com/redis/sorted-sets-zremrangebyscore.html) 移除有序集合中给定的分数区间的所有成员 |
  | 15   | [ZREVRANGE key start stop [WITHSCORES\]](https://www.runoob.com/redis/sorted-sets-zrevrange.html) 返回有序集中指定区间内的成员，通过索引，分数从高到低 |
  | 16   | [ZREVRANGEBYSCORE key max min [WITHSCORES\]](https://www.runoob.com/redis/sorted-sets-zrevrangebyscore.html) 返回有序集中指定分数区间内的成员，分数从高到低排序 |
  | 17   | [ZREVRANK key member](https://www.runoob.com/redis/sorted-sets-zrevrank.html) 返回有序集合中指定成员的索引，有序集成员按分数值递减(从大到小)排序 |
  | 18   | [ZSCORE key member](https://www.runoob.com/redis/sorted-sets-zscore.html) 返回有序集中，成员的分数值 |
  | 19   | [ZUNIONSTORE destination numkeys key [key ...\]](https://www.runoob.com/redis/sorted-sets-zunionstore.html) 计算给定的一个或多个有序集的并集，并存储在新的 key 中 |
  | 20   | [ZSCAN key cursor [MATCH pattern\] [COUNT count]](https://www.runoob.com/redis/sorted-sets-zscan.html) 迭代有序集合中的元素（包括元素成员和元素分值） |

# 4.对key的操作

## 操作总结

| 1    | [DEL key](https://www.runoob.com/redis/keys-del.html) 该命令用于在 key 存在时删除 key。 |
| ---- | ------------------------------------------------------------ |
| 2    | [DUMP key](https://www.runoob.com/redis/keys-dump.html) 序列化给定 key ，并返回被序列化的值。 |
| 3    | [EXISTS key](https://www.runoob.com/redis/keys-exists.html) 检查给定 key 是否存在。 |
| 4    | [EXPIRE key](https://www.runoob.com/redis/keys-expire.html) seconds 为给定 key 设置过期时间，以秒计。 |
| 5    | [EXPIREAT key timestamp](https://www.runoob.com/redis/keys-expireat.html) EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。 |
| 6    | [PEXPIRE key milliseconds](https://www.runoob.com/redis/keys-pexpire.html) 设置 key 的过期时间以毫秒计。 |
| 7    | [PEXPIREAT key milliseconds-timestamp](https://www.runoob.com/redis/keys-pexpireat.html) 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计 |
| 8    | [KEYS pattern](https://www.runoob.com/redis/keys-keys.html) 查找所有符合给定模式( pattern)的 key 。 |
| 9    | [MOVE key db](https://www.runoob.com/redis/keys-move.html) 将当前数据库的 key 移动到给定的数据库 db 当中。 |
| 10   | [PERSIST key](https://www.runoob.com/redis/keys-persist.html) 移除 key 的过期时间，key 将持久保持。 |
| 11   | [PTTL key](https://www.runoob.com/redis/keys-pttl.html) 以毫秒为单位返回 key 的剩余的过期时间。 |
| 12   | [TTL key](https://www.runoob.com/redis/keys-ttl.html) 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。 |
| 13   | [RANDOMKEY](https://www.runoob.com/redis/keys-randomkey.html) 从当前数据库中随机返回一个 key 。 |
| 14   | [RENAME key newkey](https://www.runoob.com/redis/keys-rename.html) 修改 key 的名称 |
| 15   | [RENAMENX key newkey](https://www.runoob.com/redis/keys-renamenx.html) 仅当 newkey 不存在时，将 key 改名为 newkey 。 |
| 16   | [SCAN cursor [MATCH pattern\] [COUNT count]](https://www.runoob.com/redis/keys-scan.html) 迭代数据库中的数据库键。 |
| 17   | [TYPE key](https://www.runoob.com/redis/keys-type.html) 返回 key 所储存的值的类型。 |

## 容易有疑问的点：

### 1.序列化是什么，作用是什么？

#### 一、「序列化」= 把内存里的数据变成可以保存/传输的格式

Redis 内部存储的 `kira` 是一个 **Hash 对象**，在内存中，它的结构大致像这样：

```
{
  name: "sheldon",
  age: 25,
  job: "coder"
}
```

这在 Redis 的内部其实是**一堆指针、字符串对象、整数对象、内存块**。
 它依赖 Redis 的内部数据结构（比如 dict、sds、robj 等）。

问题来了 👇

> 如果我想把这个对象：
>
> - 保存到硬盘上；
> - 发送到另一台 Redis；
> - 或者持久化备份；
>
> 那我不能直接把内存的内容拷贝过去，因为那只是 Redis 进程的内部结构，
>  离开这台机器就完全没法解析了。

所以，我们就需要——

> **把内存中的对象，转换成一个可以保存/传输的标准格式。**

这个过程就叫：
 👉 **序列化（Serialization）**

反过来，把序列化结果还原成原来的对象，就是：
 👉 **反序列化（Deserialization）**

------

#### 二、对应到你 Redis 的例子

你执行的命令：

```
127.0.0.1:6379> dump kira
```

Redis 做的事情是：

| 阶段 | 动作                    | 说明                                             |
| ---- | ----------------------- | ------------------------------------------------ |
| ①    | 读取 `kira` 的哈希对象  | Redis 内存里是一张 dict 表                       |
| ②    | 按 RDB 规则编码成字节流 | 比如：字段数量、类型、长度、字符串内容、结束符号 |
| ③    | 添加 CRC 校验码         | 防止数据在网络或磁盘中损坏                       |
| ④    | 返回一串“乱码”给你      | 实际是序列化后的二进制内容                       |

这串乱码：

```
"\r..\x00\x00\x00&\x00\x00\x00\x06\x00\x00\x04name..."
```

其实就是 Redis 把「Hash 对象」序列化成「Redis 内部可恢复的字节流」。

然后，只要你在另一台 Redis 上执行：

```
127.0.0.1:6380> restore kira 0 "<刚才那串数据>"
```

Redis 会反序列化这串字节流，重新还原出那个哈希对象：

```
127.0.0.1:6380> hgetall kira
1) "name"
2) "sheldon"
3) "age"
4) "25"
5) "job"
6) "coder"
```

这就实现了对象的 **跨机器迁移**、**备份恢复**。

### 2.UNIX时间戳？

#### 一、UNIX时间戳是什么

**UNIX 时间戳（UNIX Timestamp）** 是一种用「整数」表示时间的方式，它表示自 **1970 年 1 月 1 日 00:00:00（UTC）** 起，到当前时刻为止所经过的 **总秒数**。

例如：

| 时间（UTC）         | UNIX 时间戳          |
| ------------------- | -------------------- |
| 1970-01-01 00:00:00 | 0                    |
| 1970-01-01 00:00:01 | 1                    |
| 1970-01-02 00:00:00 | 86400 （一天的秒数） |
| 2025-10-20 10:00:00 | 约 1,763,811,200     |

#### 二、为什么时间要用“时间戳”来表示？

在计算机内部，时间必须是一个**连续、可计算、可比较的数值**。
 如果你直接存 `"2025-10-20 10:00:00"` 这种字符串：

- 比较时间先后很麻烦（要解析、拆分、转换）
- 计算两个时间的差也不方便

而使用整数时间戳后，一切就变得非常简单：

```
time_t now = time(NULL);
```

得到一个整数，比如：

```
1763811200
```

然后：

- `now - 86400` 就是 **昨天同一时刻**
- 比较 `if (t1 > t2)` 就能判断谁更晚
- 存储、传输都高效，占空间小

所以，时间戳是 **计算机内部时间的“通用语言”**。

------

#### 三、为什么是“1970 年 1 月 1 日”？

这是因为 UNIX 操作系统诞生于 1969 年，
 其设计者在 1970 年初正式确定了这个“时间零点”。

也就是说，UNIX 系统中所有的时间都以此为基准。
 这一天在技术上叫：

> **UNIX Epoch（UNIX 纪元）**

------

#### 四、单位与类型

| 单位           | 含义                        | 举例             |
| -------------- | --------------------------- | ---------------- |
| **秒（s）**    | 传统 UNIX 时间戳（最常见）  | 1763811200       |
| **毫秒（ms）** | 比如 JavaScript、Redis 常用 | 1763811200123    |
| **微秒（μs）** | 更高精度（数据库中常见）    | 1763811200123456 |

不同语言/系统使用不同精度：

| 环境       | 时间戳单位                   | 示例          |
| ---------- | ---------------------------- | ------------- |
| C / Linux  | 秒                           | `time_t`      |
| JavaScript | 毫秒                         | `Date.now()`  |
| Redis      | 毫秒（`PEXPIRE`、`PTTL` 等） |               |
| Python     | 秒（默认）                   | `time.time()` |
| MySQL      | 秒（UNIX_TIMESTAMP函数）     |               |

------

#### 五、与本地时间的关系

UNIX 时间戳是以 **UTC 时间** 为标准计算的。
 要显示为“本地时间”，系统会根据当前时区进行换算。

例如（假设你在北京时间 UTC+8 区）：

| UNIX 时间戳 | UTC 时间            | 本地时间（北京）    |
| ----------- | ------------------- | ------------------- |
| 1763811200  | 2025-10-20 02:00:00 | 2025-10-20 10:00:00 |

计算公式：

```
本地时间 = UTC 时间 + 时区偏移量
```

------

六、Redis 与 UNIX 时间戳

Redis 常用 UNIX 时间戳来表示时间或过期：

| 命令                                   | 用法                                     |
| -------------------------------------- | ---------------------------------------- |
| `EXPIRE key seconds`                   | 设置在多少秒后过期（内部会转换成时间戳） |
| `PEXPIREAT key milliseconds-timestamp` | 直接指定时间戳（毫秒）                   |
| `TIME`                                 | 返回当前 UNIX 时间戳（秒 和 微秒）       |

例如：

```
127.0.0.1:6379> TIME
1) "1763811200"
2) "123456"
```

表示当前时间是：

```
1763811200 秒 + 123456 微秒
```

### 3、pattern是什么

#### 一、原句回顾

> ```
> [KEYS pattern] 查找所有符合给定模式 (pattern) 的 key。
> ```

这句话出自 Redis 命令说明：

```
KEYS pattern
```

意思是：

> **在当前 Redis 数据库中，查找所有「key 的名字」符合你指定模式的键。**

------

#### 二、我们先明确几个概念：

##### 1️⃣ Redis 的 key 是什么？

在 Redis 中，所有数据都是「键值对」结构：

```
key         value
--------    -------------------
user:1      {"name": "Alice"}
user:2      {"name": "Bob"}
order:1001  {"price": 88}
order:1002  {"price": 99}
```

`key` 就像是数据库里的“表名 + 主键”的结合体，用来标识一条数据。

------

##### 2️⃣ KEYS 命令是干什么的？

`KEYS` 命令让你查找数据库里所有「key 名字」符合某种“模式”的 key。

语法：

```
KEYS pattern
```

例如：

```
KEYS user:*
```

就会列出所有以 `user:` 开头的 key，比如：

```
1) "user:1"
2) "user:2"
```

------

#### 三、那“pattern（模式）”是什么意思？

这里的「模式」其实指的是一种 **通配符匹配规则**，
 跟 Linux 命令行里的 `ls *.txt` 或 SQL 里的 `LIKE` 有点类似。

Redis 支持的通配符如下：

| 通配符 | 含义                           | 示例        | 匹配结果                          |
| ------ | ------------------------------ | ----------- | --------------------------------- |
| `*`    | 匹配任意多个字符（包括空字符） | `user:*`    | `user:1`, `user:abc`, `user:1001` |
| `?`    | 匹配任意单个字符               | `user:?`    | `user:a`, `user:1`                |
| `[]`   | 匹配括号内任意一个字符         | `user:[12]` | `user:1`, `user:2`                |
| `\`    | 转义符（让特殊字符失效）       | `user:\*`   | 匹配名为 `user:*` 的键            |

------

#### 四、例子讲解

假设你的 Redis 里有这些键：

```
user:1
user:2
user:admin
order:202501
order:202502
session:abc123
```

| 命令               | 结果                             |
| ------------------ | -------------------------------- |
| `KEYS *`           | 查找所有键（相当于“全选”）       |
| `KEYS user:*`      | `user:1`, `user:2`, `user:admin` |
| `KEYS order:2025*` | `order:202501`, `order:202502`   |
| `KEYS *admin`      | `user:admin`                     |
| `KEYS *:a*`        | `user:admin`, `session:abc123`   |

------

#### 五、警告 ⚠️：不要在生产环境中使用 KEYS！

虽然 `KEYS pattern` 很方便，但它有个**致命缺点**：

> 它会遍历整个 Redis 数据库中的所有 key！

如果你的 Redis 有几百万个键，执行 `KEYS *` 会：

- 阻塞 Redis 线程；
- 导致服务器短时间无法响应其他请求；
- 造成线上服务卡顿。

所以在生产环境一般不用 `KEYS`，而是用更安全的：

```
SCAN pattern
```

它支持「渐进式扫描」（不会一次性遍历全部）。