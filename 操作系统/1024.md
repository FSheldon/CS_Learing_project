# 1.分页，分段都是什么，段页式又是什么？

## 一、概念讲解

在操作系统的内存管理中，**分段**和**分页**都是用来解决“如何高效地分配和管理内存”的两种基本策略。

- **分页（Paging）**：
   把内存空间**划分为固定大小的块**（称为“页”），每个进程的逻辑地址空间也被划分为同样大小的页。分页的核心是**消除外部碎片**，实现内存的离散分配。
- **分段（Segmentation）**：
   按照**程序的逻辑结构**（如代码段、数据段、栈段等）来划分地址空间。每个段的大小**不固定**，反映了程序的逻辑模块结构。分段的核心是**支持逻辑上的独立性与保护性**。
- **段页式（Segmented Paging）**：
   是将两者**结合**起来的一种方式：
   先将程序按逻辑划分为若干“段”，再将每个段**分页**。
   它兼顾了分段的逻辑性和分页的高效内存利用。

------

## 二、原理分析

| 特性     | 分页 (Paging)              | 分段 (Segmentation)        | 段页式 (Segmented Paging) |
| -------- | -------------------------- | -------------------------- | ------------------------- |
| 划分依据 | 固定大小的页               | 程序的逻辑结构             | 先按段，再分页            |
| 大小     | 固定                       | 可变                       | 段内页固定                |
| 地址组成 | 页号 + 页内偏移            | 段号 + 段内偏移            | 段号 + 页号 + 页内偏移    |
| 优点     | 消除外部碎片、易于内存分配 | 反映程序逻辑结构、便于保护 | 结合两者优点              |
| 缺点     | 不反映程序逻辑结构         | 产生外部碎片               | 地址转换更复杂            |

------

## 三、示例说明

### 🎯 举个生活例子来理解

- **分页**就像：

  > 把一本书强行每 10 页装订成一本小册子（页固定大小）。
  >  无论章节逻辑，10 页就是一册。

- **分段**就像：

  > 一本书按“章节”划分：序章、正文、附录等。
  >  每一章长度不同，但逻辑上完整。

- **段页式**就像：

  > 先按“章节”划分（分段），然后每一章太长时再分成若干固定页（分页）。
  >  这样既有逻辑层次，又方便打印和装订。

------

### 💻 举个地址转换的例子

假设虚拟地址为：

> 段号 = 2，页号 = 3，页内偏移 = 50

转换步骤：

1. 先查 **段表**：找到第 2 段的起始物理地址。
2. 进入该段对应的 **页表**：查找页号 3 对应的物理页框号。
3. 物理地址 = 页框起始地址 + 偏移量（50）。

------

## 四、系统关联

在现代操作系统（如 Linux、Windows）中：

- 实际内存管理**主要基于分页**（因为硬件支持页表，效率高）。
- “分段”机制更多用于**逻辑结构和保护**（例如代码段、数据段的访问权限）。
- Intel 的 x86 架构采用了**段页式结构**，但在 64 位模式下，**分段功能基本被弃用**，只保留分页。

------

## 五、教师小结

| 对比点    | 分页           | 分段         | 段页式      |
| --------- | -------------- | ------------ | ----------- |
| 管理单位  | 页             | 段           | 段中的页    |
| 页/段大小 | 固定           | 可变         | 段内页固定  |
| 地址映射  | 页表           | 段表         | 段表 + 页表 |
| 优点      | 高效利用内存   | 支持逻辑结构 | 综合优势    |
| 缺点      | 不支持逻辑划分 | 外部碎片     | 转换复杂    |

📘 **总结要点：**

- **分页关注“空间利用”**，追求内存分配效率；
- **分段关注“程序结构”**，追求逻辑清晰与保护；
- **段页式结合两者**，在一些硬件架构中使用，但现代系统多以分页为主。



# 2.磁盘的结构，几种磁盘调度算法

## 磁盘结构

- 盘面（Platter）：一个磁盘有多个盘面；
- 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；
- 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；
- 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；
- 制动手臂（Actuator arm）：用于在磁道之间移动磁头；
- 主轴（Spindle）：使整个盘面转动。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/014fbc4d-d873-4a12-b160-867ddaed9807.jpg)

## 1️⃣ 磁盘的基本结构（Disk Structure）

磁盘是操作系统中**最重要的外存储设备**，用于持久化保存数据。它由若干**盘片（Platters）**组成，每个盘片上有两面，都可以存储数据。

🧭 **基本组成要素：**

- **盘片（Platter）**：涂有磁性材料的圆盘。
- **磁道（Track）**：每个盘面上由同心圆构成的数据环。
- **扇区（Sector）**：磁道上最小的物理存储单位（通常 512B 或 4KB）。
- **柱面（Cylinder）**：所有盘片上相同半径的磁道集合（因为读写头同时移动）。

🧩 **硬件部件：**

- **磁头（Head）**：负责读写数据。
- **主轴（Spindle）**：驱动盘片旋转。
- **磁臂（Arm）**：带动磁头沿半径方向移动。
- **控制器（Controller）**：负责命令解释与数据传输。

📍**访问一个磁盘块的时间 = 寻道时间 + 旋转延迟 + 传输时间**

------

## 二、原理分析：磁盘访问过程

当系统要访问某个扇区时：

1. **寻道时间（Seek Time）**
    → 移动磁臂，使磁头定位到目标柱面上。
    （机械结构移动最慢，是磁盘访问的主要瓶颈。）
2. **旋转延迟（Rotational Latency）**
    → 磁盘旋转，让目标扇区旋转到磁头下方。
3. **数据传输时间（Transfer Time）**
    → 数据经过控制器传送到内存或CPU。

💡因此，为了提高效率，我们希望**减少磁臂的移动距离**——这正是磁盘调度算法要解决的核心问题。

## 三、示例说明：常见的磁盘调度算法

设想磁头当前在 **53 号磁道**，接到的 I/O 请求序列为： **[98, 183, 37, 122, 14, 124, 65, 67]**

------

### 1️⃣ FCFS（First Come First Serve，先来先服务）

**原理：**
 按请求到达顺序依次处理，不考虑磁头位置。

**优点：** 公平、简单。
 **缺点：** 磁头移动距离大，效率低。

**示例：**

> 移动顺序：53 → 98 → 183 → 37 → 122 → 14 → 124 → 65 → 67
>  总移动距离大、耗时多。

------

### 2️⃣ SSTF（Shortest Seek Time First，最短寻道时间优先）

**原理：**
 每次选择距离当前磁头最近的请求。

**优点：** 总移动距离较小，效率高。
 **缺点：** 容易导致**饥饿**（远处请求长时间得不到响应）。

**示例：**

> 当前在 53，最近的是 65（距离 12），然后 67、37、14、98...
>  距离大幅减少，但有些请求会被长期延迟。

------

### 3️⃣ SCAN（电梯算法）

**原理：**
 磁头像电梯一样在磁道上来回移动：

- 从一端向另一端移动时依次处理经过的请求；
- 到达尽头后方向反转。

**优点：** 均衡了等待时间，避免饥饿。
 **缺点：** 两端响应速度略慢。

**示例：**

> 若磁头从小号到大号方向移动：
>  53 → 65 → 67 → 98 → 122 → 124 → 183 → (反转) → 37 → 14

------

### 4️⃣ C-SCAN（Circular SCAN，循环电梯算法）

**原理：**
 磁头只在一个方向移动（如从小到大），到达末尾后**快速返回起点**（不服务途中请求），再继续扫描。

**优点：** 所有请求等待时间更平均，适合高负载系统。
 **缺点：** 返回过程不服务，略有浪费。

------

### 5️⃣ LOOK 与 C-LOOK

SCAN 与 C-SCAN 的改进版本：
 不必移动到磁盘最末端，而是在**最远请求处掉头**。

- **LOOK**：双向来回但只到最远请求处。
- **C-LOOK**：单向循环但只扫描到最远请求处。

------

## 四、系统关联

在现代操作系统中：

- 磁盘调度算法是 **I/O 调度器** 的核心部分；
- 不同系统可选择不同策略（如 Linux 的 I/O 调度器有 CFQ、Deadline、NOOP 等）；
- **SSD（固态硬盘）** 出现后，寻道时间几乎为零，因此现代系统对磁盘调度的依赖大幅降低，但传统算法仍是理解存储层优化的重要基础。

------

## 五、小结

| 算法          | 策略            | 优点         | 缺点     | 是否可能饥饿 |
| ------------- | --------------- | ------------ | -------- | ------------ |
| FCFS          | 按到达顺序      | 公平简单     | 效率低   | 否           |
| SSTF          | 最近请求优先    | 移动距离短   | 可能饥饿 | 是           |
| SCAN          | 电梯式来回      | 均衡等待     | 两端慢   | 否           |
| C-SCAN        | 单向循环        | 平均等待     | 返回浪费 | 否           |
| LOOK / C-LOOK | 优化SCAN/C-SCAN | 减少无用移动 | 实现复杂 | 否           |

📘 **总结要点：**

- 所有磁盘调度算法都围绕一个目标：**减少平均寻道时间**。
- **SSTF → SCAN → C-SCAN** 是一个从高效到公平的演进过程。
- 现代系统中仍然在概念层保留这些思想，用于优化磁盘与I/O性能。



# 3.进程同步和进程通信有什么区别？同步的方法，通信的方法

## 一、概念讲解

在操作系统中，当系统同时运行多个进程时，它们往往需要**协同工作**。
 要让这些进程既能**有序执行**，又能**正确交换信息**，操作系统就必须提供两类机制：

| 类别                            | 作用                         | 比喻                             |
| ------------------------------- | ---------------------------- | -------------------------------- |
| **进程同步（Synchronization）** | 解决进程间**执行顺序**的问题 | 「大家排队取餐，不冲突」         |
| **进程通信（Communication）**   | 解决进程间**数据传递**的问题 | 「排完队后，告诉对方取到哪种餐」 |

二者密切相关但关注点不同：

- **同步**强调「协调动作」；
- **通信**强调「信息交换」。

------

## 二、原理分析

### 1️⃣ 进程间同步（Process Synchronization）

**目标：**
 保证多个进程在共享资源（如文件、变量、缓冲区）时，不会出现数据冲突或执行混乱。

🧠 **常见同步方式：**

| 同步机制                           | 原理简述                   | 特点               |
| ---------------------------------- | -------------------------- | ------------------ |
| **互斥锁（Mutex）**                | 一次只能一个进程访问临界区 | 最基本的同步工具   |
| **信号量（Semaphore）**            | 用计数器控制资源访问数量   | 可实现互斥或同步   |
| **条件变量（Condition Variable）** | 等待特定条件成立再执行     | 多用于线程间       |
| **管程（Monitor）**                | 封装共享资源与操作接口     | 面向对象系统中常见 |

🧩 **例子（信号量机制）**

假设打印机是共享资源：

```
P(mutex)      ← 请求打印机
打印操作
V(mutex)      ← 释放打印机
```

其中 `P` 表示进入临界区的请求（wait），`V` 表示释放（signal）。

📍 **关键点：**
 同步保证了“操作顺序正确”，但不传递数据内容。

------

### 2️⃣ 进程间通信（Inter-Process Communication, IPC）

**目标：**
 让不同进程能够**交换数据或消息**，实现协作。

🧠 **常见通信方式：**

| 通信方式                      | 特点                             | 示例                         |
| ----------------------------- | -------------------------------- | ---------------------------- |
| **管道（Pipe）**              | 单向、字节流形式，常用于父子进程 | `ps aux                      |
| **命名管道（FIFO）**          | 可在非亲缘进程间通信             | Linux: `/tmp/myfifo`         |
| **消息队列（Message Queue）** | 按消息单元传输                   | 系统调用：`msgsnd`, `msgrcv` |
| **共享内存（Shared Memory）** | 多个进程映射同一内存区，最快     | 常配合信号量使用             |
| **信号（Signal）**            | 一种轻量级通知机制               | 如 `SIGKILL`, `SIGINT`       |
| **套接字（Socket）**          | 支持不同主机间通信               | 网络通信基础                 |

📍 **关键点：**
 通信是“传递信息”的行为，可以是数据、指令或事件。

------

## 三、示例说明

🎯 **类比理解：**

| 场景                      | 同步                         | 通信                             |
| ------------------------- | ---------------------------- | -------------------------------- |
| 两个人共用打印机          | 不能同时打印（互斥）         | 打印完成后告诉对方「我打印好了」 |
| 两个线程合作生产/消费数据 | 消费者等待生产者生产（同步） | 生产者把数据放入缓冲区（通信）   |

💻 **示例代码：共享内存 + 信号量**

假设两个进程需要共享一个整数：

```
// 共享内存 + 信号量伪代码
wait(mutex);
shared_data = 10;      // 通信：写数据
signal(mutex);
```

这里：

- 信号量用于**同步访问顺序**；
- 共享内存用于**传递实际数据**。

------

## 四、系统关联

- 在 **操作系统内核层面**，同步和通信往往配合使用。
   比如：共享内存通信中，一定需要同步机制来防止数据竞争。
- 在 **多线程编程（如POSIX线程）** 中，同步工具（锁、信号量、条件变量）更常见。
- 在 **分布式系统** 中，通信机制更复杂（如 RPC、Socket），同步可通过时钟或分布式锁实现。

------

## 五、小结

| 对比点       | 进程同步                   | 进程通信                 |
| ------------ | -------------------------- | ------------------------ |
| 目的         | 保证执行顺序正确，避免冲突 | 传递数据，实现协作       |
| 关注点       | “什么时候执行”             | “传什么内容”             |
| 典型工具     | 信号量、互斥锁、管程       | 管道、消息队列、共享内存 |
| 是否传递数据 | ❌ 否                       | ✅ 是                     |
| 是否可跨主机 | 否（一般在同一机器）       | 可（通过 Socket）        |

📘 **总结要点：**

- **同步是控制节奏，通信是交换信息。**
- 实际系统中两者往往一起出现，比如共享内存通信必须配合同步机制。
- 理解这一区别，是学习操作系统中「进程协作」的关键基础。

# 4.虚拟地址寻址过程，页，页面大小，页表，页表项，页表项长度，页表长度。为什么要分页，而不是直接对物理地址编码

## 📘 一、概念讲解：什么是虚拟地址寻址？

现代操作系统（如 Linux、Windows）使用**虚拟地址（Virtual Address）**而不是直接使用物理地址。

> 每个进程都认为自己独占整个内存空间。

但实际上，CPU访问内存时，必须先经过一个“地址转换”过程：
 **虚拟地址 → 物理地址**

这个转换由**硬件（MMU, Memory Management Unit）\**和\**操作系统的页表机制**共同完成。

------

## 🧩 二、原理分析：虚拟地址寻址过程

我们来具体看看 CPU 如何把虚拟地址变成物理地址。

假设虚拟地址长度为 32 位（即 4 GB 地址空间）。

操作系统采用 **分页（Paging）** 机制。

### 1️⃣  分页的思想

把整个虚拟地址空间 **按固定大小的块划分**：

- 每一块叫 **页（Page）**
- 每一页对应物理内存中的一块 **页框（Frame）**

比如：

- 页面大小 = 4 KB（常见值）
- 那么：
   4 GB 虚拟空间 = 4 GB / 4 KB = **1,048,576 页**

------

### 2️⃣  虚拟地址的结构

虚拟地址通常被分为两部分：

| 部分 | 名称               | 作用                       |
| ---- | ------------------ | -------------------------- |
| 高位 | 页号 (Page Number) | 指示该地址属于哪一页       |
| 低位 | 页内偏移 (Offset)  | 表示该地址在该页内的偏移量 |

例如：
 页面大小 = 4 KB = 2¹² 字节
 → 页内偏移需要 12 位
 → 若虚拟地址为 32 位，则页号占 20 位

```
虚拟地址结构：
| 页号 (20位) | 页内偏移 (12位) |
```

------

### 3️⃣  页表与页表项（PTE）

操作系统为每个进程维护一个 **页表（Page Table）**。

页表是一个映射表：

> 负责记录每个“虚拟页号”对应的“物理页框号”。

每个**页表项（PTE, Page Table Entry）**包含的信息：

| 字段               | 含义                 |
| ------------------ | -------------------- |
| 物理页框号         | 页在物理内存中的位置 |
| 有效位 (Valid bit) | 是否已装入内存       |
| 读写权限 (R/W)     | 是否可写             |
| 修改位 (Dirty)     | 是否被修改过         |
| 访问位 (Accessed)  | 是否被访问过         |
| 缓存控制           | 是否允许缓存         |

------

### 4️⃣  地址转换的过程（单级页表）

**过程举例：**

1. CPU 发出虚拟地址 VA
2. MMU 取出其中的 **页号**
3. 在**页表**中查找该页号对应的**页表项**
4. 得到 **物理页框号**
5. 将物理页框号 + 页内偏移 组合成物理地址 PA

```
PA = [页表[页号].物理页框号] + [页内偏移]
```

------

### 5️⃣  页表长度与页表项长度

假设：

- 虚拟地址 32 位 → 共 2²⁰ 页
- 每个页表项（PTE）4 字节
   → 页表大小 = 2²⁰ × 4 B = **4 MB**

这只是单个进程的页表大小。
 如果系统中有很多进程，这将非常浪费内存。

------

### 6️⃣  二级页表（多级页表）

为减少页表占用的空间，引入 **多级页表（Hierarchical Page Table）**。

例如：
 二级页表将 20 位页号再拆成：

- 一级页目录号 (10 位)
- 二级页号 (10 位)

每一级页表只在被访问时才创建 → 节省内存。

------

## 🧠 三、示例说明

假设：

- 页面大小：4 KB
- 虚拟地址：`0x1234ABCD`

拆分：

```
页号 = 0x1234A
页内偏移 = 0xBCD
```

查页表得到：

```
页号 0x1234A 对应物理页框号 0x02F5
```

组合物理地址：

```
物理地址 = 0x02F5000 + 0xBCD = 0x02F5BCD
```

------

## 🔗 四、系统关联：分页与虚拟内存的关系

分页是**虚拟内存实现的基础机制**。
 它使得：

- 进程拥有独立地址空间（安全性）
- 支持部分装入与页面置换（效率）
- 操作系统能更灵活地管理内存（抽象层）



# 5.分页，分块，分段，段页式，多级页表，快表

## 🧩 一、概念讲解：内存管理的演化脉络

| 阶段       | 技术                           | 核心思想                             | 目标             |
| ---------- | ------------------------------ | ------------------------------------ | ---------------- |
| 1️⃣ 最早期   | **分块（固定分区）**           | 将物理内存固定分成若干块             | 简单分配         |
| 2️⃣ 过渡期   | **分段（Segmentation）**       | 按逻辑结构（代码段/数据段/栈段）划分 | 支持程序逻辑结构 |
| 3️⃣ 主流机制 | **分页（Paging）**             | 按固定大小页划分                     | 提高内存利用率   |
| 4️⃣ 综合方案 | **段页式（Segmented Paging）** | 逻辑分段 + 物理分页                  | 兼顾逻辑性与效率 |
| 5️⃣ 性能优化 | **快表（TLB）**                | 缓存页表项                           | 加速地址转换     |
| 6️⃣ 扩展优化 | **多级页表**                   | 分级存储页表                         | 节省内存空间     |



## 🧱 二、分块（Fixed Partition / 分区管理）

### 📘 概念讲解

最早期的内存管理方式：

- 操作系统把物理内存划分为**固定大小的几个块（区）**。
- 每个进程装入一个块。

### 🧩 原理分析

假设内存 1GB，划成 4 个区（每区 256MB），每个进程只能放进一个区。

### ❌ 缺点

- 内部碎片：程序没用满分区也浪费。
- 外部碎片：无法动态伸缩。
- 多任务效率极低。

------

## 🧭 三、分段（Segmentation）

### 📘 概念讲解

按**程序逻辑结构**划分内存，如：

- 代码段（text）
- 数据段（data）
- 栈段（stack）

每个段大小不等，由程序逻辑决定。

### 🧩 原理分析

- 每个段有**段基址**（起始地址）+ **段限长**（长度）

- 地址结构：

  ```
  虚拟地址 = [段号 | 段内偏移]
  物理地址 = 段基址 + 段内偏移
  ```

### 💡 示例说明

假设：

```
段0：代码段，基址1000，长度400
段1：数据段，基址2000，长度300
```

访问逻辑地址 (段1, 50) → 物理地址 = 2000 + 50 = 2050。

### ✅ 优点

- 更贴近程序逻辑结构。
- 支持代码共享、保护（不同段权限不同）。

### ❌ 缺点

- 段大小不固定 → 容易产生外部碎片。
- 段分配与回收复杂。

------

## 📄 四、分页（Paging）

### 📘 概念讲解

分页是一种**物理内存抽象机制**。
 它把虚拟内存和物理内存都划分为**等大小的页（Page）和页框（Frame）**。

| 名称               | 说明                               |
| ------------------ | ---------------------------------- |
| 页（Page）         | 逻辑上的固定单位（虚拟内存的一页） |
| 页框（Frame）      | 物理内存的一页                     |
| 页表（Page Table） | 记录“页号 → 页框号”的映射关系      |

------

### 🧩 原理分析

- 虚拟地址被拆成两部分：

  ```
  虚拟地址 = [页号 | 页内偏移]
  ```

- 通过页表查到该页对应的物理页框号。

  ```
  物理地址 = [页框号 | 页内偏移]
  ```

### 📘 示例

页大小 = 4KB（12位偏移）

| 虚拟页号 | 物理页框号 |
| -------- | ---------- |
| 0        | 3          |
| 1        | 5          |
| 2        | 8          |

访问虚拟地址 0x1234
 → 页号 = 1，页内偏移 = 0x234
 → 页框号 = 5
 → 物理地址 = (5 × 4KB) + 0x234

### ✅ 优点

- 不会产生外部碎片。
- 物理内存利用率高。
- 支持虚拟内存（部分页在磁盘）。

### ❌ 缺点

- 逻辑上程序结构被打散。
- 需要查页表，速度较慢。

------

## 🧮 五、段页式（Segmented Paging）

### 📘 概念讲解

综合“分段”和“分页”的优点：

- 程序按逻辑结构分段；
- 每个段内部再分页。

### 🧩 原理分析

地址结构：

```
虚拟地址 = [段号 | 页号 | 页内偏移]
```

访问流程：

1. 查段表，找到该段的页表基址。
2. 查页表，找到对应的物理页框。
3. 拼接页内偏移得到物理地址。

### 📘 优势

- 逻辑清晰（段）
- 内存利用率高（页）
- 每段可独立分配/保护

### 💡 示例说明

```
段表：
段0 → 页表地址 A
段1 → 页表地址 B
```

访问(段1, 页2, 偏移300)
 → 找段1页表B → 查页号2映射 → 拼偏移300。

------

## ⚡ 六、快表（TLB，Translation Lookaside Buffer）

### 📘 概念讲解

由于每次地址转换都要查页表，速度会变慢。
 于是硬件加入一个**高速缓存（TLB）**，存储**最近访问过的页表项**。

### 🧩 原理分析

- 先查 TLB，看有没有页号对应的物理页框；
- 命中（Hit）→ 直接得物理地址；
- 未命中（Miss）→ 查页表并更新 TLB。

> ✅ 访问速度显著提高，一次内存访问变成平均不到 1.1 次。

------

## 🧮 七、多级页表（Multilevel Page Table）

### 📘 概念讲解

如果虚拟空间很大（如 64位系统），
 页表就会极其庞大（数百万项），会占用大量内存。

解决办法：**将页表分级存储。**

### 🧩 原理分析

例如两级页表：

```
虚拟地址 = [页目录号 | 页表号 | 页内偏移]
```

访问流程：

1. 用“页目录号”查页目录表 → 得页表的物理地址；
2. 再用“页表号”查页表 → 得页框号；
3. 拼偏移。

> ✅ 仅当访问某部分虚拟空间时，才需加载相应的二级页表 → 节省内存。

### 📘 示例

32位地址（4KB页）：

```
页目录：10位
页表：10位
页内偏移：12位
```

一个页目录项指向一个页表，一个页表再指向1024个页。

23.有用户态进程A，其虚拟内存页为1KB，A占用了64页，内存大小为128KB，A进程将爱子到内存的页面和物理内存块的编号对应关系如下：

> 页面编号  物理内存块编号
>
> 0             4
>
> 1             9
>
> 2             5
>
> 3             8

请根据以上信息回答如下问题，并给出计算过程：

> 1）虚拟地址为015D对应的物理地址是多少？
>
> 2）物理地址为113C对应的虚拟地址为多少？
>
> 3）进程A有一作业长度为8页，试图访问虚拟地址2A3D并保存整型1到该地址对应的物理地址空间，之后又尝试从该地址读取保存的数据，请问A进程这两次内存访问过程能否正常执行？并解释原因。

