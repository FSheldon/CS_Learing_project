````
1.同步，异步，阻塞，非阻塞的概念

# 一、先把四个词放在“二维坐标系”里看

把“**同步 / 异步**”看成横轴（逻辑上的等待关系）：

- **同步（Synchronous）**：发出请求的实体**必须等待**请求结果/响应才能继续执行下一步（从逻辑上是顺序的）。
- **异步（Asynchronous）**：发出请求后立即返回，后续处理通过**回调 / 事件 / future / promise / 完成通知**等机制处理（逻辑上不必立即等待结果）。

把“**阻塞 / 非阻塞**”看成纵轴（线程/进程在等待时的运行状态）：

- **阻塞（Blocking）**：当等待时，**线程/进程被操作系统挂起（suspended）**，不会占用 CPU。
- **非阻塞（Non-blocking）**：调用立即返回，线程/进程**不会被操作系统挂起**；如果没有结果，通常返回一个“稍后再试”的错误码或状态，线程可以继续做别的事情或自己轮询。

这四个可以任意组合，形成 2×2 的矩阵（常见组合与实现）：

- 同步 + 阻塞（最典型）
- 同步 + 非阻塞（程序自己轮询直到拿到结果）
- 异步 + 非阻塞（事件驱动 / 回调 / 高效）
- 异步 + 阻塞（概念上可能，但实际少见 / 无意义）

# 二、什么是“调用线程或进程”与“挂起”？

- **调用线程/进程**：就是执行某条语句或函数（如 `read()`）的执行实体。单进程单线程程序中“调用进程”就是进程本身；多线程程序中是执行调用的那个线程。
- **挂起（suspend / blocked）**：操作系统调度层面的动作。线程状态从 **Running（运行）** → **Blocked/Waiting（阻塞/等待）**，OS 不再分配 CPU 时间给它，直到等待事件发生（如 I/O 完成、锁释放、定时到期）再把它放入就绪队列（Ready），由调度器恢复执行。

# 三、逐个详细解释并给实际例子

## 1）阻塞（Blocking）

**定义**：调用发出后，若结果不可立即得到，**线程被操作系统挂起**，直到结果可用并返回，然后继续执行。

**操作系统表现**：

- 线程状态变为 BLOCKED/WAITING。
- 不占用 CPU，内核保存其上下文，切换到其它线程运行。

**现实世界类比**：你到银行柜台办理业务，柜台说“请在这等着”，你坐在柜台前不离开直到办完（你被“挂起”去做别的事）。

**常见例子**：

- `read(fd, buf, size)` 在 blocking 文件描述符上：无数据则阻塞。
- `accept(listen_fd, ...)` 如果没有连接则阻塞。
- `pthread_mutex_lock(&m)` 如果锁被占用则阻塞等待。
- 阻塞的网络 `connect()`（直到连接建立或超时）。

**优点**：

- 编程模型简单、直观（写起来像顺序代码）。
- 不浪费 CPU（挂起时不占 CPU）。

**缺点**：

- 单线程应用在等待期间无法做其它工作。
- 大量并发时需要大量线程（每个阻塞操作都可能需要一个线程），线程切换开销和内存开销高。

------

## 2）非阻塞（Non-blocking）

**定义**：调用立即返回，不会被内核挂起；如果条件不满足（例如没有数据），调用返回一个指示“暂不可用”的状态（例如 `-1` 并设置 `errno == EAGAIN` / `EWOULDBLOCK`）。

**现实类比**：你去柜台问“好了没？”，柜台说“还没”，你回去继续做别的事情，不在柜台坐着等。

**常见例子**：

- 把 socket 或文件描述符设置 `O_NONBLOCK`，然后 `read()` / `write()` 会立即返回。
- `pthread_mutex_trylock(&m)`，如果锁不可得直接返回失败，不阻塞。

**实现方式**：

- 在用户态忙轮询（busy-wait）或使用事件机制（见下文）来获知何时可重试。

**优点**：

- 线程不会被挂起，可以继续执行其它工作或处理多个任务（适合事件循环）。
- 适合高并发场景与单线程事件架构。

**缺点**：

- 如果用轮询会浪费 CPU（忙等）。
- 编程复杂度增加（需处理返回码 EAGAIN 等）。

------

## 3）同步（Synchronous）

**定义（逻辑层面）**：调用者**必须等待**操作完成并拿到结果才能继续执行后续依赖结果的代码。强调“逻辑顺序性”。

**现实类比**：你点菜后一定要等到上菜才能吃，吃完才能离开桌子继续别的安排。

**举例**：

- 经典 `read()`、`write()` 默认就是同步调用（你拿到结果后才继续处理）。
- 在程序里写的顺序函数调用，后面的调用依赖前面结果，如 `data = read(); process(data);` —— 这是同步逻辑。

**注意**：同步只是逻辑约束，不必然决定线程是否被内核挂起（这就是你之前问的点）。

------

## 4）异步（Asynchronous）

**定义（逻辑层面）**：调用者发出操作后**不等待**结果立即返回。操作完成后，结果通过回调（callback）、事件通知、future/promise、信号、消息队列等方式告知调用方。

**现实类比**：你点菜后去看手机或聊天，服务员做好菜会叫你回来（回调）或把菜放桌上（事件通知）。

**实现/例子**：

- POSIX AIO (`aio_read`)（传统异步 I/O）。
- `io_uring`（Linux 新型异步 I/O 接口）。
- 在应用级别用线程池将同步调用放后台：`submit_task(fn)` 返回 future，后台线程执行 I/O，完成后 set promise（这是“伪异步”，但对调用者是异步）。
- JavaScript 的 `fetch(...).then(...)`、Node.js 的回调/Promise、Python 的 `async/await`（背后是事件循环 + 非阻塞 I/O）。

**优点**：

- 高效利用线程与 CPU（特别是在大量 I/O 并发时）。
- 单线程即可处理大量并发 I/O（事件驱动模型）。

**缺点**：

- 编程范式不同，回调地狱、错误处理、控制流复杂性较高（现代语言用 Promise / async/await 改善）。
- 有时需要额外资源或复杂底层支持。

------

# 四、把“同步/异步” 和 “阻塞/非阻塞” 具体举例对照

## 同步 + 阻塞（最常见）

- 调用：`read(fd, buf, size)`（blocking fd）
- 行为：调用被内核阻塞直到数据到来或错误
- 优点：代码简单直观
- 缺点：线程在等待时不能做别的事

## 同步 + 非阻塞（程序主动轮询）

- 调用：`set_nonblock(fd)`，然后循环 `read()`，直到成功
- 行为：每次调用立即返回，程序通过循环等待结果（busy-wait 或带 sleep 的轮询）
- 优点：不被内核阻塞；实现简单
- 缺点：若不加延时会浪费 CPU；延时会增加响应延迟

## 异步 + 非阻塞（事件驱动 / 推荐用于高并发）

- 调用：`epoll` / `select` / `poll` 等 + non-blocking fd；或者真正的异步 API（`io_uring`）
- 行为：注册事件，内核在资源就绪时通知；回调或事件循环处理
- 优点：高效、可扩展（单线程处理大量连接）
- 缺点：编程模型复杂（但 async/await 已大幅简化）

## 异步 + 阻塞（少见）

- 概念上：发起异步任务，但等待其完成时使用阻塞等待（如调用 `future.get()` 会阻塞当前线程直到完成）
- 这是把异步模式和阻塞等待组合起来，通常是对异步的“阻塞使用”，在设计上常被视为滥用或退化为同步阻塞。

2.PCB的概念，具体PCB中会保存哪些信息？

- #### 什么是进程控制块？

  当你打开一个应用程序，比如记事本、浏览器、微信……
  操作系统就会立刻“在后台”给这个程序建立一个档案。这个档案就是 PCB。

  它不是程序本身，而是一个专门的结构，负责记录：这个程序现在处于什么状态、执行到了哪一行、占用了哪些资源……

   **PCB 是操作系统用来「掌控」每一个正在运行程序的“控制中心”。**

  每一个进程在操作系统中都有一个专属的数据结构来表示它的状态与信息，这个结构就叫做 Process Control Block（PCB）。它也被称为 任务控制块（Task Control Block）。

  可以把 PCB 想象成一个“身份证 + 体检表 + 活动记录本”，里面包含了系统管理进程所需要的全部信息。

  #### 为什么需要 PCB？

  在系统中可能同时运行上百个进程：

  - 每个进程都需要 CPU、内存、文件、I/O 等资源
  - 每个进程的状态不断变化（如 Ready、Running、Waiting）
  - 系统要知道进程执行到哪里了、优先级是多少、打开了哪些文件…

  这些信息 不能乱、不能丢、不能搞混，否则程序运行会出错。

  于是，系统就用 PCB 来“记录”和“维护”每个进程的全貌。

  ------

  ### PCB 中包含哪些信息？

  PCB 是操作系统为每个进程创建的“档案袋”，里面记录了这个进程运行所需要的所有关键信息。

  我们可以把 PCB 想象成一个结构体（结构化数据块），它通常包含以下 8 大类信息：

  #### 1️⃣ **进程标识信息（Process Identification）**

  这类信息是操作系统用来**唯一识别和管理进程的编号或标识**。主要包括： 

  - Process ID（PID）：系统为每个进程分配的唯一编号。
  - Parent Process ID（PPID）：表示这个进程是谁创建的。
  - 用户 ID / 组 ID：识别运行这个进程的用户身份，决定权限。

  这类信息不是进程运行所需的，而是用于区分系统中的所有进程；关联父子进程结构和权限判断。例如，当操作系统进行进程调度或销毁某进程时，它必须通过 PID 精确指向该对象，不能有任何歧义。

  #### 2️⃣ **进程状态（Process State）**

  这是描述进程当前“生命周期阶段”的一组枚举型信息，常见状态：

  - New：刚被创建，还没准备好调度
  - Ready：已准备好，被放入就绪队列
  - Running：正在 CPU 上执行
  - Waiting / Blocked：在等待某种资源或事件，不可调度
  - Terminated：已完成或被强制终止，等待清理

  帮助操作系统调度器管理哪个进程可以运行、哪个需要等待。

  详细内容可以参考：[操作系统：进程状态（Process State）-CSDN博客](https://blog.csdn.net/2402_88047672/article/details/149797610?fromshare=blogdetail&sharetype=blogdetail&sharerId=149797610&sharerefer=PC&sharesource=2402_88047672&sharefrom=from_link)

  #### 3️⃣ **程序计数器（Program Counter）**

  程序计数器（PC）是一种特殊寄存器，用于记录**下一条将要执行的机器指令的地址**。

  系统执行程序或代码是逐行执行的。当一个进程因为某种原因被暂停，程序计数器记录它执行到哪了；当它恢复执行时，能从正确位置继续运行。

  当操作系统发生进程切换（上下文切换）时，它会暂停当前进程并保存其 PC 值，以便将来恢复时可以准确地从中断位置继续执行。

  如果不保存 PC，进程就只能从头开始或执行错误的指令序列，程序的连续性和正确性就无法保证。

  #### 4️⃣ **CPU 寄存器内容（CPU Registers）**

  除了程序计数器之外，CPU 在执行进程时还涉及多个寄存器，比如：

  - 通用寄存器：存储临时变量
  - 堆栈寄存器（Stack Pointer）：管理调用栈
  - 标志寄存器（Flags）：记录条件判断结果（例如某次比较操作结果）
  - 程序状态字（PSW）：控制中断使能、模式等运行环境信息

  所有这些寄存器共同定义了进程当前的执行上下文（execution context）。
  每次切换进程时，操作系统都必须将**当前进程的寄存器内容存入 PCB，加载新进程的寄存器内容**，否则会造成计算逻辑混乱，错误执行。

  执行程序过程中会频繁使用 CPU 寄存器。切换进程时，需要先保存当前寄存器状态，再加载另一个进程的寄存器内容，确保“接力不出错”。

  #### 5️⃣ **内存管理信息（Memory Management Info）**

  操作系统在进行地址转换、访问控制和内存隔离时必须依赖这些信息。这部分信息描述进程如何在内存中布置，包括：

  - 代码段地址（Text Segment）
  - 数据段（Data Segment）和 BSS 段
  - 堆（Heap）和栈（Stack）区域的边界
  - 页表或段表指针（如果使用分页/分段内存管理）

  如果没有这部分，系统将无法实现每个进程的独立地址空间，所有进程就可能读写彼此的数据，严重破坏系统安全性和稳定性。

   作用：帮助操作系统了解这个进程**用了哪些内存空间**，避免内存越界访问或与其他进程冲突。

  #### 6️⃣ **调度和优先级信息（Scheduling & Priority Info）**

  用于控制进程调度的参数：

  - 优先级（Priority）
  - 调度算法相关字段（如时间片耗尽标志、最近调度时间）
  - 进程是否可抢占（preemptable）

  操作系统的调度器（scheduler）依赖这些信息**决定哪个进程获得 CPU 执行权、执行多长时间**。
  例如，在 Linux 中，不同优先级的进程使用不同调度策略（如实时 vs 普通进程），这类信息就是其决策依据。

  #### 7️⃣ **I/O 状态信息（I/O Status Info）**

  这一类信息记录进程在使用的 I/O 设备状态，是操作系统“感知进程是否需要外部设备”的核心依据。 

  主要包含：

  - 打开了哪些文件（文件描述符表）
  - 每个文件/设备当前的读写偏移量
  - 是否在等待某个设备返回（如磁盘、网络）

  I/O 状态信息让操作系统知道一个进程“连着哪些外部接口”，便于 I/O 子系统知道这个进程在等待哪些输入输出，确保 I/O 完成后可以唤醒进程。

  #### 8️⃣ 会计信息（Accounting Info）

  这部分信息是操作系统用来记录一个进程在资源使用方面的“行为记录”。

  它包含的典型字段：

  - CPU 占用时间（区分用户态和内核态）
  - 内存使用量
  - IO 读写次数或数据量

  这些数据不是用来控制进程运行的，而是让操作系统可以“看见”一个进程在系统中真实使用过哪些资源、持续了多久。不是为了调度而存在，但却是系统稳定性、资源公平性、责任审计的基础。

  ### PCB 是怎么用的？

  我们来讲讲 PCB 的 使用流程，你会理解它为什么是操作系统的“灵魂小本子”。

  **使用场景一：进程创建时**

  - 操作系统会为新进程分配一个 PCB，并填写初始状态（如 New）
  - 初始化：程序计数器指向程序入口；状态设为 Ready

  没有 PCB，就没有地方放这些信息，也无法调度这个进程。就像你要注册一个学生，必须先建立档案，后续成绩、课程都记在档案里。 

  **使用场景二：进程调度时**

  当 CPU 空出来，调度器会从“就绪队列（Ready Queue）”中选择一个进程运行，这时它会：

  - 遍历或优先选择某个 PCB（通常依据优先级、等待时间等）
  - 加载这个 PCB 中保存的：
    - 程序计数器（下一条要执行的地址）
    - 寄存器状态（恢复上下文）
    - 地址空间结构

  然后把 CPU 控制权交给这个进程。

  操作系统调度不是“拍脑袋”，而是基于 PCB 中保存的优先级、状态、历史等字段决定谁上 CPU。没有 PCB，就像没有选手资料就开始比赛——无法公平决策。

  **使用场景三：进程终止时**

  当进程完成执行或被强制终止时，操作系统会：

  - 读取 PCB 中的信息，查：
    - 该进程打开了哪些文件，释放文件描述符
    - 占用了哪些内存区域，释放物理内存
    - 使用了哪些设备，解除设备绑定
    - 写入会计信息：记录它用了多长时间、用了多少资源
  - 把 PCB 从进程表中清除，彻底释放这个“进程的存在”

  系统无法凭空知道一个进程都用了什么资源，必须靠 PCB 记录的信息才能进行干净的资源回收，避免“资源泄露”。 

![图片说明](https://uploadfiles.nowcoder.com/images/20211226/820488794_1640503265595/53A907732353F3A0169EF2122F347866)

3.几种进程调度算法

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

## 一、批处理系统（Batch Processing System）

### 🧠 1. 概念

**批处理系统**是指**用户将若干作业（任务）提交给操作系统后，由系统统一调度、成批处理**的一类操作系统。
 用户在提交作业后**不需要立即与系统交互**，系统在适当时机**自动执行这些作业**。

👉 简单来说：

> 用户一次性交给系统一堆任务，然后系统自己找时间一批一批执行。

------

### ⚙️ 2. 工作方式（运行流程）

1. 用户把作业（程序 + 数据 + 作业说明）提交给操作系统。
2. 系统将作业暂存到**输入队列**（作业池）中。
3. **作业调度程序**根据一定策略（如先来先服务、最短作业优先等）选择下一个作业。
4. 作业在系统中顺序执行，执行完后输出结果。
5. 用户收到结果，但整个过程中没有实时交互。

------

### 💡 3. 实际例子

- **早期的大型机系统（Mainframe）**：
  - IBM 360、UNIVAC 等大型主机，用户把作业打成穿孔卡提交。
- **现代版本的批处理系统**：
  - 数据中心的**批量数据分析任务**（Hadoop MapReduce 作业）
  - **银行结算系统**：每晚统一批量处理当日交易、生成账单。
  - **高校服务器的批量作业系统（如 SLURM、PBS）**：科研人员提交计算任务，排队执行。
  - **自动化报表系统**：每天凌晨生成财务报表。

------

### 🎯 4. 设计重点

- **系统吞吐量**：单位时间完成的作业数最大化。
- **CPU 利用率**：减少空闲时间，提高资源使用率。
- **作业调度算法**：保证系统整体效率和公平性。
- **无需人机交互**：重点是自动化、高效处理大量任务。

------

## 二、交互式系统（Interactive System）

### 🧠 1. 概念

**交互式系统**是指**用户与计算机系统之间存在实时交互**的系统。
 用户通过终端（键盘、GUI 等）输入命令，系统**立即响应**并返回结果。

👉 你每天用的 Windows、macOS、Linux 桌面版，都是交互式系统。

------

### ⚙️ 2. 工作方式（运行流程）

1. 用户通过命令行或图形界面发出请求；
2. 系统解析命令，立即执行；
3. 将结果反馈给用户；
4. 用户根据结果再次输入命令（形成连续的交互循环）。

> 交互式系统必须保证“响应时间”短，用户感觉系统在“随时听他指挥”。

------

### 💡 3. 实际例子

- **桌面操作系统**：Windows、macOS、Linux 桌面版
- **服务器 shell 环境**：Linux SSH 登录后与系统实时交互
- **数据库管理系统（DBMS）交互查询**：用户输入 SQL，系统返回结果
- **智能手机操作系统（Android / iOS）**
- **网页交互系统**：如在线 IDE、聊天网页（前端与服务器实时交互）

------

### 🎯 4. 设计重点

- **响应时间（Response Time）短**
- **交互性强**：允许频繁的用户操作和反馈
- **多道程序设计**：同时执行多个任务，提升系统响应
- **用户体验友好**：UI 设计、输入响应速度

------

## 三、实时系统（Real-Time System）

### 🧠 1. 概念

**实时系统**要求系统不仅要正确执行计算任务，还要**在严格规定的时间内完成**任务。
 也就是说，**时间正确性与逻辑正确性同等重要**。

> 如果系统结果计算正确但延迟太久——在实时系统里就是**错误**！

------

### ⚙️ 2. 实时系统分类

根据时间要求的严格程度，实时系统分为两种：

| 类型                                    | 定义                                                         | 示例                                       |
| --------------------------------------- | ------------------------------------------------------------ | ------------------------------------------ |
| **硬实时系统（Hard Real-Time System）** | 必须在截止时间（Deadline）前完成任务，否则系统出错甚至崩溃。 | 飞机控制系统、核电站控制、汽车安全气囊系统 |
| **软实时系统（Soft Real-Time System）** | 偶尔错过截止时间可接受，但性能会下降。                       | 视频播放、网络游戏、在线语音通话           |

------

### 💡 3. 实际例子

- **硬实时系统**：
  - 飞机飞控系统（F-35 Flight Control）
  - 医疗监护系统（心电监测、呼吸机）
  - 自动驾驶车辆的避障系统
  - 工业自动化设备（数控机床、机器人臂控制）
- **软实时系统**：
  - 网络视频会议（Zoom、腾讯会议）
  - 音视频播放器
  - 实时股票交易分析系统

------

### 🎯 4. 设计重点

- **时间确定性**（Determinism）：在规定时间内响应；
- **优先级调度**（如 Rate Monotonic、Earliest Deadline First）；
- **资源可预测性**：对内存、I/O、CPU 的访问可精确控制；
- **系统可靠性和稳定性**极高；
- 通常牺牲通用性换取时间保证（例如限制分页、禁止动态内存分配）。

------

## 四、三者区别对比表

| 特性               | 批处理系统                       | 交互式系统             | 实时系统                       |
| ------------------ | -------------------------------- | ---------------------- | ------------------------------ |
| **用户交互**       | 无                               | 有                     | 通常无（自动控制）             |
| **响应时间**       | 不重要（延迟可接受）             | 重要（尽快响应）       | 极重要（必须在时间限制内完成） |
| **主要目标**       | 提高系统吞吐量                   | 提高响应速度与交互体验 | 满足时间约束、稳定性与可靠性   |
| **典型环境**       | 后台数据处理、大型机、服务器集群 | 桌面、服务器、智能终端 | 工业控制、飞控、医疗系统       |
| **调度策略**       | 批量作业调度（FCFS、SJF）        | 时间共享（RR、MLFQ）   | 优先级调度（RM、EDF）          |
| **例子**           | 银行结算系统、Hadoop 批处理      | Windows/Linux 桌面     | 汽车控制系统、飞控系统         |
| **是否强调实时性** | 否                               | 一般                   | 是                             |
| **性能关注点**     | 吞吐量                           | 响应时间               | 时间确定性                     |

### [#](https://www.cyc2018.xyz/计算机基础/操作系统基础/计算机操作系统 - 进程管理.html#_1-批处理系统)1. 批处理系统

批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

**1.1 先来先服务 first-come first-serverd（FCFS）**

非抢占式的调度算法，按照请求的顺序进行调度。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

**1.2 短作业优先 shortest job first（SJF）**

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

**1.3 最短剩余时间优先 shortest remaining time next（SRTN）**

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

### [#](https://www.cyc2018.xyz/计算机基础/操作系统基础/计算机操作系统 - 进程管理.html#_2-交互式系统)2. 交互式系统

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

**2.1 时间片轮转**

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系：

- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
- 而如果时间片过长，那么实时性就不能得到保证。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8c662999-c16c-481c-9f40-1fdba5bc9167.png)

**2.2 优先级调度**

为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

**2.3 多级反馈队列**

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png)

## 🧩 一、时间片轮转调度（Round-Robin, RR）

### 🧠 1. 核心思想

系统给每个就绪进程分配**一个固定时间片（time quantum）**，
 进程在这个时间片内运行。

- 若在时间片结束前完成 → 退出队列。
- 若未完成 → 操作系统**抢占**它，把它放回就绪队列尾部，等待下一次轮到它。

👉 所有进程**公平轮流使用 CPU**。

------

### ⚙️ 2. 运行机制

假设时间片长度 = 1 单位时间（仅举例），就绪队列按 FIFO 顺序管理：

示例进程：

| 进程 | 到达时间 | CPU 总运行时间 |
| ---- | -------- | -------------- |
| P1   | 0        | 5              |
| P2   | 0        | 3              |
| P3   | 0        | 1              |

**执行过程：**

```
时间片长度 = 1
就绪队列初始：[P1, P2, P3]

时间线：
0-1: P1（剩余4）
1-2: P2（剩余2）
2-3: P3（完成）
3-4: P1（剩余3）
4-5: P2（剩余1）
5-6: P1（剩余2）
6-7: P2（完成）
7-8: P1（剩余1）
8-9: P1（完成）

结束。
```

------

### 📊 3. 特点

| 优点                                | 缺点                                  |
| ----------------------------------- | ------------------------------------- |
| 公平性高，每个进程都能获得 CPU 时间 | 时间片太短：频繁上下文切换，开销大    |
| 响应速度快（适合交互式系统）        | 时间片太长：退化成 FCFS（先来先服务） |
| 易于实现                            | 不区分作业的重要性或优先级            |

------

### 💡 4. 实际应用

- 几乎所有**交互式操作系统（如 Linux、Windows）**都基于时间片轮转思想；
- Linux 调度器会动态调整“时间片”长度（高优先级的进程时间片更长）；
- 浏览器标签页、文本编辑器、终端命令等都在使用 RR 思想保证响应性。

------

## 🧩 二、优先级调度（Priority Scheduling）

### 🧠 1. 核心思想

每个进程分配一个**优先级（priority）**，
 操作系统**始终选择优先级最高的进程**运行。

> 你可以把它理解为：CPU 是个 VIP 服务台，优先为“重要的顾客”服务。

------

### ⚙️ 2. 运行方式

可以分为两种：

1. **非抢占式**：当前运行的进程不会被新来的高优先级进程打断；
2. **抢占式**：一旦有更高优先级的进程到来，当前进程立即被抢占。

------

### 📘 示例（抢占式）

| 进程 | 到达时间 | 运行时间 | 优先级（数字越小优先级越高） |
| ---- | -------- | -------- | ---------------------------- |
| P1   | 0        | 4        | 2                            |
| P2   | 1        | 3        | 1                            |
| P3   | 2        | 2        | 3                            |

执行过程：

```
0-1: P1开始（优先级2）
1: P2到达（优先级1），抢占P1
1-4: P2执行完
4-6: P1继续执行（剩余3→0）
6-8: P3执行
```

------

### 📊 3. 特点

| 优点                   | 缺点                                         |
| ---------------------- | -------------------------------------------- |
| 高优先级任务快速响应   | 低优先级任务可能被长期饿死（Starvation）     |
| 灵活，可反映任务重要性 | 需要额外机制防止饥饿（如“优先级老化 aging”） |
| 可与实时系统结合使用   | 调度复杂度稍高                               |

------

### 💡 4. 现实应用

- **操作系统内核**：中断处理线程优先级最高；
- **实时系统**：关键任务优先级高，普通任务低；
- **打印系统**：紧急文件可被优先打印；
- **Linux 调度器**：使用“动态优先级”机制（基于进程 nice 值和历史运行情况）。

------

### 🔧 5. “优先级老化 (Aging)” 机制

为防止低优先级任务“永远得不到 CPU”，系统会让等待时间长的任务**逐渐提升优先级**：

> 等待越久 → 优先级越高 → 迟早会被调度

这种策略常与优先级调度结合使用。

------

## 🧩 三、多级反馈队列调度（Multilevel Feedback Queue, MLFQ）

### 🧠 1. 核心思想

**综合时间片轮转与优先级调度的优点。**

操作系统维护**多个就绪队列**，每个队列有**不同的优先级和时间片**。

- 新进程从最高优先级队列开始；
- 如果在分配的时间片内没跑完 → 降到下一级优先级队列；
- 等待时间过长的进程可能被提升（防止饥饿）。

> 📘 简单理解：
>  “短作业”和“响应型进程”留在高优先级队列，
>  “长作业”逐渐下沉到底层队列。

------

### ⚙️ 2. 典型结构示意

| 队列号 | 优先级 | 时间片长度 | 特点                 |
| ------ | ------ | ---------- | -------------------- |
| Q0     | 最高   | 8ms        | 短作业优先，时间片短 |
| Q1     | 中等   | 16ms       | 普通作业             |
| Q2     | 最低   | 32ms       | 长作业、后台任务     |

------

### 📘 示例：

假设三个进程：

| 进程 | CPU总时间 |
| ---- | --------- |
| P1   | 6         |
| P2   | 12        |
| P3   | 30        |

初始都进入最高级队列 Q0（时间片=8ms）。

**执行过程：**

```
0-6: P1完成（用时6<8）
6-14: P2运行（剩余4），未完成 → 降到Q1
14-22: P3运行（剩余22），未完成 → 降到Q1
Q0空，调度Q1（时间片16）

22-26: P2继续（剩余0，完成）
26-42: P3继续（剩余6），未完成 → 降到Q2
Q1空，调度Q2（时间片32）

42-48: P3完成
```

最终顺序：P1 → P2 → P3
 P1响应最快，P3延迟最大，但**系统整体公平且高效**。

------

### 📊 3. 特点

| 优点                             | 缺点                 |
| -------------------------------- | -------------------- |
| 综合公平性与响应性               | 实现复杂，需要调参   |
| 短作业可快速完成                 | 长作业可能被频繁降级 |
| 防止饥饿（通过优先级提升 aging） | 调度器维护成本高     |

------

### 💡 4. 实际应用

- **现代操作系统调度器的原型**：
  - Linux CFS（完全公平调度器） → 基于改进的 MLFQ 思想；
  - Windows 调度器 → 使用动态优先级反馈机制；
- **UNIX BSD 调度器** → 典型 MLFQ 实现；
- **游戏系统 / 图形渲染线程**：高响应线程放在高优先级队列。

------

## 🔍 四、三种算法的对比总结

| 特性             | 时间片轮转 (RR)          | 优先级调度     | 多级反馈队列 (MLFQ)          |
| ---------------- | ------------------------ | -------------- | ---------------------------- |
| **调度依据**     | 时间片顺序               | 优先级高低     | 综合优先级 + 时间片反馈      |
| **抢占**         | 是                       | 可抢占或非抢占 | 抢占式                       |
| **响应时间**     | 快，公平                 | 高优先级快     | 高优先级快，低优先级逐渐下降 |
| **是否防止饥饿** | 是                       | 否（需老化）   | 是（自动调整优先级）         |
| **适用场景**     | 交互式系统               | 实时系统       | 通用操作系统                 |
| **实现复杂度**   | 简单                     | 中等           | 高                           |
| **现实应用**     | Linux/Windows 时间片调度 | 实时内核调度   | 现代 OS 通用调度器核心思想   |

### [#](https://www.cyc2018.xyz/计算机基础/操作系统基础/计算机操作系统 - 进程管理.html#_3-实时系统)3. 实时系统

实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。



4.解释一下死锁，死锁的必要条件，避免，解开死锁的几种方法。

## 🧩 一、死锁的定义（Deadlock Definition）

### 💡 概念：

> **死锁**是指一组进程（或线程）因竞争资源或相互等待而永远阻塞、无法继续执行的状态。

换句话说：

- 每个进程都**持有某些资源**，
- 同时又**请求新的资源**，但这些资源被其他进程占用，
- 导致它们**互相等待，永远无法被唤醒**。

## 必要条件

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c037c901-7eae-4e31-a1e4-9d41329e5c3e.png)

- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。

- 占有和等待：已经得到了某个资源的进程可以再请求新的资源。

- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。

- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

- 📘 **举例（对应上面的例子）**

  - 互斥：资源A、B都不能同时给两人；
  - 占有且等待：P1占A还要B；
  - 不可剥夺：P2占了B不能强制拿走；
  - 循环等待：P1等B，P2等A，形成环。

  ## 🧩 三、死锁的系统状态表示（资源分配图）

  操作系统中通常用**资源分配图（Resource Allocation Graph, RAG）**来描述死锁关系。

  - **圆圈**代表进程；
  - **方框**代表资源；
  - **箭头方向**：
    - 进程 → 资源 ：表示进程请求资源；
    - 资源 → 进程 ：表示资源分配给进程。

  📘 **死锁存在当且仅当：**

  > 资源分配图中存在“环形等待回路（cycle）”。

  ------

  ## 🧩 四、死锁的处理方法（Deadlock Handling Methods）

  操作系统可以通过**预防（prevent）**、**避免（avoid）**、**检测并恢复（detect & recover）**三种思路来处理死锁。

  ### ✅ 1. 死锁预防（Prevention）

  **思想：**
   在系统设计阶段**破坏四个必要条件之一**，使死锁永远不会发生。

  | 被破坏条件 | 方法                           | 示例                                  |
  | ---------- | ------------------------------ | ------------------------------------- |
  | 互斥       | 尽量让资源可共享               | 如文件只读可共享；但打印机无法共享    |
  | 占有且等待 | 进程一次性申请所有资源         | 但浪费资源，降低并发性                |
  | 不可剥夺   | 允许系统强制回收资源           | 如被高优先级任务抢占                  |
  | 循环等待   | 对资源排序，进程必须按顺序申请 | 例如编号资源R1<R2，必须先申请小号资源 |

  ### ✅ 2. 死锁避免（Avoidance）

  **思想：**
   在资源分配时，系统**动态分析是否会进入不安全状态**，如果可能导致死锁，就拒绝分配。

  📘 典型算法：**银行家算法（Banker’s Algorithm）**

  #### 🏦 银行家算法原理：

  - 系统像银行一样，有一定资源“余额”；
  - 当进程请求资源时，系统检查：
     若满足请求后仍处于“安全状态” → 批准；
     若会导致“危险（潜在死锁）” → 拒绝。

  #### 举例：

  银行有10张钞票（资源），
   三位客户：

  | 客户 | 最大需求 | 当前占有 | 剩余需求 |
  | ---- | -------- | -------- | -------- |
  | A    | 7        | 2        | 5        |
  | B    | 5        | 1        | 4        |
  | C    | 3        | 1        | 2        |

  如果A再要3张（总占5），系统判断：

  > 若满足它后，系统能否依次满足每个人最终释放？
  >  如果“不能”，就暂时拒绝分配。

  ✅ 银行家算法通过动态判断安全状态来**避免死锁的出现**。

  在程序运行时避免发生死锁。

  ### [#](https://www.cyc2018.xyz/计算机基础/操作系统基础/计算机操作系统 - 死锁.html#_1-安全状态)1. 安全状态

  ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed523051-608f-4c3f-b343-383e2d194470.png)

  图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。

  定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。

  安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。

  ### [#](https://www.cyc2018.xyz/计算机基础/操作系统基础/计算机操作系统 - 死锁.html#_2-单个资源的银行家算法)2. 单个资源的银行家算法

  一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。

  ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png)

  上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。

  ### [#](https://www.cyc2018.xyz/计算机基础/操作系统基础/计算机操作系统 - 死锁.html#_3-多个资源的银行家算法)3. 多个资源的银行家算法

  ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png)

  上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。

  检查一个状态是否安全的算法如下：

  - 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。
  - 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。
  - 重复以上两步，直到所有进程都标记为终止，则状态时安全的。

  如果一个状态不是安全的，需要拒绝进入这个状态。

  ------

  ### ✅ 3. 死锁检测与恢复（Detection & Recovery）

  **思想：**

  > 系统允许死锁发生，但能“检测到死锁”，然后“采取措施解除死锁”。

  #### (1) 死锁检测：

  - 系统定期扫描资源分配图；
  - 若检测到**循环等待环**，则存在死锁。

  ### 1. 每种类型一个资源的死锁检测

  ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1fa0453-a4b0-4eae-a352-48acca8fff74.png)

  上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。

  图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。

  每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。

  ### [#](https://www.cyc2018.xyz/计算机基础/操作系统基础/计算机操作系统 - 死锁.html#_2-每种类型多个资源的死锁检测)2. 每种类型多个资源的死锁检测

  ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png)

  上图中，有三个进程四个资源，每个数据代表的含义如下：

  - E 向量：资源总量
  - A 向量：资源剩余量
  - C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量
  - R 矩阵：每个进程请求的资源数量

  进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。

  算法总结如下：

  每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。

  1. 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。
  2. 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。
  3. 如果没有这样一个进程，算法终止。

  #### (2) 死锁恢复：

  | 方法     | 说明                                     |
  | -------- | ---------------------------------------- |
  | 终止进程 | 终止部分进程（通常代价最小的）以打破死锁 |
  | 资源剥夺 | 暂时撤销某进程的资源并分配给他人         |
  | 回滚     | 将进程回到安全状态点重新执行             |

  ⚠️ 缺点：

  - 检测与恢复代价较高；
  - 适用于死锁概率低、但必须保证系统连续运行的场景（如服务器）。

  ------

  ### ✅ 4. 死锁忽略（Ignore）

  > 也叫**鸵鸟策略（Ostrich policy）**
  >  ——“把头埋进沙子，假装没看到问题”。

  - 现代系统（如Linux、Windows）常采用这种策略；
  - 死锁出现概率很低（如系统调用锁设计良好）；
  - 出现死锁时由用户或管理员重启相关进程。

  ------

  ## 🧩 五、死锁处理方法对比总结

  | 方法       | 思想             | 优点         | 缺点                     |
  | ---------- | ---------------- | ------------ | ------------------------ |
  | 预防       | 破坏必要条件     | 简单直接     | 并发性差，资源利用率低   |
  | 避免       | 动态判断安全状态 | 安全性高     | 实现复杂，需预知最大需求 |
  | 检测与恢复 | 检测后解除死锁   | 资源利用率高 | 检测/恢复代价高          |
  | 忽略       | 不处理死锁       | 简单         | 无法保证安全性           |

## 5.解释一下几种界面置换算法。

在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。

页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

### [#](https://www.cyc2018.xyz/计算机基础/操作系统基础/计算机操作系统 - 内存管理.html#_1-最佳)1. 最佳

> OPT, Optimal replacement algorithm

所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。

是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。

举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：

```html
7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1
```

开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。

### [#](https://www.cyc2018.xyz/计算机基础/操作系统基础/计算机操作系统 - 内存管理.html#_2-最近最久未使用)2. 最近最久未使用

> LRU, Least Recently Used

虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。

为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。

因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。

```html
4，7，0，7，1，0，1，2，1，2，6
```

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eb859228-c0f2-4bce-910d-d9f76929352b.png)

\### 3. 最近未使用

> NRU, Not Recently Used

每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：

- R=0，M=0
- R=0，M=1
- R=1，M=0
- R=1，M=1

当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。

NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。

### [#](https://www.cyc2018.xyz/计算机基础/操作系统基础/计算机操作系统 - 内存管理.html#_4-先进先出)4. 先进先出

> FIFO, First In First Out

选择换出的页面是最先进入的页面。

该算法会将那些经常被访问的页面换出，导致缺页率升高。

### [#](https://www.cyc2018.xyz/计算机基础/操作系统基础/计算机操作系统 - 内存管理.html#_5-第二次机会算法)5. 第二次机会算法

FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：

当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png)

### [#](https://www.cyc2018.xyz/计算机基础/操作系统基础/计算机操作系统 - 内存管理.html#_6-时钟)6. 时钟

> Clock

第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png)
````
