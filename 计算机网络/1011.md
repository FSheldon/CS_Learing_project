# 网络协议学习笔记

## 1.HTTP/HTTPS 协议的工作过程（核心传输）

### 应用层生成 HTTP 请求消息
- 示例：
  ```
  GET / HTTP/1.1  // 方法：获取首页
  Host: www.example.com  // 主机名
  User-Agent: Chrome/120.0  // 浏览器信息
  ```
- （HTTPS 会先握手加密密钥，确保数据安全。）

### 传输层处理
- 往下传给传输层（TCP），TCP 加段头、建立连接。

### 服务器响应
- 服务器收到后，应用层解析请求，生成响应：
  ```
  HTTP/1.1 200 OK  // 成功
  Content-Type: text/html  // 类型：网页
  <html><body>欢迎！</body></html>  // 实际内容
  ```
- 浏览器应用层收到，解释成网页，渲染给你看。

### 示例：发微信消息
- 应用层用自定义协议（微信的私有协议，基于 HTTP）包装消息：“文本+表情+时间戳”。
- 加用户 ID、群 ID 等元数据。
- 传给 TCP，确保不丢；服务器应用层解析，推给接收者。

### 总结：
- **格式化与验证**：确保数据结构正确（e.g., JSON/XML 格式）。
- **会话管理**：跟踪对话（e.g., HTTP 的 Cookie 记住登录状态）。
- **安全性**：集成加密（HTTPS）、认证（OAuth）。
- **多媒体处理**：支持图片、视频的编码（MIME 类型）。

## HTTP/HTTPS 报文内容及含义

### curl 示例输出
```
C:\Users\SHE.F>curl -v http://www.baidu.com
* Host www.baidu.com:80 was resolved.
* IPv6: (none)
* IPv4: 39.156.70.239, 39.156.70.46
*   Trying 39.156.70.239:80...
* Connected to www.baidu.com (39.156.70.239) port 80
* using HTTP/1.x
> GET / HTTP/1.1
> Host: www.baidu.com
> User-Agent: curl/8.13.0
> Accept: */*
>
* Request completely sent off
< HTTP/1.1 200 OK
< Accept-Ranges: bytes
< Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
< Connection: keep-alive
< Content-Length: 2381
< Content-Type: text/html
< Date: Sat, 11 Oct 2025 06:11:09 GMT
< Etag: "588604c1-94d"
< Last-Modified: Mon, 23 Jan 2017 13:27:29 GMT
< Pragma: no-cache
< Server: bfe/1.0.8.18
< Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/
< Tr_id: bfe_10453437151549512691
<
<!DOCTYPE html>
<!--STATUS OK--><html> <head><meta http-equiv=content-type content=text/html;charset=utf-8><meta http-equiv=X-UA-Compatible content=IE=Edge><meta content=always name=referrer><link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css><title>百度一下，你就知道</title></head> <body link=#0000cc> <div id=wrapper> <div id=head> <div class=head_wrapper> <div class=s_form> <div class=s_form_wrapper> <div id=lg> <img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129> </div> <form id=form name=f action=//www.baidu.com/s class=fm> <input type=hidden name=bdorz_come value=1> <input type=hidden name=ie value=utf-8> <input type=hidden name=f value=8> <input type=hidden name=rsv_bp value=1> <input type=hidden name=rsv_idx value=1> <input type=hidden name=tn value=baidu><span class="bg s_ipt_wr"><input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus></span><span class="bg s_btn_wr"><input type=submit id=su value=百度一下 class="bg s_btn"></span> </form> </div> </div> <div id=u1> <a href=http://news.baidu.com name=tj_trnews class=mnav>新闻</a> <a href=http://www.hao123.com name=tj_trhao123 class=mnav>hao123</a> <a href=http://map.baidu.com name=tj_trmap class=mnav>地图</a> <a href=http://v.baidu.com name=tj_trvideo class=mnav>视频</a> <a href=http://tieba.baidu.com name=tj_trtieba class=mnav>贴吧</a> <noscript> <a href=http://www.baidu.com/bdorz/login.gif?login&tpl=mn&u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tj_login class=lb>登录</a> </noscript> <script>document.write('<a href="http://www.baidu.com/bdorz/login.gif?login&tpl=mn&u='+ encodeURIComponent(window.location.href+ (window.location.search === "" ? "?" : "&")+ "bdorz_come=1")+ '" name="tj_login" class="lb">登录</a>');</script> <a href=//www.baidu.com/more/ name=tj_briicon class=bri style="display: block;">更多产品</a> </div> </div> </div> <div id=ftCon> <div id=ftConw> <p id=lh> <a href=http://home.baidu.com>关于百度</a> <a href=http://ir.baidu.com>About Baidu</a> </p> <p id=cp>&copy;2017 Baidu <a href=http://www.baidu.com/duty/>使用百度前必读</a>  <a href=http://jianyi.baidu.com/ class=cp-feedback>意见反馈</a> 京ICP证030173号  <img src=//www.baidu.com/img/gs.gif> </p> </div> </div> </div> </body> </html>
* Connection #0 to host www.baidu.com left intact
```

### 报文解析
#### 第一部分：前置信息（连接建立）
```
* Host www.baidu.com:80 was resolved.
* IPv6: (none)
* IPv4: 39.156.70.239, 39.156.70.46
*   Trying 39.156.70.239:80...
* Connected to www.baidu.com (39.156.70.239) port 80
* using HTTP/1.x
```
- **DNS 解析**：curl 先查 `www.baidu.com` 的 IP（IPv4 有俩备选，用了第一个）。这是应用层的 DNS 协议在后台干的活。
- **TCP 连接**：用 80 端口（HTTP 默认）建立连接。这是传输层（TCP 三握手）的结果。
- **HTTP/1.x**：确认用 1.x 版本（1.1）。

#### 第二部分：HTTP 请求报文（Request Message）
```
> GET / HTTP/1.1
> Host: www.baidu.com
> User-Agent: curl/8.13.0
> Accept: */*
>
```

#### 第三部分：HTTP 响应报文（Response Message）
```
< HTTP/1.1 200 OK
< Accept-Ranges: bytes
< Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
< Connection: keep-alive
< Content-Length: 2381
< Content-Type: text/html
< Date: Sat, 11 Oct 2025 06:11:09 GMT
< Etag: "588604c1-94d"
< Last-Modified: Mon, 23 Jan 2017 13:27:29 GMT
< Pragma: no-cache
< Server: bfe/1.0.8.18
< Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/
< Tr_id: bfe_10453437151549512691
<
```

#### 第四部分：响应体（Body）
- HTML 内容（百度首页）。

## HTTPS 的加密过程详解

HTTPS 的整个通信过程可以分为两大阶段：**证书验证**和**数据传输阶段**，数据传输阶段又可以分为**非对称加密**和**对称加密**两个阶段。具体流程按序号讲解。

### 详细流程
1. 客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的 80 端口)。
2. 采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority) 证书，证书是需要申请的，并由专门的数字证书认证机构 (CA) 通过非常严格的审核之后颁发的电子证书 (当然了是要钱的，安全级别越高价格越贵)。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。
3. 服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。Chrome 浏览器点击地址栏的锁标志再点击证书就可以看到证书详细信息。
4. 客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。
5. 如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥 A。然后客户端还会生成一个随机码 KEY，并使用公钥 A 将其加密。
6. 客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。
7. 服务器在收到随机码 KEY 之后会使用私钥 B 将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。
8. 服务器使用密钥 (随机码 KEY) 对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY) 解密数据。
9. 双方使用对称加密愉快地传输所有数据。

## HTTPS 和 HTTP 的区别

### 最重要区别
- **安全性**：HTTP 明文传输，不对数据进行加密安全性较差。HTTPS (HTTP + SSL / TLS) 的数据传输过程是加密的，安全性较好。

### 其他区别
- 使用 HTTPS 协议需要申请 CA 证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、DigiCert 和 GlobalSign 等。
- HTTP 页面响应速度比 HTTPS 快，这个很好理解，由于加了一层安全层，建立连接的过程更复杂，也要交换更多的数据，难免影响速度。
- 由于 HTTPS 是建构在 SSL / TLS 之上的 HTTP 协议，所以，要比 HTTP 更耗费服务器资源。
- HTTPS 和 HTTP 使用的是完全不同的连接方式，用的端口也不一样，前者是 443，后者是 80。

### HTTPS 的缺点
- 在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是耗电量都有大幅度上升。
- HTTPS 的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。
- 在现有的证书机制下，中间人攻击依然有可能发生。
- HTTPS 需要更多的服务器资源，也会导致成本的升高。

## SSL / TLS 以及 SSL / TLS 握手的概念

### 1. SSL / TLS 概念
SSL 和 TLS 协议可以为通信双方提供识别和认证通道，从而保证通信的机密性和数据完整性。TLS 协议是从 Netscape SSL 3.0 协议演变而来的，不过这两种协议并不兼容，SSL 已经逐渐被 TLS 取代，所以下文就以 TLS 指代安全层。

### 2. TLS 握手过程中发生了什么
TLS 握手是启动 HTTPS 通信的过程，类似于 TCP 建立连接时的三次握手。在 TLS 握手的过程中，通信双方交换消息以相互验证，相互确认，并确立它们所要使用的加密算法以及会话密钥 (用于对称加密的密钥)。可以说，TLS 握手是 HTTPS 通信的基础部分。

具体：
- 商定双方通信所使用的 TLS 版本 (例如 TLS1.0, 1.2, 1.3 等等)；
- 确定双方所要使用的密码组合；
- 客户端通过服务器的公钥和数字证书上的数字签名验证服务端的身份；
- 生成会话密钥，该密钥将用于握手结束后的对称加密。

### 3. TLS 握手详细过程
"client hello" 消息：客户端通过发送 "client hello" 消息向服务器发起握手请求，该消息包含了客户端所支持的 TLS 版本和密码组合以供服务器进行选择，还有一个 "client random" 随机字符串。

"server hello" 消息：服务器发送 "server hello" 消息对客户端进行回应，该消息包含了数字证书，服务器选择的密码组合和 "server random" 随机字符串。

**验证**：客户端对服务器发来的证书进行验证，确保对方的合法身份，验证过程可以细化为以下几个步骤：

- 检查数字签名
- 验证证书链 (这个概念下面会进行说明)
- 检查证书的有效期
- 检查证书的撤回状态 (撤回代表证书已失效)

"premaster secret" 字符串：客户端向服务器发送另一个随机字符串 "premaster secret (预主密钥)"，这个字符串是经过服务器的公钥加密过的，只有对应的私钥才能解密。

使用私钥：服务器使用私钥解密 "premaster secret"。

生成共享密钥：客户端和服务器均使用 client random，server random 和 premaster secret，并通过相同的算法生成相同的共享密钥 KEY。

客户端就绪：客户端发送经过共享密钥 KEY 加密过的 "finished" 信号。

服务器就绪：服务器发送经过共享密钥 KEY 加密过的 "finished" 信号。

达成安全通信：握手完成，双方使用对称加密进行安全通信。

### 4. TLS 握手过程中的一些重要概念

#### 数字证书 (digital certificate)
在非对称加密通信过程中，服务器需要将公钥发送给客户端，在这一过程中，公钥很可能会被第三方拦截并替换，然后这个第三方就可以冒充服务器与客户端进行通信，这就是传说中的“中间人攻击”(man in the middle attack)。解决此问题的方法是通过受信任的第三方交换公钥，具体做法就是服务器不直接向客户端发送公钥，而是要求受信任的第三方，也就是证书认证机构 (Certificate Authority, 简称 CA) 将公钥合并到数字证书中，然后服务器会把公钥连同证书一起发送给客户端，私钥则由服务器自己保存以确保安全。数字证书一般包含以下内容：
- 证书所有者的公钥
- 证书所有者的专有名称
- 证书颁发机构的专有名称
- 证书的有效起始日期
- 证书的过期日期
- 证书数据格式的版本号
- 序列号，这是证书颁发机构为该证书分配的唯一标识符
- ... ...

#### 数字签名 (digital signature)
这个概念很好理解，其实跟人的手写签名类似，是为了确保数据发送者的合法身份，也可以确保数据内容未遭到篡改，保证数据完整性。与手写签名不同的是，数字签名会随着文本数据的变化而变化。具体到数字证书的应用场景，数字签名的生成和验证流程如下：
- 服务器对证书内容进行信息摘要计算 (常用算法有 SHA-256 等)，得到摘要信息，再用私钥把摘要信息加密，就得到了数字签名
- 服务器把数字证书连同数字签名一起发送给客户端
- 客户端用公钥解密数字签名，得到摘要信息
- 客户端用相同的信息摘要算法重新计算证书摘要信息，然后对这两个摘要信息进行比对，如果相同，则说明证书未被篡改，否则证书验证失败

#### 证书链 (certificate chain)
证书链，也称为证书路径，是用于认证实体合法身份的证书列表，具体到 HTTPS 通信中，就是为了验证服务器的合法身份。之所以使用证书链，是为了保证根证书 (root CA certificate) 的安全，中间层可以看做根证书的代理，起到了缓冲的作用。证书链从根证书开始，并且证书链中的每一级证书所标识的实体都要为其下一级证书签名，而根证书自身则由证书颁发机构签名。客户端在验证证书链时，必须对链中所有证书的数字签名进行验证，直到达到根证书为止。

#### 密码规范和密码组合 (CipherSpecs 和 CipherSuites)
通信双方在安全连接中所使用的算法必须符合密码安全协议的规定，CipherSpecs 和 CipherSuites 正好定义了合法的密码算法组合。CipherSpecs 用于认证加密算法和信息摘要算法的组合，通信双方必须同意这个密码规范才能进行通信。而 CipherSuites 则定义了 SSL / TLS 安全连接中所使用的加密算法的组合，该组合包含三种不同的算法：
- 握手期间所使用的密钥交换和认证算法 (最常用的是 RSA 算法)
- 加密算法 (用于握手完成后的对称加密，常用的有 AES、3DES 等)
- 信息摘要算法 (常用的有 SHA-256、SHA-1 和 MD5 等)

## 2.DNS 域名解析的整个过程

### 什么是 DNS 域名解析
我们首先要了解域名和 IP 地址的区别。IP 地址是互联网上计算机唯一的逻辑地址，通过 IP 地址实现不同计算机之间的相互通信，每台联网计算机都需要通过 IP 地址来互相联系和分别。

但由于 IP 地址是由一串容易混淆的数字串构成，人们很难记忆所有计算机的 IP 地址，这样对于我们日常工作生活访问不同网站是很困难的。基于这种背景，人们在 IP 地址的基础上又发展出了一种更易识别的符号化标识，这种标识由人们自行选择的字母和数字构成，相比 IP 地址更易被识别和记忆，逐渐代替 IP 地址成为互联网用户进行访问互联的主要入口。这种符号化标识就是域名。

域名虽然更易被用户所接受和使用，但计算机只能识别纯数字构成的 IP 地址，不能直接读取域名。因此要想达到访问效果，就需要将域名翻译成 IP 地址。而 DNS 域名解析承担的就是这种翻译效果。

### 2.DNS 域名解析过程
当我们在浏览器地址栏中输入 `www.baidu.com` 时，DNS 解析将会有将近 10 个步骤，这个过程大体由一张图可以表示：

整个过程大体描述如下，其中前两个步骤是在本地电脑内完成的，后 8 个步骤涉及到真正的域名解析服务器：

1. **第一步**：本地电脑会检查浏览器缓存中有没有这个域名对应的解析过的 IP 地址，如果缓存中有，这个解析过程就结束。浏览器缓存域名也是有限制的，不仅浏览器缓存大小有限制，而且缓存的时间也有限制，通常情况下为几分钟到几小时不等，域名被缓存的时间限制可以通过 TTL 属性来设置。这个缓存时间太长和太短都不太好，如果时间太长，一旦域名被解析到的 IP 有变化，会导致被客户端缓存的域名无法解析到变化后的 IP 地址，以致该域名不能正常解析，这段时间内有一部分用户无法访问网站。如果设置时间太短，会导致用户每次访问网站都要重新解析一次域名。

2. **第二步**：如果浏览器缓存中没有数据，浏览器会查找操作系统缓存中是否有这个域名对应的 DNS 解析结果。其实操作系统也有一个域名解析的过程，在 Linux 中可以通过 `/etc/hosts` 文件来设置，而在 windows 中可以通过配置 `C:\Windows\System32\drivers\etc\hosts` 文件来设置，用户可以将任何域名解析到任何能够访问的 IP 地址。例如，我们在测试时可以将一个域名解析到一台测试服务器上，这样不用修改任何代码就能测试到单独服务器上的代码的业务逻辑是否正确。正是因为有这种本地 DNS 解析的规程，所以有黑客就可能通过修改用户的域名来把特定的域名解析到他指定的 IP 地址上，导致这些域名被劫持。

3. **第三步**：前两个过程无法解析时，就要用到我们网络配置中的 "DNS 服务器地址" 了。操作系统会把这个域名发送给这个本地 DNS 服务器。每个完整的内网通常都会配置本地 DNS 服务器，例如用户是在学校或工作单位接入互联网，那么用户的本地 DNS 服务器肯定在学校或工作单位里面。它们一般都会缓存域名解析结果，当然缓存时间是受到域名的失效时间控制的。大约 80% 的域名解析到这里就结束了，后续的 DNS 迭代和递归也是由本地 DNS 服务器负责。

   - Windows 配置：控制面板 → 网络和共享中心 → 更改适配器设置 → 选中目标适配器右键选择属性 → Internet 协议版本 4 (TCP/IPv4) → 配置 DNS 地址。
   - Linux 设置：`/etc/resolv.conf`

4. **第四步**：如果本地 DNS 服务器仍然没有命中，就直接到根 DNS 服务器请求解析。

5. **第五步**：根 DNS 服务器返回给本地 DNS 域名服务器一个顶级 DNS 服务器地址，它是国际顶级域名服务器，如 .com、.cn、.org 等，全球只有 13 台左右。

6. **第六步**：本地 DNS 服务器再向上一步获得的顶级 DNS 服务器发送解析请求。

7. **第七步**：接受请求的顶级 DNS 服务器查找并返回此域名对应的 Name Server 域名服务器的地址，这个 Name Server 服务器就是我要访问的网站域名提供商的服务器，其实该域名的解析任务就是由域名提供商的服务器来完成。比如我要访问 `www.baidu.com`，而这个域名是从 A 公司注册获得的，那么 A 公司上的服务器就会有 `www.baidu.com` 的相关信息。

8. **第八步**：Name Server 服务器会查询存储的域名和 IP 的映射关系表，再把查询出来的域名和 IP 地址等等信息，连同一个 TTL 值返回给本地 DNS 服务器。

9. **第九步**：返回该域名对应的 IP 和 TTL 值，本地 DNS 服务器会缓存这个域名和 IP 的对应关系，缓存时间由 TTL 值控制。

10. **第十步**：把解析的结果返回给本地电脑，本地电脑根据 TTL 值缓存在本地系统缓存中，域名解析过程结束。在实际的 DNS 解析过程中，可能还不止这 10 步，如 Name Server 可能有很多级，或者有一个 GTM 来负载均衡控制，这都有可能会影响域名解析过程。

### 递归查询和迭代查询的区别
- **DNS 递归名称解析**：在 DNS 递归名称解析中，当所配置的本地名称服务器解析不了时，后面的查询工作是由本地名称服务器替代 DNS 客户端进行的（以“本地名称服务器”为中心），只需要本地名称服务器向 DNS 客户端返回最终的查询结果即可。
- **DNS 迭代名称解析**（或者叫“迭代查询”）：的所有查询工作全部是 DNS 客户端自己进行（以“DNS 客户端”自己为中心）。在条件之一满足时就会采用迭代名称解析方式：
  - 在查询本地名称服务器时，如果客户端的请求报文中没有申请使用递归查询，即在 DNS 请求报头部的 RD 字段没有置 1。相当于说“你都没有主动要求我为你进行递归查询，我当然不会为你工作了”。
  - 客户端在 DNS 请求报文中申请使用的是递归查询（也就是 RD 字段置 1 了），但在所配置的本地名称服务器上是禁用递归查询（DNS 服务器一般默认支持递归查询的），即在应答 DNS 报文头部的 RA 字段置 0。

DNS 客户端和本地名称服务器是递归，而本地名称服务器和其他名称服务器之间是迭代。

### 域名解析记录
主要分为 A 记录、MX 记录、CNAME 记录、NS 记录和 TXT 记录：

1. **A 记录**：A 代表 Address，用来指定域名对应的 IP 地址，如将 `item.taobao.com` 指定到 `115.238.23.xxx`，将 `switch.taobao.com` 指定到 `121.14.24.xxx`。A 记录可以将多个域名解析到一个 IP 地址，但是不能将一个域名解析到多个 IP 地址。

2. **MX 记录**：Mail Exchange，就是可以将某个域名下的邮件服务器指向自己的 Mail Server，如 `taobao.com` 域名的 A 记录 IP 地址是 `115.238.25.xxx`，如果将 MX 记录设置为 `115.238.25.xxx`，即 `xxx@taobao.com` 的邮件路由，DNS 会将邮件发送到 `115.238.25.xxx` 所在的服务器，而正常通过 Web 请求的话仍然解析到 A 记录的 IP 地址。

3. **CNAME 记录**：Canonical Name，即别名解析。所谓别名解析就是可以为一个域名设置一个或者多个别名，如将 `aaa.com` 解析到 `bbb.net`、`ccc.com` 也解析到 `bbb.net`，其中 `bbb.net` 分别是 `aaa.com` 和 `ccc.com` 的别名。

4. **NS 记录**：为某个域名指定 DNS 解析服务器，也就是这个域名由指定的 IP 地址的 DNS 服务器取解析。

5. **TXT 记录**：为某个主机名或域名设置说明，如可以为 `ddd.net` 设置 TXT 记录为 "这是 XXX 的博客" 这样的说明。

## 3.TCP 三次握手和四次挥手的详细过程，解释其中的关键字段

| ***\*步骤\**** | ***\*发送方\**** | ***\*包类型\**** | ***\*关键字段\****           | ***\*接收方状态变化\****  |
| -------------- | ---------------- | ---------------- | ---------------------------- | ------------------------- |
| 1              | 客户端A          | SYN              | SYN=1, seq=x                 | SYN_SENT → (等)           |
| 2              | 服务器B          | SYN+ACK          | SYN=1, ACK=1, seq=y, ack=x+1 | SYN_RCVD → (等)           |
| 3              | 客户端A          | ACK              | ACK=1, seq=x+1, ack=y+1      | ESTABLISHED ← ESTABLISHED |

| ***\*步骤\**** | ***\*发送方\**** | ***\*包类型\**** | ***\*关键字段\****           | ***\*接收方状态变化\**** |
| -------------- | ---------------- | ---------------- | ---------------------------- | ------------------------ |
| 1              | 客户端A          | FIN              | FIN=1, seq=u                 | FIN_WAIT_1 → FIN_WAIT_2  |
| 2              | 服务器B          | ACK              | ACK=1, ack=u+1               | CLOSE_WAIT → (继续)      |
| 3              | 服务器B          | FIN+ACK          | FIN=1, ACK=1, seq=v, ack=u+1 | LAST_ACK → CLOSED        |
| 4              | 客户端A          | ACK              | ACK=1, ack=v+1               | TIME_WAIT → CLOSED       |

## UDP “直接发” 如何知道发给谁、谁该接收、接收到的信息来自哪里

哈哈，这个疑问超级好！很多人以为 UDP “乱扔包”，其实它靠 IP 地址 + 端口号的“双标签系统”精准定位，就像寄信用“邮编 + 门牌号”。UDP 无连接，但不等于“无地址”——它借用网络层（IP）和应用层（端口）的力量，确保包“知道去哪、从哪来”。我们一步步拆过程。

### UDP 报文结构回顾（头仅 8 字节，简单粗暴）
- **源端口（2 字节）**：发包的应用进程 ID（e.g., 12345）。
- **目的端口（2 字节）**：收包的应用进程 ID（e.g., 53=DNS）。
- **长度（2 字节）**：整个数据报大小。
- **校验和（2 字节）**：简单错误检查（可选）。

### 发送过程：怎么知道“发给谁”？
- **应用层生成数据**：比如，浏览器要查 DNS，应用层（DNS 协议）生成查询消息：“www.baidu.com 的 IP？”。
- **加 UDP 头**：传输层加头——源端口（浏览器随机端口，如 5353）、目的端口（DNS 标准 53）。数据 = UDP 头 + 应用数据。
- **交给 IP 层**：网络层加 IP 头——源 IP（你的 IP，如 192.168.1.100）、目的 IP（DNS 服务器 IP，如 8.8.8.8）。
- **直接发**：整个“IP 包”（含 UDP）扔到网络接口层，通过路由器跳跃。无握手，无确认——“邮递员”只管投递，不管到没到。

**比喻**：你写明信片（UDP 数据），写上“寄给：北京 XX 路 53 号（目的 IP+端口）”，落款“来自：上海 YY 街 5353 号（源 IP+端口）”。邮局（IP 层）按地址转运，收方一看门牌（端口）知道给谁。

### 接收过程：怎么知道“谁该接收、来自哪里”？
- **网络层剥 IP 头**：包到你的主机，IP 层查目的 IP 匹配本地？是 → 交给传输层；否 → 丢。
- **传输层剥 UDP 头**：UDP 层查目的端口（e.g., 53） → 找对应应用进程（DNS 服务）。同时，源 IP+源端口告诉你“来自谁的哪个 App”。
- **应用层处理**：DNS 应用收到消息，知道来源（可回包到源 IP+源端口），处理后回。
- 如果端口无对应进程？OS 丢包或发 ICMP 错误。

### 关键点
- **发给谁**：目的 IP（主机）+目的端口（进程）。无连接，但每个包自带“坐标”。
- **谁接收**：主机收到后，端口号像“分机号”，直达正确 App（e.g., 80=HTTP 服务器）。
- **来自哪里**：源 IP+源端口，收方据此回复（e.g., DNS 回包用你的源端口作为目的端口）。

### 潜在问题
- 丢包？UDP 不管，重传靠应用（e.g., DNS 超时重问）。乱序？应用自己序。防火墙可滤端口防滥用。

### 示例
玩游戏 UDP 发“位置更新”——源：你的 IP+游戏端口 1234；目的：服务器 IP+游戏端口 7777。服务器收到，知道“玩家 X 从 IP Y 发来”，回包到你的坐标。快！但网抖=丢帧。

## 4.TCP 的重传机制

重传包括超时重传、快速重传、带选择确认的重传（SACK）、重复 SACK 四种。

### 超时重传
超时重传，是 TCP 协议保证数据可靠性的另一个重要机制，其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的 ACK 报文，那么就重新发送数据，直到发送成功为止。

#### 超时时间设置
- **RTT**：就是数据完全发送完，到收到确认信号的时间，即数据包的一次往返时间。
- **超时重传时间**：就是 RTO（Retransmission Timeout）。那么，RTO 到底设置多大呢？
  - 如果 RTO 设置很大，等了很久都没重发，这样肯定就不行。
  - 如果 RTO 设置很小，那很可能数据都没有丢失，就开始重发了，这会导致网络阻塞，从而恶性循环，导致更多的超时出现。
- 一般来说，RTO 略微大于 RTT，效果是最佳的。

其实，RTO 有个标准方法的计算公式，也叫 Jacobson / Karels 算法。
1. 首先计算 SRTT（即计算平滑的 RTT）  
   SRTT = (1 - α) * SRTT + α * RTT // 求 SRTT 的加权平均  
   （这一次的 SRTT 是上一次的 SRTT 与这一次的 RTT 计算得来，初始 SRTT 等于 RTT）

2. 其次，计算 RTTVAR (round-trip time variation)  
   RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|) // 计算 SRTT 与真实值的差距

3. 最后，得出最终的 RTO  
   RTO = µ * SRTT + ∂ * RTTVAR = SRTT + 4·RTTVAR  
   在 Linux 下，α = 0.125，β = 0.25， μ = 1，∂ = 4。别问这些参数是怎么来的，它们是大量实践，调出的最优参数。

#### 超时重传的缺点
- 当一个报文丢失时，会等待一定的超时周期，才重传分组，增加了端到端的时延。
- 当一个报文丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。
- 并且，对于 TCP，如果发生一次超时重传，时间间隔下次就会加倍。

### 快速重传
TCP 还有另外一种快速重传（Fast Retransmit）机制，它不以时间为驱动，而是以数据驱动重传。它是基于接收端的反馈信息来引发重传的。可以用它来解决超时重发的时间等待问题，快速重传流程如下：

在上图，发送方发出了 1，2，3，4，5 份数据：
- 第一份 Seq1 先送到了，于是就 Ack 回 2；
- 结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；
- 后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；
- 发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。
- 最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。

快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传之前的⼀个，还是重传所有的问题。  
比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。  
根据 TCP 不同的实现，以上两种情况都是有可能的。可⻅，这是一把双刃剑。  
为了解决不知道该重传哪些 TCP 报⽂，于是就有 SACK ⽅法。

### SACK（Selective Acknowledgment，选择确认）
#### 一、传统 TCP ACK 的局限性
先复习下普通的 ACK 是怎么工作的：  
假设发送端连续发送了 5 个包：  
`[1][2][3][4][5]`  
如果包 3 丢失，接收方收到：  
✅1 ✅2 ❌3 ✅4 ✅5  
接收方会发送：  
ACK = 3  
ACK = 3  
ACK = 3  
ACK = 3 ...  
表示“我希望从 3 开始的数据”。  
👉 但它并不能告诉发送方：我其实已经收到了 4、5。  
结果：  
- 发送方只能根据重复 ACK 猜测“也许 3 丢了”，触发快速重传；  
- 可是一旦丢的不止一个包（例如丢 3 和 4），事情就复杂了；  
- 发送方不知道哪些数据已经收到、哪些没收到，只能笼统地重传多个包，效率低。

#### 二、SACK 的工作原理
目标：让接收方告诉发送方——我具体收到了哪些片段。  

SACK 是 TCP 选项的一种扩展字段，由接收方在 ACK 报文中携带：  
每个 SACK 块表示一个已收到的数据范围：  
SACK = [Left Edge, Right Edge)  

举例：  
假设：  
丢失情况：包 3 丢了，但包 4、5 收到了  
接收方发送：  
ACK = 3  
SACK = [4,6)  
意思是：  
“我希望从 3 开始的数据（即包 3）；  
但我其实已经收到了 4 和 5。”  

发送方收到 SACK 后会：  
- 知道哪些数据已经被确认；  
- 只重传“未被确认”的那部分（例如包 3），不再重复发送包 4、5。  
这样就极大提升了网络利用率，尤其在高丢包或长延迟环境下。

#### 三、SACK 机制图解
发送端：  [1][2][3][4][5]  
接收端收到：  1,2,4,5  
接收端回复： ACK=3 + SACK=[4,6)  
发送端得知：3 丢失，4~5 已收，重传 3 即可。

### DSACK（Duplicate SACK，重复选择确认）
#### 1️⃣ 出现背景
SACK 能告诉发送方“哪些收到了”，  
但有时候 发送方会误以为某个包丢了（例如乱序造成重复 ACK），从而多重传了一次。  
为了让发送方知道自己“白白重传了”，就有了 DSACK。

#### 2️⃣ DSACK 的工作原理
接收方在检测到“重复的数据段”时，会在 SACK 选项中携带重复的区间。  

例子：  
发送方发出： [1][2][3][4]  
包 2 乱序晚到  
接收方先收到：1,3,4  
→ 回复 ACK=2 + SACK=[3,5)  
发送方误以为包 2 丢失 → 重传 2  
稍后包 2 原本的副本也到了  
接收方现在收到重复的包 2  
→ 回复 DSACK = [2,3)  
意思是：  
“我收到了重复的 [2,3) 这段数据。”  

发送方看到 DSACK，就知道：  
啊，原来我重传的包 2 其实早已送达；  
所以网络中可能只是乱序而不是丢包。

#### TCP 发送方根据 DSACK 的实际行为
TCP 发送方确实会根据 DSACK 调整之后的行为。  
它不会仅仅“知道错了”，而是会据此修正自己的网络判断模型。  

TCP 发送方在整个连接期间，会持续做三件事：  
这些算法全都依赖于一个假设：  
“重复 ACK 代表丢包。”  
但现实中，这个假设有时是错的（例如包乱序）。  
于是，DSACK 提供了一种“反馈纠正机制”。  

实际行为（以 Linux TCP 为例）：  
- 检测到 DSACK 后，内核会认为最近的“丢包”其实是误判；  
- 内核记录一次“spurious retransmission（虚假重传）”；  
- 如果连续发生这种情况，TCP 会：  
  - 增加乱序容忍度；  
  - 延长重传超时时间 RTO；  
  - 调整触发快速重传的阈值；  
  - 在某些实现中，还会恢复 cwnd（称为 DSACK-based cwnd undo）。  

换句话说：  
TCP 会逐步“学会”这个网络有点乱，  
不要一看到重复 ACK 就惊慌地减速。

## 5.HTTP 协议版本的发展过程，每一次改进了什么方面？目前常用的 HTTP 协议是什么？

### HTTP 协议版本发展概述
HTTP 协议从 0.9 版本开始演进，每一版都针对性能、安全和功能进行优化。

#### HTTP/0.9（1991）
🌱 “最原始的 HTTP，只能拿文本。”  
**特点**：  
- 只有一个命令：GET  
- 无请求头、无响应头  
- 只能传输 HTML 文本  
- 连接：一次请求一个 TCP 连接，完毕即断开  

示例：  
GET /index.html  
<html>...</html>  

**问题**：  
- 无法传输图片、音频、视频等多媒体内容  
- 无法区分内容类型、编码  
- 无缓存机制、无状态控制  

#### HTTP/1.0（1996）
🌿 “现代 Web 的雏形。”  
**改进**：  

- 增加请求头和响应头（允许携带元信息）  
- 支持 Content-Type, User-Agent, Status Code 等  
- 支持多媒体类型传输  
- 可传输图片、音频等  
- 引入缓存机制  
  - 使用 Expires、Last-Modified 等头  
- 增加状态码（如 404, 500）  
- 每次请求仍需重新建立 TCP 连接  

**问题**：  
- TCP 连接频繁建立/断开 → 性能低  
- 服务器无法区分同一 IP 下多个站点（虚拟主机）  

#### HTTP/1.1（1997）
🌾 “真正的主流标准版本”，至今仍然大量使用。  
**重大改进**：  
- **持久连接（Persistent Connection）**  
  - 默认 Connection: keep-alive  
  - 同一 TCP 连接可发送多个请求（减少握手开销）  
- **管线化（Pipelining）**  
  - 允许在一个连接上并行发送多个请求（但响应仍需按顺序返回）  
  - 实际上由于“队头阻塞”问题（Head-of-line blocking）→ 很少被用  
- **引入 Host 头**  
  - Host: www.example.com  
  - 支持虚拟主机（一个服务器多个域名）  
- **缓存优化**  
  - Cache-Control, ETag, If-Modified-Since  
- **分块传输编码（Chunked Transfer Encoding）**  
  - 支持流式传输，不必提前知道数据长度  
- **更多方法支持**  
  - 如 PUT、DELETE、OPTIONS 等  

**问题**：  
- 多个请求仍在同一 TCP 流中排队（队头阻塞）  
- 头部体积越来越大（无压缩）  
- 并发性能差（需多 TCP 连接）  

#### HTTP/2（2015，RFC 7540）
🌲 “性能革命版本”，解决 HTTP/1.1 的关键性能瓶颈。  
**核心改进**：  
- **二进制分帧（Binary Framing）**  
  - 请求与响应被分为独立的二进制帧，减少解析成本  
- **多路复用（Multiplexing）**  
  - 在一个 TCP 连接上并行传输多个请求/响应流（无队头阻塞）  
- **头部压缩（HPACK）**  
  - 减少重复的 HTTP 头传输成本  
- **服务器推送（Server Push）**  
  - 服务端可主动推送资源（如 CSS、JS）  
- **优先级和依赖机制**  
  - 客户端可指定流的优先级以优化加载顺序  

**问题**：  
- 仍基于 TCP → 一旦丢包，仍然存在底层队头阻塞（HOL）  

#### HTTP/3（2022，RFC 9114）
🚀 “新时代的 HTTP”，基于 QUIC（UDP）。  
**关键创新**：  
- **基于 QUIC 协议（UDP 之上）**  
  - 内建加密（TLS 1.3）  
  - 消除了 TCP 队头阻塞问题  
  - 更快的连接建立（0-RTT）  
  - 多路复用无阻塞  
  - 各请求独立传输，即使丢包也不影响其他流  
- **更快的握手**  
  - 第一次通信仅需 1-RTT（甚至 0-RTT）  
- **内置加密**  
  - 不再区分 HTTP 与 HTTPS  
- **迁移能力强**  
  - QUIC 的连接可在 IP 变化（如 Wi-Fi → 5G）后保持  

**现状**：  
- 已被 Chrome、Firefox、Edge 等主流浏览器支持  
- 大型网站（Google、Facebook、Cloudflare）已普及  

### 目前最常用的 HTTP 版本
当前主流：**HTTP/1.1 与 HTTP/2 共存**  
- 浏览器默认使用 HTTP/2（若服务器支持）  
- 不支持 HTTP/2 的服务器则自动回退至 HTTP/1.1  
- **HTTP/3 正在快速普及中**  
  - 大多数现代浏览器和 CDN 已支持  
  - 预计未来几年成为主流