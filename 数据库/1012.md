# SQL 和 MySQL 学习笔记

## MySQL 常用命令

### 1️⃣ 登录与退出
- `mysql -u 用户名 -p`        # 登录 MySQL（输入密码）
- `mysql -h 主机名 -u 用户名 -p`  # 远程登录
- `exit;`                     # 或者 `\q` 退出

### 2️⃣ 数据库操作（DDL）
- `SHOW DATABASES;`                          -- 查看所有数据库
- `CREATE DATABASE testdb;`                  -- 创建数据库
- `CREATE DATABASE testdb`  
  `DEFAULT CHARACTER SET utf8mb4`  
  `COLLATE utf8mb4_general_ci;`            -- 指定字符集与排序规则
- `USE testdb;`                              -- 选择数据库
- `DROP DATABASE testdb;`                    -- 删除数据库  
  （使用 `IF NOT EXISTS` 和 `IF EXISTS` 保险）

### 3️⃣ 表结构操作（DDL）

#### ✅ 创建表
```sql
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    birthdate DATE,
    is_active BOOLEAN DEFAULT TRUE
);
```
**实例解析**：  
- `id`：用户 id，整数类型，自增长，作为主键。  
- `username`：用户名，变长字符串，不允许为空。  
- `email`：用户邮箱，变长字符串，不允许为空。  
- `birthdate`：用户的生日，日期类型。  
- `is_active`：用户是否已经激活，布尔类型，默认值为 `true`。  

如果你希望在创建表时指定数据引擎、字符集和排序规则等，可以使用 `CHARACTER SET` 和 `COLLATE` 子句：  
```sql
CREATE TABLE mytable (
    id INT PRIMARY KEY,
    name VARCHAR(50)
) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
```

以下例子中我们将在 RUNOOB 数据库中创建数据表 `runoob_tbl`：  
```sql
CREATE TABLE IF NOT EXISTS `runoob_tbl`(
   `runoob_id` INT UNSIGNED AUTO_INCREMENT,
   `runoob_title` VARCHAR(100) NOT NULL,
   `runoob_author` VARCHAR(40) NOT NULL,
   `submission_date` DATE,
   PRIMARY KEY ( `runoob_id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
```
**实例解析**：  
- 如果不想字段为空可以设置字段的属性为 `NOT NULL`，如上实例中的 `runoob_title` 与 `runoob_author` 字段，在操作数据库时如果输入该字段的数据为空，就会报错。  
- `AUTO_INCREMENT` 定义列为自增的属性，一般用于主键，数值会自动加 1。  
- `PRIMARY KEY` 关键字用于定义列为主键。您可以使用多列来定义主键，列间以逗号 `,` 分隔。  
- `ENGINE` 设置存储引擎，`CHARSET` 设置编码。

#### ✅ 查看/修改表结构
- `SHOW TABLES;`                -- 查看当前数据库的所有表
- `DESC students;`              -- 查看表结构
- `SHOW CREATE TABLE students;` -- 查看建表 SQL 语句
- `ALTER TABLE students ADD COLUMN address VARCHAR(100);`  -- 增加列
- `ALTER TABLE students MODIFY COLUMN age TINYINT;`        -- 修改列
- `ALTER TABLE students DROP COLUMN score;`                -- 删除列
- `ALTER TABLE students RENAME TO users;`                  -- 重命名表

#### ✅ 删除表
- `DROP TABLE students;`

### 4️⃣ 数据操作（DML）

#### 插入数据
```sql
INSERT INTO table_name (column1, column2, column3, ...)
VALUES (value1, value2, value3, ...);
```
**参数说明**：  
- `table_name` 是你要插入数据的表的名称。  
- `column1, column2, column3, ...` 是表中的列名。  
- `value1, value2, value3, ...` 是要插入的具体数值。  
- 如果数据是字符型，必须使用单引号 `'` 或者双引号 `"`，如：`'value1', "value1"`。  

示例：  
```sql
INSERT INTO students (name, age, gender, score)
VALUES ('Alice', 20, '女', 95.5);
```

如果你要插入所有列的数据，可以省略列名：  
```sql
INSERT INTO users
VALUES (NULL,'test', 'test@runoob.com', '1990-01-01', true);
```
这里，`NULL` 是用于自增长列的占位符，表示系统将为 `id` 列生成一个唯一的值。

**批量插入**：  
```sql
INSERT INTO students (name, age, gender, score)
VALUES
  ('Bob', 22, '男', 88.0),
  ('Cathy', 19, '女', 92.3);
```

#### 更新数据
```sql
UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;
```
**参数说明**：  
- `table_name` 是你要更新数据的表的名称。  
- `column1, column2, ...` 是你要更新的列的名称。  
- `value1, value2, ...` 是新的值，用于替换旧的值。  
- `WHERE condition` 是一个可选的子句，用于指定更新的行。如果省略 `WHERE` 子句，将更新表中的所有行。  

**更多说明**：  
- 你可以同时更新一个或多个字段。  
- 你可以在 `WHERE` 子句中指定任何条件。  
- 你可以在一个单独表中同时更新数据。  
- 当你需要更新数据表中指定行的数据时 `WHERE` 子句是非常有用的。  

**实例**：  
1. 更新单个列的值：  
   ```sql
   UPDATE employees
   SET salary = 60000
   WHERE employee_id = 101;
   ```

2. 更新多个列的值：  
   ```sql
   UPDATE orders
   SET status = 'Shipped', ship_date = '2023-03-01'
   WHERE order_id = 1001;
   ```

3. 使用表达式更新值：  
   ```sql
   UPDATE products
   SET price = price * 1.1
   WHERE category = 'Electronics';
   ```
   以上 SQL 语句将每个属于 'Electronics' 类别的产品的价格都增加了 10%。

4. 更新符合条件的所有行：  
   ```sql
   UPDATE students
   SET status = 'Graduated';
   ```
   以上 SQL 语句将所有学生的状态更新为 'Graduated'。

5. 更新使用子查询的值：  
   ```sql
   UPDATE customers
   SET total_purchases = (
       SELECT SUM(amount)
       FROM orders
       WHERE orders.customer_id = customers.customer_id
   )
   WHERE customer_type = 'Premium';
   ```
   以上 SQL 语句通过子查询计算每个 'Premium' 类型客户的总购买金额，并将该值更新到 `total_purchases` 列中。

#### 删除数据
```sql
DELETE FROM table_name
WHERE condition;
```
**参数说明**：  
- `table_name` 是你要删除数据的表的名称。  
- `WHERE condition` 是一个可选的子句，用于指定删除的行。如果省略 `WHERE` 子句，将删除表中的所有行。  

**更多说明**：  
- 如果没有指定 `WHERE` 子句，MySQL 表中的所有记录将被删除。  
- 你可以在 `WHERE` 子句中指定任何条件。  
- 您可以在单个表中一次性删除记录。  
- 当你想删除数据表中指定的记录时 `WHERE` 子句是非常有用的。  

**实例**：  
1. 删除符合条件的行：  
   ```sql
   DELETE FROM students
   WHERE graduation_year = 2021;
   ```
   以上 SQL 语句删除了 `students` 表中所有 `graduation_year` 为 2021 的学生的记录。

2. 删除所有行：  
   ```sql
   DELETE FROM orders;
   ```
   以上 SQL 语句删除了 `orders` 表中的所有记录，但表结构保持不变。

3. 使用子查询删除符合条件的行：  
   ```sql
   DELETE FROM customers
   WHERE customer_id IN (
       SELECT customer_id
       FROM orders
       WHERE order_date < '2023-01-01'
   );
   ```
   以上 SQL 语句通过子查询删除了 `orders` 表中在 '2023-01-01' 之前下的订单对应的客户。

- `DELETE FROM students WHERE id = 3;`  
- `TRUNCATE TABLE students;`  -- 清空整个表（比 DELETE 更快，清空数据但保留表结构）

### 5️⃣ 查询数据（DQL）
```sql
SELECT column1, column2, ...
FROM table_name
[WHERE condition]
[ORDER BY column_name [ASC | DESC]]
[LIMIT number];
```
**参数说明**：  
- `column1, column2, ...` 是你想要选择的列的名称，如果使用 `*` 表示选择所有列。  
- `table_name` 是你要从中查询数据的表的名称。  
- `WHERE condition` 是一个可选的子句，用于指定过滤条件，只返回符合条件的行。  
- `ORDER BY column_name [ASC | DESC]` 是一个可选的子句，用于指定结果集的排序顺序，默认是升序（ASC）。  
- `LIMIT number` 是一个可选的子句，用于限制返回的行数。  

**MySQL SELECT 语句简单的应用实例**：  
- `-- 选择所有列的所有行`  
  `SELECT * FROM users;`  
- `-- 选择特定列的所有行`  
  `SELECT username, email FROM users;`  
- `-- 添加 WHERE 子句，选择满足条件的行`  
  `SELECT * FROM users WHERE is_active = TRUE;`  
- `-- 添加 ORDER BY 子句，按照某列的升序排序`  
  `SELECT * FROM users ORDER BY birthdate;`  
- `-- 添加 ORDER BY 子句，按照某列的降序排序`  
  `SELECT * FROM users ORDER BY birthdate DESC;`  
- `-- 添加 LIMIT 子句，限制返回的行数`  
  `SELECT * FROM users LIMIT 10;`

#### 基本查询
- `SELECT * FROM students;`  
- `SELECT name, score FROM students WHERE gender='女';`

#### 条件查询
- `SELECT * FROM students WHERE age > 18 AND score >= 90;`

#### 模糊查询（LIKE）
- `SELECT * FROM students WHERE name LIKE 'A%';`  -- A 开头  
- `SELECT * FROM students WHERE name LIKE '%e';`  -- e 结尾  

**✅ % 与 _ 是两个“通配符”**  
不区分大小写的匹配：  
`SELECT * FROM employees WHERE last_name LIKE 'smi%' COLLATE utf8mb4_general_ci;`  

**LIKE 子句提供了强大的模糊搜索能力**，可以根据不同的模式和需求进行定制。在使用时，请确保理解通配符的含义，并根据实际情况进行匹配。  

以下是一些进阶的 SELECT 语句实例：  
- `-- 使用 AND 运算符和通配符`  
  `SELECT * FROM users WHERE username LIKE 'j%' AND is_active = TRUE;`  
- `-- 使用 OR 运算符`  
  `SELECT * FROM users WHERE is_active = TRUE OR birthdate < '1990-01-01';`  
- `-- 使用 IN 子句`  
  `SELECT * FROM users WHERE birthdate IN ('1990-01-01', '1992-03-15', '1993-05-03');`

#### 排序
- `SELECT * FROM students ORDER BY score DESC, age ASC;`  

**✅ 含义**：对查询结果按指定字段进行排序。

#### 限制行数
- `SELECT * FROM students LIMIT 5;`          -- 取前 5 条  
- `SELECT * FROM students LIMIT 5 OFFSET 10;`-- 从第 11 条开始取 5 条

#### 分组与聚合
```sql
SELECT gender, AVG(score) AS avg_score
FROM students
GROUP BY gender
HAVING avg_score > 90;  -- 分组后的过滤
```
**✅ GROUP BY 含义**：将查询结果按某列分组统计，常与聚合函数一起使用。  

**⚙️ 示例**：  
```sql
SELECT gender, COUNT(*) AS num_students
FROM students
GROUP BY gender;
```

**⚙️ 示例**：  
`SELECT gender,COUNT(*)AS num_studentsFROM studentsGROUPBY gender;`

**✅ HAVING 含义**：对分组后的结果再进行过滤（类似于 WHERE，但作用于分组之后）。

### 6️⃣ 多表操作（JOIN）

#### 内连接
```sql
SELECT s.name, c.course_name
FROM students s
JOIN courses c ON s.id = c.student_id;
```

**🔗 5️⃣ JOIN —— 多表连接查询**  

**✅ (1) 内连接（INNER JOIN）**  
```sql
SELECT s.name, c.course_name
FROM students s
JOIN courses c ON s.id = c.student_id;
```
**含义**：只返回两张表中匹配成功的行。  
→ 当 `students.id = courses.student_id` 时，数据匹配成功才出现在结果中。

#### 左外连接（LEFT JOIN）
```sql
SELECT s.name, c.course_name
FROM students s
LEFT JOIN courses c ON s.id = c.student_id;
```
**含义**：返回左表的全部数据，即使右表没有匹配，也会显示（右表内容显示 NULL）。  

**📘 类比**：  
左表是“学生名单”，右表是“选课名单”。  
内连接：只显示有选课的学生。  
左外连接：显示所有学生，没有选课的学生课程为 NULL。

#### ✅ (3) 右外连接（RIGHT JOIN）
```sql
SELECT s.name, c.course_name
FROM students s
RIGHT JOIN courses c ON s.id = c.student_id;
```
**含义**：返回右表的全部数据，即使左表没有匹配，也会显示（左表字段显示 NULL）。

#### 自连接
```sql
SELECT a.name AS A, b.name AS B
FROM employees a, employees b
WHERE a.manager_id = b.id;
```

**✅ (4) 自连接（SELF JOIN）**  
表与自身连接，用于比较同一表中不同记录。  
```sql
SELECT a.name AS student1, b.name AS student2
FROM students a, students b
WHERE a.age = b.age AND a.id != b.id;
```
→ 查询所有同龄的不同学生。

### 7️⃣ 子查询
```sql
SELECT name, score
FROM students
WHERE score > (SELECT AVG(score) FROM students);
```
**✅ 含义**：括号中的查询称为“子查询”，会先执行。  
这里：  
`(SELECT AVG(score) FROM students)`  
计算所有学生的平均分，然后主查询返回成绩高于平均分的学生。

### 8️⃣ 视图（VIEW）
```sql
CREATE VIEW high_score AS
SELECT name, score FROM students WHERE score > 90;
SELECT * FROM high_score;
DROP VIEW high_score;
```
**✅ 含义**：视图是一个“虚拟表”，并不存储真实数据，而是保存了一个查询语句。  
之后你可以像操作表一样查询它：  
`SELECT * FROM high_score;`  
等价于：  
`SELECT name, score FROM students WHERE score > 90;`  

**✅ 优点**：  
- 代码更简洁  
- 可用于权限控制（让用户只能访问视图）  
- 简化复杂查询

### 9️⃣ 索引（INDEX）
- `CREATE INDEX idx_name ON students(name);`  
- `SHOW INDEX FROM students;`  
- `DROP INDEX idx_name ON students;`  

**✅ 含义**：索引是加速查询的结构，相当于书本的“目录”。  
有索引的字段，在查询时 MySQL 可以快速定位数据。  

**✅ 类比**：  
没有索引 → 从头翻页找  
有索引 → 直接查目录页码，快速跳转  

**✅ 注意**：  
- 提高查询速度  
- 但会降低插入、更新速度（因为索引要维护）  
- 不宜给所有字段都建索引

### 🔟 用户与权限（DCL）
- `CREATE USER 'user1'@'localhost' IDENTIFIED BY 'password123';`  
- `GRANT ALL PRIVILEGES ON testdb.* TO 'user1'@'localhost';`  
- `REVOKE INSERT ON testdb.* FROM 'user1'@'localhost';`  
- `FLUSH PRIVILEGES;`  -- 刷新权限  

**✅ 逐项解释**：  
（原笔记中未详细展开，此处保留标题以保持完整性）

## MySQL 中的数据结构，并举一些应该被设为该数据结构的实际现实生活例子

MySQL 的数据类型主要分为三大类：

### 一、数值类型（Numeric Types）
**✅ 举例对比**：  
（原笔记中未详细展开，此处保留标题以保持完整性）

### 二、字符串类型（String Types）
**✅ 举例对比**：  
（原笔记中未详细展开，此处保留标题以保持完整性）

### 三、日期与时间类型（Date & Time Types）
**✅ 举例对比**：  
（原笔记中未详细展开，此处保留标题以保持完整性）

### 四、JSON 类型（结构化数据）
```sql
CREATE TABLE user_profiles (
  id INT PRIMARY KEY,
  info JSON
);
INSERT INTO user_profiles VALUES
(1, '{"name": "Tom", "age": 22, "skills": ["C++", "MySQL"]}');
```
**✅ 优点**：  
- 可以存储结构化数据（类似 Python 字典或 JavaScript 对象）  
- 灵活，适合半结构化信息  
- 可用 JSON 函数直接查询字段内容  

**⚙️ 示例查询**：  
`SELECT info->>'$.name' FROM user_profiles;`  

**✅ 现实应用场景**：  

| 场景           | 使用理由                   |
| -------------- | -------------------------- |
| 用户自定义配置 | 每个人配置不同，结构不固定 |
| 电商商品属性   | 不同商品参数数量不同       |
| API 日志存储   | 请求体字段不固定           |
| 动态表单       | 字段数量与结构不稳定       |

## 外键是什么？

### 一、外键是什么（Foreign Key）
外键（Foreign Key）是用来**建立和强化两个表之间的联系**的约束。  

它的作用是：  
- 保证表与表之间的引用关系是合法的、一致的。  

**一句话解释**：  
外键就是“某个表中的字段，引用了另一个表的主键”。

### 🧱 二、举个具体例子
假设我们有两个表：  
① 学生表 `students`  
| id（主键） | name |
| ---------- | ---- |
| 1          | 小明 |
| 2          | 小红 |
| 3          | 小刚 |

```sql
CREATE TABLE students (
  id INT PRIMARY KEY,
  name VARCHAR(50)
);
```

② 成绩表 `scores`  
| score_id | student_id | score |
| -------- | ---------- | ----- |
| 1        | 1          | 95    |
| 2        | 2          | 87    |
| 3        | 3          | 78    |

```sql
CREATE TABLE scores (
  score_id INT PRIMARY KEY,
  student_id INT,
  score INT,
  FOREIGN KEY (student_id) REFERENCES students(id)
);
```

这里这行：  
`FOREIGN KEY (student_id) REFERENCES students(id)`  
就是定义了一个**外键约束**。

### 🔗 三、这句话的含义
这句话表示：  
- 表 `scores` 中的 `student_id` 字段，必须引用表 `students` 中存在的 `id` 值。  
- 也就是说：  
  - `scores.student_id = 1` ✅ 因为在 `students` 表中有 `id=1` 的学生；  
  - `scores.student_id = 99` ❌ 因为没有 `id=99` 的学生。  
- MySQL 会自动阻止这种不合法的数据插入。

### 💡 四、为什么需要外键
外键是为了解决数据库中的**数据一致性（Referential Integrity）**问题。  

没有外键约束时，你可能会出现这样的混乱：  
| score_id                         | student_id | score |
| -------------------------------- | ---------- | ----- |
| 1                                | 999        | 88    |
| → 但 `id=999` 的学生根本不存在！ |            |       |

这个“孤儿记录（orphan record）”会导致数据混乱，查询结果不可信。  
外键可以防止这种情况发生。

## UNION 语句如何使用？

### 描述
MySQL `UNION` 操作符用于连接两个以上的 `SELECT` 语句的结果组合到一个结果集合，并去除重复的行。  
`UNION` 操作符必须由两个或多个 `SELECT` 语句组成，每个 `SELECT` 语句的列数和对应位置的数据类型必须相同。

### 语法
MySQL `UNION` 操作符语法格式：  
```sql
SELECT column1, column2, ...
FROM table1
WHERE condition1
UNION
SELECT column1, column2, ...
FROM table2
WHERE condition2
[ORDER BY column1, column2, ...];
```
**参数说明**：  
- `column1, column2, ...` 是你要选择的列的名称，如果使用 `*` 表示选择所有列。  
- `table1, table2, ...` 是你要从中查询数据的表的名称。  
- `condition1, condition2, ...` 是每个 `SELECT` 语句的过滤条件，是可选的。  
- `ORDER BY` 子句是一个可选的子句，用于指定合并后的结果集的排序顺序。

### 实例
1. 基本的 `UNION` 操作：  
   ```sql
   SELECT city FROM customers
   UNION
   SELECT city FROM suppliers
   ORDER BY city;
   ```
   以上 SQL 语句将选择客户表和供应商表中所有城市的唯一值，并按城市名称升序排序。

2. 使用过滤条件的 `UNION`：  
   ```sql
   SELECT product_name FROM products WHERE category = 'Electronics'
   UNION
   SELECT product_name FROM products WHERE category = 'Clothing'
   ORDER BY product_name;
   ```
   以上 SQL 语句将选择电子产品和服装类别的产品名称，并按产品名称升序排序。

3. `UNION` 操作中的列数和数据类型必须相同：  
   ```sql
   SELECT first_name, last_name FROM employees
   UNION
   SELECT department_name, NULL FROM departments
   ORDER BY first_name;
   ```
   返回的结果包括了 `employees` 表中的 `first_name` 和 `last_name`，以及 `departments` 表中的 `department_name` 和 `NULL`，所有的结果都按照 `first_name` 列排序。

4. 使用 `UNION ALL` 不去除重复行：  
   ```sql
   SELECT city FROM customers
   UNION ALL
   SELECT city FROM suppliers
   ORDER BY city;
   ```
   以上 SQL 语句使用 `UNION ALL` 将客户表和供应商表中的所有城市合并在一起，不去除重复行。  

`UNION` 操作符在合并结果集时会去除重复行，而 `UNION ALL` 不会去除重复行，因此 `UNION ALL` 的性能可能更好，但如果你确实希望去除重复行，可以使用 `UNION`。

## ORDER BY 使用方法？ORDER BY（排序）语句

### 描述
我们知道从 MySQL 表中使用 `SELECT` 语句来读取数据。  
如果我们需要对读取的数据进行排序，我们就可以使用 MySQL 的 `ORDER BY` 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果。  
MySQL `ORDER BY`（排序）语句可以按照一个或多个列的值进行升序（ASC）或降序（DESC）排序。

### 语法
以下是 `SELECT` 语句使用 `ORDER BY` 子句将查询数据排序后再返回数据：  
```sql
SELECT column1, column2, ...
FROM table_name
ORDER BY column1 [ASC | DESC], column2 [ASC | DESC], ...;
```
**参数说明**：  
- `column1, column2, ...` 是你要选择的列的名称，如果使用 `*` 表示选择所有列。  
- `table_name` 是你要从中查询数据的表的名称。  
- `ORDER BY column1 [ASC | DESC], column2 [ASC | DESC], ...` 是用于指定排序顺序的子句。`ASC` 表示升序（默认），`DESC` 表示降序。

**更多说明**：  
- 你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。  
- 你可以设定多个字段来排序。  
- 你可以使用 `ASC` 或 `DESC` 关键字来设置查询结果是按升序或降序排列。默认情况下，它是按升序排列。  
- 你可以添加 `WHERE...LIKE` 子句来设置条件。  

**具体的排序规则由字符规则确定**，事先建库时的编码规则决定了如何排序，可以在查询时重新指定编码规则。

### 实例
以下是一些 `ORDER BY` 子句的使用实例。  

1. 单列排序：  
   ```sql
   SELECT * FROM products
   ORDER BY product_name ASC;
   ```
   以上 SQL 语句将选择产品表 `products` 中的所有产品，并按产品名称升序 `ASC` 排序。

2. 多列排序：  
   ```sql
   SELECT * FROM employees
   ORDER BY department_id ASC, hire_date DESC;
   ```
   以上 SQL 语句将选择员工表 `employees` 中的所有员工，并先按部门 ID 升序 `ASC` 排序，然后在相同部门中按雇佣日期降序 `DESC` 排序。

3. 使用数字表示列的位置：  
   ```sql
   SELECT first_name, last_name, salary
   FROM employees
   ORDER BY 3 DESC, 1 ASC;
   ```
   以上 SQL 语句将选择员工表 `employees` 中的名字和工资列，并按第三列（`salary`）降序 `DESC` 排序，然后按第一列（`first_name`）升序 `ASC` 排序。

4. 使用表达式排序：  
   ```sql
   SELECT product_name, price * discount_rate AS discounted_price
   FROM products
   ORDER BY discounted_price DESC;
   ```
   以上 SQL 语句将选择产品表 `products` 中的产品名称和根据折扣率计算的折扣后价格，并按折扣后价格降序 `DESC` 排序。

5. 从 MySQL 8.0.16 版本开始，可以使用 `NULLS FIRST` 或 `NULLS LAST` 处理 NULL 值：  
   ```sql
   SELECT product_name, price
   FROM products
   ORDER BY price DESC NULLS LAST;
   ```
   以上 SQL 语句将选择产品表 `products` 中的产品名称和价格，并按价格降序 `DESC` 排序，将 NULL 值排在最后。  

   相反，如果你想让 NULL 值排在前面，可以这样写：  
   ```sql
   SELECT product_name, price
   FROM products
   ORDER BY price DESC NULLS FIRST;
   ```

`ORDER BY` 子句是一个强大的工具，可以根据不同的业务需求对查询结果进行排序。在实际应用中，注意选择适当的列和排序顺序，以获得符合期望的排序效果。