# 1.如何在终端向一个文件写入内容？

## 🧩 一、使用输出重定向符号 `>` 和 `>>`

### 1️⃣ 覆盖写入（创建或清空原内容）

```
echo "Hello Linux!" > test.txt
```

🔹 含义：

- 如果 `test.txt` 不存在，会创建该文件；
- 如果存在，会**清空原内容**再写入 `"Hello Linux!"`。

🔹 示例结果：

```
cat test.txt
Hello Linux!
```

------

### 2️⃣ 追加写入（不清空原内容）

```
echo "New line" >> test.txt
```

🔹 含义：
 在 `test.txt` 的末尾**追加**新内容，不影响已有内容。

------

## 🧩 二、使用 `cat` 命令从终端输入文本

### 1️⃣ 手动输入内容

```
cat > file.txt
```

然后输入：

```
Line 1
Line 2
```

结束输入时，按下：

```
Ctrl + D
```

🔹 含义：
 创建或覆盖 `file.txt`，并写入刚才输入的内容。

------

### 2️⃣ 追加模式

```
cat >> file.txt
```

🔹 作用：
 在 `file.txt` 末尾追加新内容，直到按下 `Ctrl + D` 结束。

## 重定向命令输出到文件

你还可以把命令的输出写入文件，例如：

```
ls -l > output.txt
```

🔹 含义：
 将 `ls -l` 的结果保存到 `output.txt`（覆盖写入）。

追加写法：

```
ls -l >> output.txt
```

## 使用vim/vi

## vi/vim 的使用

基本上 vi/vim 共分为三种模式，**命令模式（Command Mode）、输入模式（Insert Mode）和命令行模式（Command-Line Mode）**。

### 命令模式

**用户刚刚启动 vi/vim，便进入了命令模式。**

此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符，比如我们此时按下 **i**，并不会输入一个字符，**i** 被当作了一个命令。

以下是普通模式常用的几个命令：

- **i** -- 切换到输入模式，在光标当前位置开始输入文本。
- **x** -- 删除当前光标所在处的字符。
- **:** -- 切换到底线命令模式，以在最底一行输入命令。
- **a** -- 进入插入模式，在光标下一个位置开始输入文本。
- **o**：在当前行的下方插入一个新行，并进入插入模式。
- **O** -- 在当前行的上方插入一个新行，并进入插入模式。
- **dd** -- 剪切当前行。
- **yy** -- 复制当前行。
- **p**（小写） -- 粘贴剪贴板内容到光标下方。
- **P**（大写）-- 粘贴剪贴板内容到光标上方。
- **u** -- 撤销上一次操作。
- **Ctrl + r** -- 重做上一次撤销的操作。
- **:w** -- 保存文件。
- **:q** -- 退出 Vim 编辑器。
- **:q!** -- 强制退出Vim 编辑器，不保存修改。

若想要编辑文本，只需要启动 Vim，进入了命令模式，按下 **i** 切换到输入模式即可。

命令模式只有一些最基本的命令，因此仍要依靠**底线命令行模式**输入更多命令。

### 输入模式

在命令模式下按下 **i** 就进入了输入模式，使用 **Esc** 键可以返回到普通模式。



在输入模式中，可以使用以下按键：

- **字符按键以及Shift组合**，输入字符
- **ENTER**，回车键，换行
- **BACK SPACE**，退格键，删除光标前一个字符
- **DEL**，删除键，删除光标后一个字符
- **方向键**，在文本中移动光标
- **HOME**/**END**，移动光标到行首/行尾
- **Page Up**/**Page Down**，上/下翻页
- **Insert**，切换光标为输入/替换模式，光标将变成竖线/下划线
- **ESC**，退出输入模式，切换到命令模式

### 底线命令模式

在命令模式下按下 **:**（英文冒号）就进入了底线命令模式。

底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。

在底线命令模式中，基本的命令有（已经省略了冒号）：

- `:w`：保存文件。
- `:q`：退出 Vim 编辑器。
- `:wq`：保存文件并退出 Vim 编辑器。
- `:q!`：强制退出Vim编辑器，不保存修改。

按 **ESC** 键可随时退出底线命令模式。

简单的说，我们可以将这三个模式想成底下的图标来表示：

![img](https://www.runoob.com/wp-content/uploads/2014/07/vim-vi-workmodel.png)

## vi/vim 按键说明

除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。

### 第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等

| 移动光标的方法                                               |                                                              |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| h 或 向左箭头键(←)                                           | 光标向左移动一个字符                                         |
| j 或 向下箭头键(↓)                                           | 光标向下移动一个字符                                         |
| k 或 向上箭头键(↑)                                           | 光标向上移动一个字符                                         |
| l 或 向右箭头键(→)                                           | 光标向右移动一个字符                                         |
| 如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 "30j" 或 "30↓" 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！ |                                                              |
| [Ctrl] + [f]                                                 | 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)          |
| [Ctrl] + [b]                                                 | 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)           |
| [Ctrl] + [d]                                                 | 屏幕『向下』移动半页                                         |
| [Ctrl] + [u]                                                 | 屏幕『向上』移动半页                                         |
| +                                                            | 光标移动到非空格符的下一行                                   |
| -                                                            | 光标移动到非空格符的上一行                                   |
| n<space>                                                     | 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。 |
| 0 或功能键[Home]                                             | 这是数字『 0 』：移动到这一行的最前面字符处 (常用)           |
| $ 或功能键[End]                                              | 移动到这一行的最后面字符处(常用)                             |
| H                                                            | 光标移动到这个屏幕的最上方那一行的第一个字符                 |
| M                                                            | 光标移动到这个屏幕的中央那一行的第一个字符                   |
| L                                                            | 光标移动到这个屏幕的最下方那一行的第一个字符                 |
| G                                                            | 移动到这个档案的最后一行(常用)                               |
| nG                                                           | n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) |
| gg                                                           | 移动到这个档案的第一行，相当于 1G 啊！ (常用)                |
| n<Enter>                                                     | n 为数字。光标向下移动 n 行(常用)                            |
| 搜索替换                                                     |                                                              |
| /word                                                        | 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) |
| ?word                                                        | 向光标之上寻找一个字符串名称为 word 的字符串。               |
| n                                                            | 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ |
| N                                                            | 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 |
| 使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！ |                                                              |
| :n1,n2s/word1/word2/g                                        | n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用) |
| **:1,$s/word1/word2/g** 或 **:%s/word1/word2/g**             | 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) |
| **:1,$s/word1/word2/gc** 或 **:%s/word1/word2/gc**           | 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用) |
| 删除、复制与贴上                                             |                                                              |
| x, X                                                         | 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) |
| nx                                                           | n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 |
| dd                                                           | 剪切游标所在的那一整行(常用)，用 p/P 可以粘贴。              |
| ndd                                                          | n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p/P 可以粘贴。 |
| d1G                                                          | 删除光标所在到第一行的所有数据                               |
| dG                                                           | 删除光标所在到最后一行的所有数据                             |
| d$                                                           | 删除游标所在处，到该行的最后一个字符                         |
| d0                                                           | 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符      |
| yy                                                           | 复制游标所在的那一行(常用)                                   |
| nyy                                                          | n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) |
| y1G                                                          | 复制游标所在行到第一行的所有数据                             |
| yG                                                           | 复制游标所在行到最后一行的所有数据                           |
| y0                                                           | 复制光标所在的那个字符到该行行首的所有数据                   |
| y$                                                           | 复制光标所在的那个字符到该行行尾的所有数据                   |
| p, P                                                         | p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用) |
| J                                                            | 将光标所在行与下一行的数据结合成同一行                       |
| c                                                            | 重复删除多个数据，例如向下删除 10 行，[ 10cj ]               |
| u                                                            | 复原前一个动作。(常用)                                       |
| [Ctrl]+r                                                     | 重做上一个动作。(常用)                                       |
| 这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！ |                                                              |
| .                                                            | 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用) |

### 第二部分：一般模式切换到编辑模式的可用的按钮说明

| 进入输入或取代的编辑模式                                     |                                                              |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| i, I                                                         | 进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用) |
| a, A                                                         | 进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用) |
| o, O                                                         | 进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用) |
| r, R                                                         | 进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用) |
| 上面这些按键中，在 vi 画面的左下角处会出现『--INSERT--』或『--REPLACE--』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！ |                                                              |
| [Esc]                                                        | 退出编辑模式，回到一般模式中(常用)                           |

### 第三部分：一般模式切换到指令行模式的可用的按钮说明

| 指令行的储存、离开等指令                                     |                                                              |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| :w                                                           | 将编辑的数据写入硬盘档案中(常用)                             |
| :w!                                                          | 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ |
| :q                                                           | 离开 vi (常用)                                               |
| :q!                                                          | 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。    |
| 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ |                                                              |
| :wq                                                          | 储存后离开，若为 :wq! 则为强制储存后离开 (常用)              |
| ZZ                                                           | 这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出) |
| ZQ                                                           | 不保存，强制退出。效果等同于 **:q!**。                       |
| :w [filename]                                                | 将编辑的数据储存成另一个档案（类似另存新档）                 |
| :r [filename]                                                | 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 |
| :n1,n2 w [filename]                                          | 将 n1 到 n2 的内容储存成 filename 这个档案。                 |
| :! command                                                   | 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！ |
| vim 环境的变更                                               |                                                              |
| :set nu                                                      | 显示行号，设定之后，会在每一行的前缀显示该行的行号           |
| :set nonu                                                    | 与 set nu 相反，为取消行号！                                 |

特别注意，在 vi/vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。

举例来说，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。

# 2.grep，sort, wc,uniq,cut命令--**文本处理的核心工具**。

# 🧩 一、命令功能概览

| 命令   | 全称                            | 主要功能                             | 示例                     |
| ------ | ------------------------------- | ------------------------------------ | ------------------------ |
| `grep` | Global Regular Expression Print | 在文件中查找符合模式（pattern）的行  | `grep "error" log.txt`   |
| `sort` | sort                            | 对文本行排序                         | `sort names.txt`         |
| `uniq` | unique                          | 去除相邻重复行（通常和 `sort` 联用） | `uniq users.txt`         |
| `wc`   | word count                      | 统计行数、单词数、字节数             | `wc -l file.txt`         |
| `cut`  | cut                             | 从每一行中提取字段                   | `cut -d',' -f2 data.csv` |

# 🧩 三、各命令详讲与典型组合

## 1️⃣ `grep` —— 文本过滤器

```
grep "error" system.log
```

👉 输出所有包含 “error” 的行。

常用参数：

- `-i`：忽略大小写
- `-n`：显示行号
- `-v`：反选（显示不匹配的行）
- `-r`：递归搜索目录

------

## 2️⃣ `sort` —— 排序工具

```
sort file.txt
```

👉 默认对行按字典序升序排列。

常用参数：

- `-r`：逆序排列
- `-n`：按数值大小排序
- `-k`：指定列排序
   例：`sort -k2n file.txt` 表示按第 2 列的数值排序

# 例子

### 🌟 示例：对学生成绩文件排序

内容：

```
Alice,Math,85
Bob,Math,92
Alice,English,78
Bob,English,88
```

按**姓名 + 成绩（数值）**排序：

```
sort -t',' -k1,1 -k3,3n students.csv
```

输出：

```
Alice,English,78
Alice,Math,85
Bob,English,88
Bob,Math,92
```

🔹 `-t','` 指明分隔符是逗号
 🔹 `-k1,1` 按第一列（名字）排序
 🔹 `-k3,3n` 按第三列（成绩数值）排序

------

## 3️⃣ `uniq` —— 去除重复行

```
uniq file.txt
```

👉 删除**相邻的**重复行。
 ⚠️ 所以通常要先 `sort` 才能正确去重：

```
sort file.txt | uniq
```

常用参数：

- `-c`：统计每行出现次数
- `-d`：仅显示重复的行
- `-u`：仅显示唯一的行

------

## 4️⃣ `wc` —— 统计命令

```
wc file.txt
```

输出格式：

```
行数  单词数  字节数
```

常用参数：

- `-l`：只统计行数
- `-w`：只统计单词数
- `-c`：只统计字节数

------

## 5️⃣ `cut` —— 字段提取工具

```
cut -d',' -f2 data.csv
```

👉 用逗号作为分隔符，提取第二列。

常用参数：

- `-d`：指定分隔符
- `-f`：指定字段号
- `-c`：按字符位置截取，如 `cut -c 1-5 file.txt`

# 3.**重定向 管道 流**

在 Linux 中一个命令的去向可以有 3 个地方：终端、文件、作为另外一个命令的入参。

![img](https://i-blog.csdnimg.cn/blog_migrate/c6717cc34cb8a303691609c669c1e34c.jpeg)

命令一般都是通过键盘输入，然后输出到终端、文件等地方，它的标准用语是 stdin 、 stdout 以及 stderr 。

- 标准输入`stdin`，终端接收键盘输入的命令，会产生两种输出；
- 标准输出`stdout`，终端输出的信息（不包含错误信息）；
- 标准错误输出`stderr` ，终端输出的错误信息。

![img](https://i-blog.csdnimg.cn/blog_migrate/75cecdc3df1ae325a9b4af845d335a1d.jpeg)

**重定向**

把本来要显示在终端的命令结果，输送到别的地方（到文件中或者作为其他命令的输入）。

**输出重定向 >**

`>`表示重定向到新的文件，`cut -d , -f 1 notes.csv > name.csv`，它表示通过逗号剪切`notes.csv`文件（剪切完有 3 个部分）获取第一个部分，重定向到`name.csv`文件。

我们来看一个具体示例，学习它的使用，假设我们有一个文件`notes.csv`，文件内容如下：

```
Mark1,951/100,很不错1  
Mark2,952/100,很不错2  
Mark3,953/100,很不错3  
Mark4,954/100,很不错4  
Mark5,955/100,很不错5  
Mark6,956/100,很不错6 
```

执行命令：cut -d , -f 1 notes.csv > name.csv 最后输出如下内容：

```
Mark1  
Mark2  
Mark3  
Mark4  
Mark5  
Mark6
```

【注意】使用`>`要注意，如果输出的文件不存在它会新建一个，如果输出的文件已经存在，则会覆盖。因此执行这个操作要非常小心，以免覆盖其它重要文件。

**输出重定向** `>>`

表示重定向到文件末尾，因此它不会像 > 命令这么危险，它是追加到文件的末尾（当然如果文件不存在，也会被创建）。

再次执行`cut -d , -f 1 notes.csv >> name.csv`，则会把名字追加到 `name.csv`里面。

```
Mark1  
Mark2  
Mark3  
Mark4  
Mark5  
Mark6  
Mark1  
Mark2  
Mark3  
Mark4  
Mark5  
Mark6  
```

我们平时读的 log 日志文件其实都是用这个命令输出的。

**输出重定向 2>**

标准错误输出

```
cat not_exist_file.csv > res.txt 2> errors.log 
```

- 当我们`cat`一个文件时，会把文件内容打印到屏幕上，这个是标准输出；
- 当使用了`> res.txt`时，则不会打印到屏幕，会把标准输出写入文件 `res.txt`文件中；
- `2> errors.log`当发生错误时会写入`errors.log`文件中。

**输出重定向** `2>>`

标准错误输出（追加到文件末尾）同 >> 相似。

**输出重定向** `2>&1`

标准输出和标准错误输出都重定向都一个地方

```
cat not_exist_file.csv > res.txt 2>&1  # 覆盖输出  
cat not_exist_file.csv >> res.txt 2>&1 # 追加输出  
```

目前为止，我们接触的命令的输入都来自命令的参数，其实命令的输入还可以来自文件或者键盘的输入。

![img](https://i-blog.csdnimg.cn/blog_migrate/ee4a839f4cc551302987417abda00726.jpeg)

**输入重定向** `<`

`<`符号用于指定命令的输入。

```
cat < name.csv # 指定命令的输入为 name.csv  
```

虽然它的运行结果与`cat name.csv`一样，但是它们的原理却完全不同。

- `cat name.csv`表示`cat`命令接收的输入是`notes.csv`文件名，那么要先打开这个文件，然后打印出文件内容。
- `cat < name.csv` 表示`cat`命令接收的输入直接是`notes.csv`这个文件的内容，`cat`命令只负责将其内容打印，打开文件并将文件内容传递给 `cat`命令的工作则交给终端完成。

**输入重定向** `<<`

将键盘的输入重定向为某个命令的输入。

```
sort -n << END # 输入这个命令之后，按下回车，终端就进入键盘输入模式，其中END为结束命令（这个可以自定义）  
  
wc -m << END # 统计输入的单词  
```

## 🧩 一、输入重定向的本质意义

> 🔹一句话总结：**输入重定向让命令“从别的地方读数据”，而不是从键盘读。**

也就是说：

- 默认情况下，命令从 **标准输入（stdin）** 读数据；
- 使用输入重定向后，你可以：
  - 让命令从**文件**读取；
  - 或让命令从**一段脚本文本**读取；
  - 或让命令从**字符串变量**读取。

🧠 **意义**在于：
 它让命令变得“自动化”、“可编程”、“批处理化”——不再需要人类手动输入内容。

------

## 🧩 二、具体使用场景与示例

我们分 3 种情况讲解，每一种都配上“命令、效果、意义”。

------

### ✅ 场景 1：命令本身需要交互输入 —— 用 `< 文件` 自动提供输入

#### 📘 示例：

```
sort < numbers.txt
```

等价于你运行 `sort` 后手动输入数字再按 Ctrl+D。
 🔹 **意义**：批量化处理文件输入，不用手动输入。

------

#### 📘 再看一个更有意义的例子：

某些命令默认要求你手动输入内容，例如 `mysql`、`ftp`、`python` 等。

```
mysql -u root -p < init.sql
```

🔹 **解释：**

- 通常我们要进入 MySQL 提示符里输入 SQL 语句；
- 现在用 `<` 就能直接把 `init.sql` 文件的内容输入到 `mysql` 程序中；
- 实现自动执行脚本。

🔹 **使用意义：**
 👉 这就是**自动化执行数据库初始化脚本**的关键机制。
 无人工干预即可导入大量命令或配置。

------

### ✅ 场景 2：命令需要临时输入多行数据 —— 用 `<<` (Here Document)

#### 📘 示例：

```
cat << EOF > welcome.txt
Hello $(whoami)!
Welcome to $(hostname)!
EOF
```

🔹 **解释：**

- `cat << EOF` 表示：接下来的输入行作为 cat 的标准输入；
- 一直到遇到 `EOF` 结束；
- `> welcome.txt` 表示输出到文件；
- `$(whoami)`、`$(hostname)` 是 shell 变量，会自动展开。

🔹 **生成结果：**

```
Hello sheldon!
Welcome to sheldon-virtual-machine!
```

🔹 **使用意义：**
 👉 常用于 **脚本自动生成配置文件**、**模板文件**、**批量命令输入**。

------

#### 📘 再看一个更专业场景：

在脚本中需要给命令输入多行数据：

```
ftp -n << EOF
open ftp.example.com
user testuser testpass
cd /upload
put file.txt
bye
EOF
```

🔹 作用：模拟人工 FTP 操作，实现 **无人值守文件上传**。

------

### ✅ 场景 3：命令只需要一行输入 —— 用 `<<<` (Here String)

#### 📘 示例：

```
wc -w <<< "Linux shell scripting"
```

输出：

```
3
```

🔹 **意义：**
 比 `echo "..." | wc -w` 更简洁；
 尤其在脚本中可以直接传入变量：

```
wc -m <<< "$USER logged in"
```

🔹 **典型场景：**

- 简单传入一行字符串；
- 测试命令或变量；
- 避免创建临时文件或使用管道。



# 4.**管道**`|`

把两个命令连起来使用，一个命令的输出作为另外一个命令的输入，英文是 `pipeline`，可以想象一个个水管连接起来，管道算是重定向流的一种。

![img](https://i-blog.csdnimg.cn/blog_migrate/78420878923c8af58c16aec7cd02bebe.jpeg)

举几个实际用法案例：

```
cut -d , -f 1 name.csv | sort > sorted_name.txt   
# 第一步获取到的 name 列表，通过管道符再进行排序，最后输出到sorted_name.txt  
  
du | sort -nr | head   
# du 表示列举目录大小信息  
# sort 进行排序,-n 表示按数字排序，-r 表示倒序  
# head 前10行文件  
  
grep log -Ir /var/log | cut -d : -f 1 | sort | uniq  
# grep log -Ir /var/log 表示在/var/log文件夹下搜索 log 文本，-r 表示递归，-I 用于排除二进制文件  
# cut -d : -f 1 表示通过冒号进行剪切，获取剪切的第一部分  
# sort 进行排序  
# uniq 进行去重  
```

**流**

流并非一个命令，在计算机科学中，流 stream 的含义是比较难理解的，记住一点即可：流就是读一点数据, 处理一点点数据。其中数据一般就是二进制格式。上面提及的重定向或管道，就是把数据当做流去运转的。

到此我们就接触了，流、重定向、管道等 Linux 高级概念及指令。其实你会发现关于流和管道在其它语言中也有广泛的应用。Angular 中的模板语法中可以使用管道。Node.js 中也有 stream 流的概念。

# 5.与进程相关的命令

## **w**（who）

帮助我们快速了解系统中目前有哪些用户登录着，以及他们在干什么。

### 命令输出

```
sheldon@sheldon-virtual-machine:~/Desktop$ w
 16:48:28 up  1:56,  1 user,  load average: 0.05, 0.02, 0.00
USER     TTY      来自           LOGIN@   IDLE   JCPU   PCPU WHAT
sheldon  tty2     tty2             14:52    1:55m  0.08s  0.08s /usr/libexec/gn
```

------

### 一、第一行 —— 系统总体状态行

```
16:48:28 up  1:56,  1 user,  load average: 0.05, 0.02, 0.00
```

这是 **系统级信息（uptime信息）**。
 逐项说明如下：

| 字段                               | 含义                                              |
| ---------------------------------- | ------------------------------------------------- |
| **16:48:28**                       | 当前系统时间（当前时钟时间）                      |
| **up 1:56**                        | 系统已运行 1 小时 56 分钟（从上次启动起）         |
| **1 user**                         | 当前只有 1 位用户已登录系统                       |
| **load average: 0.05, 0.02, 0.00** | 系统在最近 1、5、15 分钟内的平均负载（CPU繁忙度） |

### 🧠 小补充：

- 平均负载（load average）表示平均**可运行进程数**。
  - 对单核系统，`1.0` 表示刚好满载；
  - 对四核系统，`4.0` 表示满载；
  - 你的值都接近 `0` → 系统几乎空闲。✅

### 二、第二行 —— 表头

```
USER     TTY      来自           LOGIN@   IDLE   JCPU   PCPU WHAT
```

这行是列标题，下面的每一行都对应一个登录会话（用户终端）。

------

### 三、第三行 —— 用户会话信息

```
sheldon  tty2     tty2             14:52    1:55m  0.08s  0.08s /usr/libexec/gn
```

我们逐列解释👇：

| 列名            | 示例值          | 说明                                                         |
| --------------- | --------------- | ------------------------------------------------------------ |
| **USER**        | sheldon         | 当前登录的用户名                                             |
| **TTY**         | tty2            | 表示该用户使用的终端设备。 本地登录通常是 `tty1`, `tty2` 等； 远程SSH登录则会显示 `pts/0`, `pts/1`。 |
| **来自 (FROM)** | tty2            | 表示登录来源。 这里是 `tty2`，意味着本地控制台登录（不是从其他主机）。 若是远程登录，会显示 IP 或主机名。 |
| **LOGIN@**      | 14:52           | 用户登录系统的时间（下午2点52分）                            |
| **IDLE**        | 1:55m           | 用户空闲时间，即多久没有键盘/鼠标操作。 1小时55分钟没操作。  |
| **JCPU**        | 0.08s           | 当前终端下所有进程的 CPU 占用总时间（包括后台任务）。        |
| **PCPU**        | 0.08s           | 当前正在执行命令的 CPU 时间（更精确）。                      |
| **WHAT**        | /usr/libexec/gn | 用户当前正在运行的命令（被截断了）。 完整命令应该是 `/usr/libexec/gnome-session-binary`，即桌面会话进程。 |

输出可以翻译成如下自然语言：

> 当前系统时间是 **16:48:28**，系统已运行 **1小时56分钟**，只有一个用户（sheldon）登录。
>  系统负载非常轻（平均0.05）。
>  用户 sheldon 在 **tty2** 控制台登录，于 **14:52** 登录，已 **空闲近两小时**，当前运行的进程为 **gnome 桌面会话进程**。

### 🧠 延伸说明：TTY 与 FROM 的含义

| 登录方式 | TTY 示例                                 | FROM 显示    | 含义           |
| -------- | ---------------------------------------- | ------------ | -------------- |
| 本地登录 | tty1, tty2                               | - 或 tty2    | 本机物理控制台 |
| SSH 登录 | pts/0, pts/1                             | 192.168.x.x  | 远程终端       |
| GUI 登录 | tty2 + /usr/libexec/gnome-session-binary | 本地桌面环境 |                |

## **ps**（process status）

用于显示当前系统中的进程， ps 命令显示的进程列表不会随时间而更新，是静态的，是运行 ps 命令那个时刻的状态或者说是一个进程快照。

### **常用参数**

- | 命令               | 含义                                                     |
  | ------------------ | -------------------------------------------------------- |
  | `ps`               | 查看**当前终端（TTY）**中的进程                          |
  | `ps -e` 或 `ps -A` | 查看**系统中所有进程**（`e` = every process）            |
  | `ps -f`            | 显示完整格式（`f` = full format）                        |
  | `ps -ef`           | **显示所有进程（完整格式）** —— 常用组合                 |
  | `ps -efH`          | 显示所有进程（完整格式 + 分层树状结构）                  |
  | `ps aux`           | 另一种风格的参数格式（BSD 风格），按 CPU、内存使用率排序 |

默认情况下，`ps` **只显示当前终端 (TTY)** 下启动的进程，
 即你当前这个 shell 和你刚执行的 `ps` 命令本身。

示例输出：

```
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 08:00 ?        00:00:02 /sbin/init
sheldon     1745    1500  0 09:00 pts/0    00:00:00 bash
sheldon     1892    1745  0 09:02 pts/0    00:00:00 ps -ef
```

解释如下：

| 列名      | 含义                           |
| --------- | ------------------------------ |
| **UID**   | 启动该进程的用户               |
| **PID**   | 进程 ID（唯一标识）            |
| **PPID**  | 父进程 ID                      |
| **C**     | CPU 占用率（最近短时间的平均） |
| **STIME** | 进程启动时间                   |
| **TTY**   | 该进程绑定的终端               |
| **TIME**  | 进程累计使用的 CPU 时间        |
| **CMD**   | 启动进程的命令行               |



## `top` 命令 —— 实时进程监控器

### 🧩 1️⃣ 命令全称

`top` = **table of processes**（进程表）
 它会**动态更新**显示系统的资源使用状况。

------

### 📊 2️⃣ 基本用法

```
top
```

会进入一个实时刷新的界面（默认每 3 秒刷新一次）：

```
top - 17:02:15 up  2:10,  1 user,  load average: 0.05, 0.02, 0.00
Tasks: 179 total,   1 running, 178 sleeping,   0 stopped,   0 zombie
%Cpu(s):  1.3 us,  0.3 sy,  0.0 ni, 98.0 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :   7856.0 total,   1920.0 free,   3120.0 used,   2816.0 buff/cache
PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
1734 sheldon  20   0 1532484  81324  55120 S   2.3  1.0   0:02.33 gnome-shell
```

------

### 🔍 3️⃣ 上半部分 —— 系统状态区

| 行     | 内容                                      | 说明 |
| ------ | ----------------------------------------- | ---- |
| 第一行 | 系统时间、运行时长、在线用户、平均负载    |      |
| 第二行 | 任务统计（总数、运行、睡眠、僵尸等）      |      |
| 第三行 | CPU 各类占比（us=用户，sy=内核，id=空闲） |      |
| 第四行 | 内存占用（物理内存）                      |      |
| 第五行 | Swap 交换空间占用                         |      |

📘 “load average”：
 表示过去 1、5、15 分钟的平均负载
 一般认为 ≤ CPU 核数 是健康的。

------

### 🧾 4️⃣ 下半部分 —— 进程列表区

| 列名    | 含义                           |
| ------- | ------------------------------ |
| PID     | 进程 ID                        |
| USER    | 所属用户                       |
| PR      | 进程优先级（priority）         |
| NI      | nice 值（影响优先级）          |
| VIRT    | 虚拟内存占用                   |
| RES     | 实际占用内存（resident）       |
| SHR     | 共享内存大小                   |
| S       | 状态（S=休眠，R=运行，Z=僵尸） |
| %CPU    | CPU 使用率                     |
| %MEM    | 内存使用率                     |
| TIME+   | 累计占用 CPU 时间              |
| COMMAND | 进程名称或命令                 |

------

### ⌨️ 5️⃣ 常用交互操作（在 top 界面中）

| 键   | 功能                      |
| ---- | ------------------------- |
| `P`  | 按 CPU 占用率排序（默认） |
| `M`  | 按内存占用率排序          |
| `T`  | 按运行时间排序            |
| `k`  | 杀死某个进程（输入 PID）  |
| `r`  | 改变某进程的 nice 值      |
| `q`  | 退出 top                  |

------

### 🧠 6️⃣ 常用参数

| 参数        | 含义                      |
| ----------- | ------------------------- |
| `-d 秒数`   | 设置刷新间隔（默认 3 秒） |
| `-p PID`    | 只监控特定 PID            |
| `-n 次数`   | 刷新指定次数后自动退出    |
| `-u 用户名` | 仅显示该用户的进程        |

示例：

```
top -u sheldon -d 2
```

👉 每 2 秒刷新一次，只看用户 sheldon 的进程。



## `kill` 命令 —— 终止或控制进程

### 🧩 1️⃣ 命令全称

`kill` = **send a signal to a process**（向进程发送信号）。

它的名字叫 “杀死”，
 但其实不仅能“杀死”，也能“暂停”“继续”等。

------

### 🧠 2️⃣ Linux 信号机制概念

每个进程都可以收到来自系统或用户的 **信号（signal）**。
 信号是内核与进程通信的方式，用数字或名字表示。

常见信号表：

| 信号名    | 编号 | 作用                               |
| --------- | ---- | ---------------------------------- |
| `SIGHUP`  | 1    | 重新加载配置（常用于守护进程）     |
| `SIGINT`  | 2    | 中断（等价于 Ctrl + C）            |
| `SIGKILL` | 9    | 强制终止（不可被捕获）             |
| `SIGTERM` | 15   | 请求终止（默认信号，可被程序处理） |
| `SIGSTOP` | 19   | 暂停（等价于 Ctrl + Z）            |
| `SIGCONT` | 18   | 继续执行暂停的进程                 |

------

### ⚙️ 3️⃣ 基本用法

| 命令             | 含义                           |
| ---------------- | ------------------------------ |
| `kill PID`       | 发送 `SIGTERM`（15），请求终止 |
| `kill -9 PID`    | 发送 `SIGKILL`，强制终止       |
| `kill -STOP PID` | 暂停该进程                     |
| `kill -CONT PID` | 恢复该进程                     |

示例：

```
kill -9 12345
```

👉 强制杀死进程号 12345。

🧩 4️⃣ 辅助命令

|                  |                            |
| ---------------- | -------------------------- |
| 命令             | 作用                       |
| `killall 进程名` | 按名称结束所有同名进程     |
| `pkill 关键字`   | 模糊匹配进程名并结束       |
| `xkill`          | （图形化）点击窗口关闭进程 |

## 系统关联 —— ps、top、kill 的逻辑链

| 命令          | 功能                   | 常见搭配     |
| ------------- | ---------------------- | ------------ |
| `ps -ef       | grep 进程名`           | 查找进程 PID |
| `top`         | 动态观察 CPU、内存占用 | 确认是否卡死 |
| `kill -9 PID` | 强制终止               | 结束问题进程 |